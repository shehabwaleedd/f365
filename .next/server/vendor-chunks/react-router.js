"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/react-router/dist/index.js":
/*!********************************************************!*\
  !*** ../../../node_modules/react-router/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* binding */ Await),\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* binding */ DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* binding */ DataRouterStateContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   UNSAFE_mapRouteProperties: () => (/* binding */ mapRouteProperties),\n/* harmony export */   UNSAFE_useRouteId: () => (/* binding */ useRouteId),\n/* harmony export */   UNSAFE_useRoutesImpl: () => (/* binding */ useRoutesImpl),\n/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   defer: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   unstable_useBlocker: () => (/* binding */ useBlocker),\n/* harmony export */   useActionData: () => (/* binding */ useActionData),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useMatches: () => (/* binding */ useMatches),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),\n/* harmony export */   useRouteError: () => (/* binding */ useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"(ssr)/../../../node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router v6.11.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nconst DataRouterContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    AwaitContext.displayName = \"Await\";\n}\nconst NavigationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nif (true) {\n    RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    RouteErrorContext.displayName = \"RouteError\";\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */ function useHref(to, _temp) {\n    let { relative } = _temp === void 0 ? {} : _temp;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { basename, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { hash, pathname, search } = useResolvedPath(to, {\n        relative\n    });\n    let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search,\n        hash\n    });\n}\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */ function useInRouterContext() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */ function useLocation() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\n}\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */ function useNavigationType() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;\n}\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/hooks/use-match\n */ function useMatch(pattern) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { pathname } = useLocation();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)(pattern, pathname), [\n        pathname,\n        pattern\n    ]);\n}\n/**\n * The interface for the navigate() function returned from useNavigate().\n */ const navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\"; // Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n    let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;\n    if (!isStatic) {\n        // We should be able to get rid of this once react 18.3 is released\n        // See: https://github.com/facebook/react/pull/26395\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\n    }\n}\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */ function useNavigate() {\n    let { isDataRoute } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext); // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    let { basename, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getPathContributingMatches)(matches).map((match)=>match.pathnameBase));\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0; // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our history listener yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\"); // If we're operating within a basename, prepend it to the pathname prior\n        // to handing off to history (but only if we're not in a data router,\n        // otherwise it'll prepend the basename inside of the router).\n        // If this is a root navigation, then we navigate to the raw basename\n        // which allows the basename to have full control over the presence of a\n        // trailing slash on root links\n        if (dataRouterContext == null && basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname,\n        dataRouterContext\n    ]);\n    return navigate;\n}\nconst OutletContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */ function useOutletContext() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */ function useOutlet(context) {\n    let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */ function useParams() {\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */ function useResolvedPath(to, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getPathContributingMatches)(matches).map((match)=>match.pathnameBase));\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */ function useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n} // Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches: parentMatches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    if (true) {\n        // You won't get a warning about 2 different <Routes> under a <Route>\n        // without a trailing *, but this is a best-effort warning anyway since we\n        // cannot even give the warning unless they land at the parent route.\n        //\n        // Example:\n        //\n        // <Routes>\n        //   {/* This route path MUST end with /* because otherwise\n        //       it will never match /blog/post/123 */}\n        //   <Route path=\"blog\" element={<Blog />} />\n        //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n        // </Routes>\n        //\n        // function Blog() {\n        //   return (\n        //     <Routes>\n        //       <Route path=\"post/:id\" element={<Post />} />\n        //     </Routes>\n        //   );\n        // }\n        let parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + ('\"' + parentPathname + '\" (under <Route path=\"' + parentPath + '\">) but the ') + 'parent route path has no trailing \"*\". This means if you navigate ' + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + ('Please change the parent <Route path=\"' + parentPath + '\"> to <Route ') + ('path=\"' + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + '\">.'));\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n        var _parsedLocationArg$pa;\n        let parsedLocationArg = typeof locationArg === \"string\" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;\n        !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + ('matched by all parent routes. The current pathname base is \"' + parentPathnameBase + '\" ') + ('but pathname \"' + parsedLocationArg.pathname + '\" was given in the `location` prop.')) : 0 : void 0;\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(routes, {\n        pathname: remainingPathname\n    });\n    if (true) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(parentRoute || matches != null, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ') : 0;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" ' + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + 'null value by default resulting in an \"empty\" page.') : 0;\n    }\n    let renderedMatches = _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n            ])\n        })), parentMatches, dataRouterState); // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n            value: {\n                location: _extends({\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\"\n                }, location),\n                navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop\n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    let codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    if (true) {\n        console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n        devInfo = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error: error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        // When we get into an error state, the user will likely click \"back\" to the\n        // previous page that didn't have an error. Because this wraps the entire\n        // application, that will have no effect--the error page continues to display.\n        // This gives us a mechanism to recover from the error when the location changes.\n        //\n        // Whether we're in an error state or not, we update the location in state\n        // so that when we are in an error state, it gets reset when a new location\n        // comes in and the user recovers from the error.\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n            return {\n                error: props.error,\n                location: props.location,\n                revalidation: props.revalidation\n            };\n        } // If we're not changing locations, preserve the location but still surface\n        // any new errors that may come through. We retain the existing error, we do\n        // this because the error provided from the app state may be cleared without\n        // the location changing.\n        return {\n            error: props.error || state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        return this.state.error ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n            value: this.props.routeContext\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    }\n}\nfunction RenderedRoute(_ref) {\n    let { routeContext, match, children } = _ref;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext); // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState) {\n    var _dataRouterState2;\n    if (parentMatches === void 0) {\n        parentMatches = [];\n    }\n    if (dataRouterState === void 0) {\n        dataRouterState = null;\n    }\n    if (matches == null) {\n        var _dataRouterState;\n        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n            // Don't bail if we have data router errors so we can render them in the\n            // boundary.  Use the pre-matched (or shimmed) matches\n            matches = dataRouterState.matches;\n        } else {\n            return null;\n        }\n    }\n    let renderedMatches = matches; // If we have data errors, trim matches to the highest error boundary\n    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n    if (errors != null) {\n        let errorIndex = renderedMatches.findIndex((m)=>m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n        !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : 0 : void 0;\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    return renderedMatches.reduceRight((outlet, match, index)=>{\n        let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null; // Only data routers handle errors\n        let errorElement = null;\n        if (dataRouterState) {\n            errorElement = match.route.errorElement || defaultErrorElement;\n        }\n        let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        let getChildren = ()=>{\n            let children;\n            if (error) {\n                children = errorElement;\n            } else if (match.route.Component) {\n                // Note: This is a de-optimized path since React won't re-use the\n                // ReactElement since it's identity changes with each new\n                // React.createElement call.  We keep this so folks can use\n                // `<Route Component={...}>` in `<Routes>` but generally `Component`\n                // usage is only advised in `RouterProvider` when we can convert it to\n                // `element` ahead of time.\n                children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\n            } else if (match.route.element) {\n                children = match.route.element;\n            } else {\n                children = outlet;\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {\n                match: match,\n                routeContext: {\n                    outlet,\n                    matches,\n                    isDataRoute: dataRouterState != null\n                },\n                children: children\n            });\n        }; // Only wrap in an error boundary within data router usages when we have an\n        // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n        // an ancestor ErrorBoundary/errorElement\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error: error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nvar DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n    !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\nfunction useRouteContext(hookName) {\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return route;\n} // Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, hookName + ' can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    return thisRoute.route.id;\n}\n/**\n * Returns the ID for the nearest contextual route\n */ function useRouteId() {\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */ function useNavigation() {\n    let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n}\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */ function useRevalidator() {\n    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return {\n        revalidate: dataRouterContext.router.revalidate,\n        state: state.revalidation\n    };\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */ function useMatches() {\n    let { matches, loaderData } = useDataRouterState(DataRouterStateHook.UseMatches);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>matches.map((match)=>{\n            let { pathname, params } = match; // Note: This structure matches that created by createUseMatchesMatch\n            // in the @remix-run/router , so if you change this please also change\n            // that :)  Eventually we'll DRY this up\n            return {\n                id: match.route.id,\n                pathname,\n                params,\n                data: loaderData[match.route.id],\n                handle: match.route.handle\n            };\n        }), [\n        matches,\n        loaderData\n    ]);\n}\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */ function useLoaderData() {\n    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n        console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n        return undefined;\n    }\n    return state.loaderData[routeId];\n}\n/**\n * Returns the loaderData for the given routeId\n */ function useRouteLoaderData(routeId) {\n    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n}\n/**\n * Returns the action data for the nearest ancestor Route action\n */ function useActionData() {\n    let state = useDataRouterState(DataRouterStateHook.UseActionData);\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"useActionData must be used inside a RouteContext\") : 0 : void 0;\n    return Object.values((state == null ? void 0 : state.actionData) || {})[0];\n}\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */ function useRouteError() {\n    var _state$errors;\n    let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\n    let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError); // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error) {\n        return error;\n    } // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */ function useAsyncValue() {\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n}\n/**\n * Returns the error from the nearest ancestor <Await /> value\n */ function useAsyncError() {\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */ function useBlocker(shouldBlock) {\n    let { router } = useDataRouterContext(DataRouterHook.UseBlocker);\n    let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n    let [blockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>String(++blockerId));\n    let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args)=>{\n        return typeof shouldBlock === \"function\" ? !!shouldBlock(args) : !!shouldBlock;\n    }, [\n        shouldBlock\n    ]);\n    let blocker = router.getBlocker(blockerKey, blockerFunction); // Cleanup on unmount\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>()=>router.deleteBlocker(blockerKey), [\n        router,\n        blockerKey\n    ]); // Prefer the blocker from state since DataRouterContext is memoized so this\n    // ensures we update on blocker state updates\n    return state.blockers.get(blockerKey) || blocker;\n}\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */ function useNavigateStable() {\n    let { router } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0; // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our router subscriber yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            router.navigate(to);\n        } else {\n            router.navigate(to, _extends({\n                fromRouteId: id\n            }, options));\n        }\n    }, [\n        router,\n        id\n    ]);\n    return navigate;\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, message) : 0;\n    }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    let { fallbackElement, router } = _ref;\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]); // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: router.basename,\n        location: router.state.location,\n        navigationType: router.state.historyAction,\n        navigator: navigator\n    }, router.state.initialized ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n        routes: router.routes,\n        state: state\n    }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n    let { routes, state } = _ref2;\n    return useRoutesImpl(routes, undefined, state);\n}\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */ function MemoryRouter(_ref3) {\n    let { basename, children, initialEntries, initialIndex } = _ref3;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries,\n            initialIndex,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */ function Navigate(_ref4) {\n    let { to, replace, state, relative } = _ref4;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(!react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let navigate = useNavigate(); // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getPathContributingMatches)(matches).map((match)=>match.pathnameBase), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>navigate(JSON.parse(jsonPath), {\n            replace,\n            state,\n            relative\n        }), [\n        navigate,\n        jsonPath,\n        relative,\n        replace,\n        state\n    ]);\n    return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */ function Outlet(props) {\n    return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */ function Route(_props) {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */ function Router(_ref5) {\n    let { basename: basenameProp = \"/\", children = null, location: locationProp, navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop, navigator, static: staticProp = false } = _ref5;\n    !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0; // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            basename,\n            navigator,\n            static: staticProp\n        }), [\n        basename,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);\n    }\n    let { pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\" } = locationProp;\n    let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            location: {\n                pathname: trailingPathname,\n                search,\n                hash,\n                state,\n                key\n            },\n            navigationType\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key,\n        navigationType\n    ]);\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(locationContext != null, '<Router basename=\"' + basename + '\"> is not able to match the URL ' + ('\"' + pathname + search + hash + '\" because it does not start with the ') + \"basename, so the <Router> won't render anything.\") : 0;\n    if (locationContext == null) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n        children: children,\n        value: locationContext\n    }));\n}\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */ function Routes(_ref6) {\n    let { children, location } = _ref6;\n    return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */ function Await(_ref7) {\n    let { children, errorElement, resolve } = _ref7;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, {\n        resolve: resolve,\n        errorElement: errorElement\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus;\n(function(AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n})(AwaitRenderStatus || (AwaitRenderStatus = {}));\nconst neverSettledPromise = new Promise(()=>{});\nclass AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: null\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        let { children, errorElement, resolve } = this.props;\n        let promise = null;\n        let status = AwaitRenderStatus.pending;\n        if (!(resolve instanceof Promise)) {\n            // Didn't get a promise - provide as a resolved promise\n            status = AwaitRenderStatus.success;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: ()=>resolve\n            });\n        } else if (this.state.error) {\n            // Caught a render error, provide it as a rejected promise\n            status = AwaitRenderStatus.error;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(()=>{}); // Avoid unhandled rejection warnings\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>renderError\n            });\n        } else if (resolve._tracked) {\n            // Already tracked promise - check contents\n            promise = resolve;\n            status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n        } else {\n            // Raw (untracked) promise - track it\n            status = AwaitRenderStatus.pending;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: ()=>true\n            });\n            promise = resolve.then((data)=>Object.defineProperty(resolve, \"_data\", {\n                    get: ()=>data\n                }), (error)=>Object.defineProperty(resolve, \"_error\", {\n                    get: ()=>error\n                }));\n        }\n        if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError) {\n            // Freeze the UI by throwing a never resolved promise\n            throw neverSettledPromise;\n        }\n        if (status === AwaitRenderStatus.error && !errorElement) {\n            // No errorElement, throw to the nearest route-level error boundary\n            throw promise._error;\n        }\n        if (status === AwaitRenderStatus.error) {\n            // Render via our errorElement\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: errorElement\n            });\n        }\n        if (status === AwaitRenderStatus.success) {\n            // Render children with resolved value\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: children\n            });\n        } // Throw to the suspense boundary\n        throw promise;\n    }\n}\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */ function ResolveAwait(_ref8) {\n    let { children } = _ref8;\n    let data = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);\n} ///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */ function createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    let routes = [];\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index)=>{\n        if (!/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {\n            // Ignore non-elements. This allows people to more easily inline\n            // conditionals in their route config.\n            return;\n        }\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            // Transparently support React.Fragment and its children.\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n            return;\n        }\n        !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\n        !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"An index route cannot have child routes.\") : 0 : void 0;\n        let route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */ function renderMatches(matches) {\n    return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n    let updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n        if (true) {\n            if (route.element) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            element: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\n            Component: undefined\n        });\n    }\n    if (route.ErrorBoundary) {\n        if (true) {\n            if (route.errorElement) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            errorElement: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\n            ErrorBoundary: undefined\n        });\n    }\n    return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n    return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries: opts == null ? void 0 : opts.initialEntries,\n            initialIndex: opts == null ? void 0 : opts.initialIndex\n        }),\n        hydrationData: opts == null ? void 0 : opts.hydrationData,\n        routes,\n        mapRouteProperties\n    }).initialize();\n} ///////////////////////////////////////////////////////////////////////////////\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQzhCO0FBQ3dPO0FBQzdEO0FBRTFNLFNBQVNzQjtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFFekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBRUEsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRUEsTUFBTVEsb0JBQW9CLFdBQVcsR0FBRXBDLGdEQUFtQixDQUFDO0FBRTNELElBQUlzQyxJQUFxQyxFQUFFO0lBQ3pDRixrQkFBa0JHLFdBQVcsR0FBRztBQUNsQztBQUVBLE1BQU1DLHlCQUF5QixXQUFXLEdBQUV4QyxnREFBbUIsQ0FBQztBQUVoRSxJQUFJc0MsSUFBcUMsRUFBRTtJQUN6Q0UsdUJBQXVCRCxXQUFXLEdBQUc7QUFDdkM7QUFFQSxNQUFNRSxlQUFlLFdBQVcsR0FBRXpDLGdEQUFtQixDQUFDO0FBRXRELElBQUlzQyxJQUFxQyxFQUFFO0lBQ3pDRyxhQUFhRixXQUFXLEdBQUc7QUFDN0I7QUFFQSxNQUFNRyxvQkFBb0IsV0FBVyxHQUFFMUMsZ0RBQW1CLENBQUM7QUFF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T3lMO0FBQ1Q7QUFFQSxTQUFTQyxtQkFBbUI5TSxNQUFNLEVBQUU2SSxJQUFJO0lBQ3RDLE9BQU85TywrREFBWUEsQ0FBQztRQUNsQndDLFVBQVVzTSxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLdE0sUUFBUTtRQUMvQ3dRLFFBQVF4UyxTQUFTLENBQUMsR0FBR3NPLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtrRSxNQUFNLEVBQUU7WUFDeERDLG9CQUFvQjtRQUN0QjtRQUNBdEQsU0FBUzlQLHNFQUFtQkEsQ0FBQztZQUMzQjBQLGdCQUFnQlQsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS1MsY0FBYztZQUMzREMsY0FBY1YsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS1UsWUFBWTtRQUN6RDtRQUNBMEQsZUFBZXBFLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtvRSxhQUFhO1FBQ3pEak47UUFDQTRNO0lBQ0YsR0FBR00sVUFBVTtBQUNmLEVBQUUsK0VBQStFO0FBRSt4QixDQUNoM0IsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZjM1Ni8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvaW5kZXguanM/NmZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlYWN0IFJvdXRlciB2Ni4xMS4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFVOU0FGRV9pbnZhcmlhbnQsIGpvaW5QYXRocywgbWF0Y2hQYXRoLCBVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMsIFVOU0FGRV93YXJuaW5nLCByZXNvbHZlVG8sIHBhcnNlUGF0aCwgbWF0Y2hSb3V0ZXMsIEFjdGlvbiwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGNyZWF0ZU1lbW9yeUhpc3RvcnksIHN0cmlwQmFzZW5hbWUsIEFib3J0ZWREZWZlcnJlZEVycm9yLCBjcmVhdGVSb3V0ZXIgfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XG5leHBvcnQgeyBBYm9ydGVkRGVmZXJyZWRFcnJvciwgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLCBjcmVhdGVQYXRoLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgcGFyc2VQYXRoLCByZWRpcmVjdCwgcmVzb2x2ZVBhdGggfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuY29uc3QgRGF0YVJvdXRlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBEYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xufVxuXG5jb25zdCBEYXRhUm91dGVyU3RhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclN0YXRlXCI7XG59XG5cbmNvbnN0IEF3YWl0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEF3YWl0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXdhaXRcIjtcbn1cblxuY29uc3QgTmF2aWdhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBOYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xufVxuXG5jb25zdCBMb2NhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBMb2NhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxvY2F0aW9uXCI7XG59XG5cbmNvbnN0IFJvdXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXSxcbiAgaXNEYXRhUm91dGU6IGZhbHNlXG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBSb3V0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlXCI7XG59XG5cbmNvbnN0IFJvdXRlRXJyb3JDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVFcnJvckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlRXJyb3JcIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaHJlZlxuICovXG5cbmZ1bmN0aW9uIHVzZUhyZWYodG8sIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgcmVsYXRpdmVcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZUhyZWYoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIG5hdmlnYXRvclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgaGFzaCxcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2hcbiAgfSA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlXG4gIH0pO1xuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTsgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAvLyB0byBjcmVhdGluZyB0aGUgaHJlZi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhd1xuICAvLyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlXG4gIC8vIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7XG4gICAgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoXG4gIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlcj4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaW4tcm91dGVyLWNvbnRleHRcbiAqL1xuXG5mdW5jdGlvbiB1c2VJblJvdXRlckNvbnRleHQoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbG9jYXRpb25cbiAqL1xuXG5mdW5jdGlvbiB1c2VMb2NhdGlvbigpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAqIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBlaXRoZXIgYnkgYSBwb3AsIHB1c2gsIG9yIHJlcGxhY2Ugb24gdGhlIGhpc3Rvcnkgc3RhY2suXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGlvbi10eXBlXG4gKi9cblxuZnVuY3Rpb24gdXNlTmF2aWdhdGlvblR5cGUoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG59XG4vKipcbiAqIFJldHVybnMgYSBQYXRoTWF0Y2ggb2JqZWN0IGlmIHRoZSBnaXZlbiBwYXR0ZXJuIG1hdGNoZXMgdGhlIGN1cnJlbnQgVVJMLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGtub3cgXCJhY3RpdmVcIiBzdGF0ZSwgZS5nLlxuICogPE5hdkxpbms+LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW1hdGNoXG4gKi9cblxuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBwYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSwgW3BhdGhuYW1lLCBwYXR0ZXJuXSk7XG59XG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBuYXZpZ2F0ZSgpIGZ1bmN0aW9uIHJldHVybmVkIGZyb20gdXNlTmF2aWdhdGUoKS5cbiAqL1xuXG5jb25zdCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcgPSBcIllvdSBzaG91bGQgY2FsbCBuYXZpZ2F0ZSgpIGluIGEgUmVhY3QudXNlRWZmZWN0KCksIG5vdCB3aGVuIFwiICsgXCJ5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5cIjsgLy8gTXV0ZSB3YXJuaW5ncyBmb3IgY2FsbHMgdG8gdXNlTmF2aWdhdGUgaW4gU1NSIGVudmlyb25tZW50c1xuXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGNiKSB7XG4gIGxldCBpc1N0YXRpYyA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpLnN0YXRpYztcblxuICBpZiAoIWlzU3RhdGljKSB7XG4gICAgLy8gV2Ugc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG9uY2UgcmVhY3QgMTguMyBpcyByZWxlYXNlZFxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoY2IpO1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgYW4gaW1wZXJhdGl2ZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBsb2NhdGlvbi4gVXNlZCBieSA8TGluaz5zLCBidXRcbiAqIG1heSBhbHNvIGJlIHVzZWQgYnkgb3RoZXIgZWxlbWVudHMgdG8gY2hhbmdlIHRoZSBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1uYXZpZ2F0ZVxuICovXG5cblxuZnVuY3Rpb24gdXNlTmF2aWdhdGUoKSB7XG4gIGxldCB7XG4gICAgaXNEYXRhUm91dGVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTsgLy8gQ29uZGl0aW9uYWwgdXNhZ2UgaXMgT0sgaGVyZSBiZWNhdXNlIHRoZSB1c2FnZSBvZiBhIGRhdGEgcm91dGVyIGlzIHN0YXRpY1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcblxuICByZXR1cm4gaXNEYXRhUm91dGUgPyB1c2VOYXZpZ2F0ZVN0YWJsZSgpIDogdXNlTmF2aWdhdGVVbnN0YWJsZSgpO1xufVxuXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgbmF2aWdhdG9yXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSkpO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IG5hdmlnYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpIDogdm9pZCAwOyAvLyBTaG9ydCBjaXJjdWl0IGhlcmUgc2luY2UgaWYgdGhpcyBoYXBwZW5zIG9uIGZpcnN0IHJlbmRlciB0aGUgbmF2aWdhdGVcbiAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgaGlzdG9yeSBsaXN0ZW5lciB5ZXRcblxuICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG5hdmlnYXRvci5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSA9PT0gXCJwYXRoXCIpOyAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gICAgLy8gdG8gaGFuZGluZyBvZmYgdG8gaGlzdG9yeSAoYnV0IG9ubHkgaWYgd2UncmUgbm90IGluIGEgZGF0YSByb3V0ZXIsXG4gICAgLy8gb3RoZXJ3aXNlIGl0J2xsIHByZXBlbmQgdGhlIGJhc2VuYW1lIGluc2lkZSBvZiB0aGUgcm91dGVyKS5cbiAgICAvLyBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIHdlIG5hdmlnYXRlIHRvIHRoZSByYXcgYmFzZW5hbWVcbiAgICAvLyB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGFcbiAgICAvLyB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG5cbiAgICBpZiAoZGF0YVJvdXRlckNvbnRleHQgPT0gbnVsbCAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgIH1cblxuICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvci5yZXBsYWNlIDogbmF2aWdhdG9yLnB1c2gpKHBhdGgsIG9wdGlvbnMuc3RhdGUsIG9wdGlvbnMpO1xuICB9LCBbYmFzZW5hbWUsIG5hdmlnYXRvciwgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCBkYXRhUm91dGVyQ29udGV4dF0pO1xuICByZXR1cm4gbmF2aWdhdGU7XG59XG5cbmNvbnN0IE91dGxldENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS5cbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW91dGxldC1jb250ZXh0XG4gKi9cblxuZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LiBVc2VkIGludGVybmFsbHkgYnkgPE91dGxldD4gdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1vdXRsZXRcbiAqL1xuXG5mdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dCkge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcblxuICBpZiAob3V0bGV0KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE91dGxldENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgb3V0bGV0KTtcbiAgfVxuXG4gIHJldHVybiBvdXRsZXQ7XG59XG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxuICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXBhcmFtc1xuICovXG5cbmZ1bmN0aW9uIHVzZVBhcmFtcygpIHtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG59XG4vKipcbiAqIFJlc29sdmVzIHRoZSBwYXRobmFtZSBvZiB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXJlc29sdmVkLXBhdGhcbiAqL1xuXG5mdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgodG8sIF90ZW1wMikge1xuICBsZXQge1xuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyO1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFVOU0FGRV9nZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKS5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZSA9PT0gXCJwYXRoXCIpLCBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gPE91dGxldD4gdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utcm91dGVzXG4gKi9cblxuZnVuY3Rpb24gdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcpIHtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZyk7XG59IC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIHdpdGggYWNjZXB0IG9wdGlvbmFsIHBhcmFtIGZvciBSb3V0ZXJQcm92aWRlciB1c2FnZVxuXG5mdW5jdGlvbiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcsIGRhdGFSb3V0ZXJTdGF0ZSkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgbmF2aWdhdG9yXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHtcbiAgICBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAvLyBZb3Ugd29uJ3QgZ2V0IGEgd2FybmluZyBhYm91dCAyIGRpZmZlcmVudCA8Um91dGVzPiB1bmRlciBhIDxSb3V0ZT5cbiAgICAvLyB3aXRob3V0IGEgdHJhaWxpbmcgKiwgYnV0IHRoaXMgaXMgYSBiZXN0LWVmZm9ydCB3YXJuaW5nIGFueXdheSBzaW5jZSB3ZVxuICAgIC8vIGNhbm5vdCBldmVuIGdpdmUgdGhlIHdhcm5pbmcgdW5sZXNzIHRoZXkgbGFuZCBhdCB0aGUgcGFyZW50IHJvdXRlLlxuICAgIC8vXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vIDxSb3V0ZXM+XG4gICAgLy8gICB7LyogVGhpcyByb3V0ZSBwYXRoIE1VU1QgZW5kIHdpdGggLyogYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyAgICAgICBpdCB3aWxsIG5ldmVyIG1hdGNoIC9ibG9nL3Bvc3QvMTIzICovfVxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nXCIgZWxlbWVudD17PEJsb2cgLz59IC8+XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2cvZmVlZFwiIGVsZW1lbnQ9ezxCbG9nRmVlZCAvPn0gLz5cbiAgICAvLyA8L1JvdXRlcz5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIEJsb2coKSB7XG4gICAgLy8gICByZXR1cm4gKFxuICAgIC8vICAgICA8Um91dGVzPlxuICAgIC8vICAgICAgIDxSb3V0ZSBwYXRoPVwicG9zdC86aWRcIiBlbGVtZW50PXs8UG9zdCAvPn0gLz5cbiAgICAvLyAgICAgPC9Sb3V0ZXM+XG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICBsZXQgcGFyZW50UGF0aCA9IHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGggfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShwYXJlbnRQYXRobmFtZSwgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLCBcIllvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgYHVzZVJvdXRlcygpYCkgYXQgXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRobmFtZSArIFwiXFxcIiAodW5kZXIgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4pIGJ1dCB0aGUgXCIpICsgXCJwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXFxcIipcXFwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBcIiArIFwiZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgXCIgKyBcInJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cXG5cXG5cIiArIChcIlBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiPiB0byA8Um91dGUgXCIpICsgKFwicGF0aD1cXFwiXCIgKyAocGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IHBhcmVudFBhdGggKyBcIi8qXCIpICsgXCJcXFwiPi5cIikpO1xuICB9XG5cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbG9jYXRpb247XG5cbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgdmFyIF9wYXJzZWRMb2NhdGlvbkFyZyRwYTtcblxuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgICAhKHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHwgKChfcGFyc2VkTG9jYXRpb25BcmckcGEgPSBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJzZWRMb2NhdGlvbkFyZyRwYS5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiV2hlbiBvdmVycmlkaW5nIHRoZSBsb2NhdGlvbiB1c2luZyBgPFJvdXRlcyBsb2NhdGlvbj5gIG9yIGB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbilgLCBcIiArIFwidGhlIGxvY2F0aW9uIHBhdGhuYW1lIG11c3QgYmVnaW4gd2l0aCB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIFwiICsgKFwibWF0Y2hlZCBieSBhbGwgcGFyZW50IHJvdXRlcy4gVGhlIGN1cnJlbnQgcGF0aG5hbWUgYmFzZSBpcyBcXFwiXCIgKyBwYXJlbnRQYXRobmFtZUJhc2UgKyBcIlxcXCIgXCIpICsgKFwiYnV0IHBhdGhuYW1lIFxcXCJcIiArIHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lICsgXCJcXFwiIHdhcyBnaXZlbiBpbiB0aGUgYGxvY2F0aW9uYCBwcm9wLlwiKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsb2NhdGlvbiA9IHBhcnNlZExvY2F0aW9uQXJnO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb25Gcm9tQ29udGV4dDtcbiAgfVxuXG4gIGxldCBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiO1xuICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGF0aG5hbWUgOiBwYXRobmFtZS5zbGljZShwYXJlbnRQYXRobmFtZUJhc2UubGVuZ3RoKSB8fCBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHtcbiAgICBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWVcbiAgfSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCwgXCJObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcXFwiXCIgKyBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2ggKyBcIlxcXCIgXCIpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKG1hdGNoZXMgPT0gbnVsbCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5Db21wb25lbnQgIT09IHVuZGVmaW5lZCwgXCJNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXFxcIlwiICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoICsgXCJcXFwiIFwiICsgXCJkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQgb3IgQ29tcG9uZW50LiBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIFwiICsgXCJudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFxcXCJlbXB0eVxcXCIgcGFnZS5cIikgOiB2b2lkIDA7XG4gIH1cblxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyAmJiBtYXRjaGVzLm1hcChtYXRjaCA9PiBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50UGFyYW1zLCBtYXRjaC5wYXJhbXMpLFxuICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSwgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWUpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVdKSxcbiAgICBwYXRobmFtZUJhc2U6IG1hdGNoLnBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgPyBwYXJlbnRQYXRobmFtZUJhc2UgOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSwgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWVCYXNlKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gIH0pKSwgcGFyZW50TWF0Y2hlcywgZGF0YVJvdXRlclN0YXRlKTsgLy8gV2hlbiBhIHVzZXIgcGFzc2VzIGluIGEgYGxvY2F0aW9uQXJnYCwgdGhlIGFzc29jaWF0ZWQgcm91dGVzIG5lZWQgdG9cbiAgLy8gYmUgd3JhcHBlZCBpbiBhIG5ldyBgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyYCBpbiBvcmRlciBmb3IgYHVzZUxvY2F0aW9uYFxuICAvLyB0byB1c2UgdGhlIHNjb3BlZCBsb2NhdGlvbiBpbnN0ZWFkIG9mIHRoZSBnbG9iYWwgbG9jYXRpb24uXG5cblxuICBpZiAobG9jYXRpb25BcmcgJiYgcmVuZGVyZWRNYXRjaGVzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbG9jYXRpb246IF9leHRlbmRzKHtcbiAgICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgICAgc2VhcmNoOiBcIlwiLFxuICAgICAgICAgIGhhc2g6IFwiXCIsXG4gICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAga2V5OiBcImRlZmF1bHRcIlxuICAgICAgICB9LCBsb2NhdGlvbiksXG4gICAgICAgIG5hdmlnYXRpb25UeXBlOiBBY3Rpb24uUG9wXG4gICAgICB9XG4gICAgfSwgcmVuZGVyZWRNYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIERlZmF1bHRFcnJvckNvbXBvbmVudCgpIHtcbiAgbGV0IGVycm9yID0gdXNlUm91dGVFcnJvcigpO1xuICBsZXQgbWVzc2FnZSA9IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSA/IGVycm9yLnN0YXR1cyArIFwiIFwiICsgZXJyb3Iuc3RhdHVzVGV4dCA6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICBsZXQgc3RhY2sgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xuICBsZXQgbGlnaHRncmV5ID0gXCJyZ2JhKDIwMCwyMDAsMjAwLCAwLjUpXCI7XG4gIGxldCBwcmVTdHlsZXMgPSB7XG4gICAgcGFkZGluZzogXCIwLjVyZW1cIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleVxuICB9O1xuICBsZXQgY29kZVN0eWxlcyA9IHtcbiAgICBwYWRkaW5nOiBcIjJweCA0cHhcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleVxuICB9O1xuICBsZXQgZGV2SW5mbyA9IG51bGw7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGVkIGJ5IFJlYWN0IFJvdXRlciBkZWZhdWx0IEVycm9yQm91bmRhcnk6XCIsIGVycm9yKTtcbiAgICBkZXZJbmZvID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIlxcdUQ4M0RcXHVEQ0JGIEhleSBkZXZlbG9wZXIgXFx1RDgzRFxcdURDNEJcIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIllvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIGVycm9ycyBieSBwcm92aWRpbmcgeW91ciBvd24gXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgIH0sIFwiRXJyb3JCb3VuZGFyeVwiKSwgXCIgb3JcIiwgXCIgXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgIH0sIFwiZXJyb3JFbGVtZW50XCIpLCBcIiBwcm9wIG9uIHlvdXIgcm91dGUuXCIpKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIlVuZXhwZWN0ZWQgQXBwbGljYXRpb24gRXJyb3IhXCIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImgzXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfVxuICB9LCBtZXNzYWdlKSwgc3RhY2sgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCB7XG4gICAgc3R5bGU6IHByZVN0eWxlc1xuICB9LCBzdGFjaykgOiBudWxsLCBkZXZJbmZvKTtcbn1cblxuY29uc3QgZGVmYXVsdEVycm9yRWxlbWVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRFcnJvckNvbXBvbmVudCwgbnVsbCk7XG5jbGFzcyBSZW5kZXJFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uLFxuICAgICAgZXJyb3I6IHByb3BzLmVycm9yXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgLy8gV2hlbiB3ZSBnZXQgaW50byBhbiBlcnJvciBzdGF0ZSwgdGhlIHVzZXIgd2lsbCBsaWtlbHkgY2xpY2sgXCJiYWNrXCIgdG8gdGhlXG4gICAgLy8gcHJldmlvdXMgcGFnZSB0aGF0IGRpZG4ndCBoYXZlIGFuIGVycm9yLiBCZWNhdXNlIHRoaXMgd3JhcHMgdGhlIGVudGlyZVxuICAgIC8vIGFwcGxpY2F0aW9uLCB0aGF0IHdpbGwgaGF2ZSBubyBlZmZlY3QtLXRoZSBlcnJvciBwYWdlIGNvbnRpbnVlcyB0byBkaXNwbGF5LlxuICAgIC8vIFRoaXMgZ2l2ZXMgdXMgYSBtZWNoYW5pc20gdG8gcmVjb3ZlciBmcm9tIHRoZSBlcnJvciB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgIC8vXG4gICAgLy8gV2hldGhlciB3ZSdyZSBpbiBhbiBlcnJvciBzdGF0ZSBvciBub3QsIHdlIHVwZGF0ZSB0aGUgbG9jYXRpb24gaW4gc3RhdGVcbiAgICAvLyBzbyB0aGF0IHdoZW4gd2UgYXJlIGluIGFuIGVycm9yIHN0YXRlLCBpdCBnZXRzIHJlc2V0IHdoZW4gYSBuZXcgbG9jYXRpb25cbiAgICAvLyBjb21lcyBpbiBhbmQgdGhlIHVzZXIgcmVjb3ZlcnMgZnJvbSB0aGUgZXJyb3IuXG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb24gIT09IFwiaWRsZVwiICYmIHByb3BzLnJldmFsaWRhdGlvbiA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvblxuICAgICAgfTtcbiAgICB9IC8vIElmIHdlJ3JlIG5vdCBjaGFuZ2luZyBsb2NhdGlvbnMsIHByZXNlcnZlIHRoZSBsb2NhdGlvbiBidXQgc3RpbGwgc3VyZmFjZVxuICAgIC8vIGFueSBuZXcgZXJyb3JzIHRoYXQgbWF5IGNvbWUgdGhyb3VnaC4gV2UgcmV0YWluIHRoZSBleGlzdGluZyBlcnJvciwgd2UgZG9cbiAgICAvLyB0aGlzIGJlY2F1c2UgdGhlIGVycm9yIHByb3ZpZGVkIGZyb20gdGhlIGFwcCBzdGF0ZSBtYXkgYmUgY2xlYXJlZCB3aXRob3V0XG4gICAgLy8gdGhlIGxvY2F0aW9uIGNoYW5naW5nLlxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IHN0YXRlLmVycm9yLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBjb25zb2xlLmVycm9yKFwiUmVhY3QgUm91dGVyIGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIiwgZXJyb3IsIGVycm9ySW5mbyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnJvdXRlQ29udGV4dFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlRXJyb3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNvbXBvbmVudFxuICAgIH0pKSA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cblxufVxuXG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICByb3V0ZUNvbnRleHQsXG4gICAgbWF0Y2gsXG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpOyAvLyBUcmFjayBob3cgZGVlcCB3ZSBnb3QgaW4gb3VyIHJlbmRlciBwYXNzIHRvIGVtdWxhdGUgU1NSIGNvbXBvbmVudERpZENhdGNoXG4gIC8vIGluIGEgRGF0YVN0YXRpY1JvdXRlclxuXG4gIGlmIChkYXRhUm91dGVyQ29udGV4dCAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dCAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpKSB7XG4gICAgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByb3V0ZUNvbnRleHRcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzLCBwYXJlbnRNYXRjaGVzLCBkYXRhUm91dGVyU3RhdGUpIHtcbiAgdmFyIF9kYXRhUm91dGVyU3RhdGUyO1xuXG4gIGlmIChwYXJlbnRNYXRjaGVzID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRNYXRjaGVzID0gW107XG4gIH1cblxuICBpZiAoZGF0YVJvdXRlclN0YXRlID09PSB2b2lkIDApIHtcbiAgICBkYXRhUm91dGVyU3RhdGUgPSBudWxsO1xuICB9XG5cbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgIHZhciBfZGF0YVJvdXRlclN0YXRlO1xuXG4gICAgaWYgKChfZGF0YVJvdXRlclN0YXRlID0gZGF0YVJvdXRlclN0YXRlKSAhPSBudWxsICYmIF9kYXRhUm91dGVyU3RhdGUuZXJyb3JzKSB7XG4gICAgICAvLyBEb24ndCBiYWlsIGlmIHdlIGhhdmUgZGF0YSByb3V0ZXIgZXJyb3JzIHNvIHdlIGNhbiByZW5kZXIgdGhlbSBpbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5LiAgVXNlIHRoZSBwcmUtbWF0Y2hlZCAob3Igc2hpbW1lZCkgbWF0Y2hlc1xuICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gbWF0Y2hlczsgLy8gSWYgd2UgaGF2ZSBkYXRhIGVycm9ycywgdHJpbSBtYXRjaGVzIHRvIHRoZSBoaWdoZXN0IGVycm9yIGJvdW5kYXJ5XG5cbiAgbGV0IGVycm9ycyA9IChfZGF0YVJvdXRlclN0YXRlMiA9IGRhdGFSb3V0ZXJTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUm91dGVyU3RhdGUyLmVycm9ycztcblxuICBpZiAoZXJyb3JzICE9IG51bGwpIHtcbiAgICBsZXQgZXJyb3JJbmRleCA9IHJlbmRlcmVkTWF0Y2hlcy5maW5kSW5kZXgobSA9PiBtLnJvdXRlLmlkICYmIChlcnJvcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yc1ttLnJvdXRlLmlkXSkpO1xuICAgICEoZXJyb3JJbmRleCA+PSAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyByb3V0ZSBmb3IgZXJyb3JzIG9uIHJvdXRlIElEczogXCIgKyBPYmplY3Qua2V5cyhlcnJvcnMpLmpvaW4oXCIsXCIpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSkpO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgZXJyb3IgPSBtYXRjaC5yb3V0ZS5pZCA/IGVycm9ycyA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA6IG51bGw7IC8vIE9ubHkgZGF0YSByb3V0ZXJzIGhhbmRsZSBlcnJvcnNcblxuICAgIGxldCBlcnJvckVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSkge1xuICAgICAgZXJyb3JFbGVtZW50ID0gbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGRlZmF1bHRFcnJvckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgbGV0IG1hdGNoZXMgPSBwYXJlbnRNYXRjaGVzLmNvbmNhdChyZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSk7XG5cbiAgICBsZXQgZ2V0Q2hpbGRyZW4gPSAoKSA9PiB7XG4gICAgICBsZXQgY2hpbGRyZW47XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjaGlsZHJlbiA9IGVycm9yRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgaXMgYSBkZS1vcHRpbWl6ZWQgcGF0aCBzaW5jZSBSZWFjdCB3b24ndCByZS11c2UgdGhlXG4gICAgICAgIC8vIFJlYWN0RWxlbWVudCBzaW5jZSBpdCdzIGlkZW50aXR5IGNoYW5nZXMgd2l0aCBlYWNoIG5ld1xuICAgICAgICAvLyBSZWFjdC5jcmVhdGVFbGVtZW50IGNhbGwuICBXZSBrZWVwIHRoaXMgc28gZm9sa3MgY2FuIHVzZVxuICAgICAgICAvLyBgPFJvdXRlIENvbXBvbmVudD17Li4ufT5gIGluIGA8Um91dGVzPmAgYnV0IGdlbmVyYWxseSBgQ29tcG9uZW50YFxuICAgICAgICAvLyB1c2FnZSBpcyBvbmx5IGFkdmlzZWQgaW4gYFJvdXRlclByb3ZpZGVyYCB3aGVuIHdlIGNhbiBjb252ZXJ0IGl0IHRvXG4gICAgICAgIC8vIGBlbGVtZW50YCBhaGVhZCBvZiB0aW1lLlxuICAgICAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KG1hdGNoLnJvdXRlLkNvbXBvbmVudCwgbnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBtYXRjaC5yb3V0ZS5lbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBvdXRsZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW5kZXJlZFJvdXRlLCB7XG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgcm91dGVDb250ZXh0OiB7XG4gICAgICAgICAgb3V0bGV0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgaXNEYXRhUm91dGU6IGRhdGFSb3V0ZXJTdGF0ZSAhPSBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfTsgLy8gT25seSB3cmFwIGluIGFuIGVycm9yIGJvdW5kYXJ5IHdpdGhpbiBkYXRhIHJvdXRlciB1c2FnZXMgd2hlbiB3ZSBoYXZlIGFuXG4gICAgLy8gRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnQgb24gdGhpcyByb3V0ZS4gIE90aGVyd2lzZSBsZXQgaXQgYnViYmxlIHVwIHRvXG4gICAgLy8gYW4gYW5jZXN0b3IgRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnRcblxuXG4gICAgcmV0dXJuIGRhdGFSb3V0ZXJTdGF0ZSAmJiAobWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSB8fCBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgaW5kZXggPT09IDApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVuZGVyRXJyb3JCb3VuZGFyeSwge1xuICAgICAgbG9jYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogZGF0YVJvdXRlclN0YXRlLnJldmFsaWRhdGlvbixcbiAgICAgIGNvbXBvbmVudDogZXJyb3JFbGVtZW50LFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgY2hpbGRyZW46IGdldENoaWxkcmVuKCksXG4gICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgb3V0bGV0OiBudWxsLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBpc0RhdGFSb3V0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pIDogZ2V0Q2hpbGRyZW4oKTtcbiAgfSwgbnVsbCk7XG59XG52YXIgRGF0YVJvdXRlckhvb2s7XG5cbihmdW5jdGlvbiAoRGF0YVJvdXRlckhvb2spIHtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VCbG9ja2VyXCJdID0gXCJ1c2VCbG9ja2VyXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlUmV2YWxpZGF0b3JcIl0gPSBcInVzZVJldmFsaWRhdG9yXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlTmF2aWdhdGVTdGFibGVcIl0gPSBcInVzZU5hdmlnYXRlXCI7XG59KShEYXRhUm91dGVySG9vayB8fCAoRGF0YVJvdXRlckhvb2sgPSB7fSkpO1xuXG52YXIgRGF0YVJvdXRlclN0YXRlSG9vaztcblxuKGZ1bmN0aW9uIChEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VCbG9ja2VyXCJdID0gXCJ1c2VCbG9ja2VyXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VMb2FkZXJEYXRhXCJdID0gXCJ1c2VMb2FkZXJEYXRhXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VBY3Rpb25EYXRhXCJdID0gXCJ1c2VBY3Rpb25EYXRhXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUVycm9yXCJdID0gXCJ1c2VSb3V0ZUVycm9yXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VOYXZpZ2F0aW9uXCJdID0gXCJ1c2VOYXZpZ2F0aW9uXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUxvYWRlckRhdGFcIl0gPSBcInVzZVJvdXRlTG9hZGVyRGF0YVwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTWF0Y2hlc1wiXSA9IFwidXNlTWF0Y2hlc1wiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUmV2YWxpZGF0b3JcIl0gPSBcInVzZVJldmFsaWRhdG9yXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VOYXZpZ2F0ZVN0YWJsZVwiXSA9IFwidXNlTmF2aWdhdGVcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlSWRcIl0gPSBcInVzZVJvdXRlSWRcIjtcbn0pKERhdGFSb3V0ZXJTdGF0ZUhvb2sgfHwgKERhdGFSb3V0ZXJTdGF0ZUhvb2sgPSB7fSkpO1xuXG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSB7XG4gIHJldHVybiBob29rTmFtZSArIFwiIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuXCI7XG59XG5cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgIWN0eCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gY3R4O1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgIXN0YXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgIXJvdXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiByb3V0ZTtcbn0gLy8gSW50ZXJuYWwgdmVyc2lvbiB3aXRoIGhvb2tOYW1lLWF3YXJlIGRlYnVnZ2luZ1xuXG5cbmZ1bmN0aW9uIHVzZUN1cnJlbnRSb3V0ZUlkKGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IHVzZVJvdXRlQ29udGV4dChob29rTmFtZSk7XG4gIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICF0aGlzUm91dGUucm91dGUuaWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBob29rTmFtZSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcXFwiaWRcXFwiXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiB0aGlzUm91dGUucm91dGUuaWQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIElEIGZvciB0aGUgbmVhcmVzdCBjb250ZXh0dWFsIHJvdXRlXG4gKi9cblxuXG5mdW5jdGlvbiB1c2VSb3V0ZUlkKCkge1xuICByZXR1cm4gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUlkKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uLCBkZWZhdWx0aW5nIHRvIGFuIFwiaWRsZVwiIG5hdmlnYXRpb24gd2hlblxuICogbm8gbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzc1xuICovXG5cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb24oKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRpb24pO1xuICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJldmFsaWRhdGUgZnVuY3Rpb24gZm9yIG1hbnVhbGx5IHRyaWdnZXJpbmcgcmV2YWxpZGF0aW9uLCBhcyB3ZWxsXG4gKiBhcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBhbnkgbWFudWFsIHJldmFsaWRhdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VSZXZhbGlkYXRvcigpIHtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gIHJldHVybiB7XG4gICAgcmV2YWxpZGF0ZTogZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsXG4gICAgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvblxuICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3RpdmUgcm91dGUgbWF0Y2hlcywgdXNlZnVsIGZvciBhY2Nlc3NpbmcgbG9hZGVyRGF0YSBmb3JcbiAqIHBhcmVudC9jaGlsZCByb3V0ZXMgb3IgdGhlIHJvdXRlIFwiaGFuZGxlXCIgcHJvcGVydHlcbiAqL1xuXG5mdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgbG9hZGVyRGF0YVxuICB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTWF0Y2hlcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gbWF0Y2g7IC8vIE5vdGU6IFRoaXMgc3RydWN0dXJlIG1hdGNoZXMgdGhhdCBjcmVhdGVkIGJ5IGNyZWF0ZVVzZU1hdGNoZXNNYXRjaFxuICAgIC8vIGluIHRoZSBAcmVtaXgtcnVuL3JvdXRlciAsIHNvIGlmIHlvdSBjaGFuZ2UgdGhpcyBwbGVhc2UgYWxzbyBjaGFuZ2VcbiAgICAvLyB0aGF0IDopICBFdmVudHVhbGx5IHdlJ2xsIERSWSB0aGlzIHVwXG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IG1hdGNoLnJvdXRlLmlkLFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBwYXJhbXMsXG4gICAgICBkYXRhOiBsb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSxcbiAgICAgIGhhbmRsZTogbWF0Y2gucm91dGUuaGFuZGxlXG4gICAgfTtcbiAgfSksIFttYXRjaGVzLCBsb2FkZXJEYXRhXSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlciBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBsb2FkZXJcbiAqL1xuXG5mdW5jdGlvbiB1c2VMb2FkZXJEYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xuXG4gIGlmIChzdGF0ZS5lcnJvcnMgJiYgc3RhdGUuZXJyb3JzW3JvdXRlSWRdICE9IG51bGwpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiWW91IGNhbm5vdCBgdXNlTG9hZGVyRGF0YWAgaW4gYW4gZXJyb3JFbGVtZW50IChyb3V0ZUlkOiBcIiArIHJvdXRlSWQgKyBcIilcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2FkZXJEYXRhIGZvciB0aGUgZ2l2ZW4gcm91dGVJZFxuICovXG5cbmZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlTG9hZGVyRGF0YSk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3Rpb24gZGF0YSBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgYWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gdXNlQWN0aW9uRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQWN0aW9uRGF0YSk7XG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgIXJvdXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VBY3Rpb25EYXRhIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5hY3Rpb25EYXRhKSB8fCB7fSlbMF07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgZXJyb3IsIHdoaWNoIGNvdWxkIGJlIGEgbG9hZGVyL2FjdGlvblxuICogZXJyb3Igb3IgYSByZW5kZXIgZXJyb3IuICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBmcm9tIHlvdXJcbiAqIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IHRvIGRpc3BsYXkgYSBwcm9wZXIgZXJyb3IgbWVzc2FnZS5cbiAqL1xuXG5mdW5jdGlvbiB1c2VSb3V0ZUVycm9yKCkge1xuICB2YXIgX3N0YXRlJGVycm9ycztcblxuICBsZXQgZXJyb3IgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTsgLy8gSWYgdGhpcyB3YXMgYSByZW5kZXIgZXJyb3IsIHdlIHB1dCBpdCBpbiBhIFJvdXRlRXJyb3IgY29udGV4dCBpbnNpZGVcbiAgLy8gb2YgUmVuZGVyRXJyb3JCb3VuZGFyeVxuXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfSAvLyBPdGhlcndpc2UgbG9vayBmb3IgZXJyb3JzIGZyb20gb3VyIGRhdGEgcm91dGVyIHN0YXRlXG5cblxuICByZXR1cm4gKF9zdGF0ZSRlcnJvcnMgPSBzdGF0ZS5lcnJvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZXJyb3JzW3JvdXRlSWRdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBoYXBweS1wYXRoIGRhdGEgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciA8QXdhaXQgLz4gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiB1c2VBc3luY1ZhbHVlKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX2RhdGE7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGVycm9yIGZyb20gdGhlIG5lYXJlc3QgYW5jZXN0b3IgPEF3YWl0IC8+IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gdXNlQXN5bmNFcnJvcigpIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9lcnJvcjtcbn1cbmxldCBibG9ja2VySWQgPSAwO1xuLyoqXG4gKiBBbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gYmxvY2sgbmF2aWdhdGlvbnMgd2l0aGluIHRoZSBTUEEgYW5kIHByZXNlbnQgdGhlXG4gKiB1c2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyB0byBjb25maXJtIHRoZSBuYXZpZ2F0aW9uLiAgTW9zdGx5IHVzZWQgdG8gYXZvaWRcbiAqIHVzaW5nIGhhbGYtZmlsbGVkIGZvcm0gZGF0YS4gIFRoaXMgZG9lcyBub3QgaGFuZGxlIGhhcmQtcmVsb2FkcyBvclxuICogY3Jvc3Mtb3JpZ2luIG5hdmlnYXRpb25zLlxuICovXG5cbmZ1bmN0aW9uIHVzZUJsb2NrZXIoc2hvdWxkQmxvY2spIHtcbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUJsb2NrZXIpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VCbG9ja2VyKTtcbiAgbGV0IFtibG9ja2VyS2V5XSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IFN0cmluZygrK2Jsb2NrZXJJZCkpO1xuICBsZXQgYmxvY2tlckZ1bmN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soYXJncyA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBzaG91bGRCbG9jayA9PT0gXCJmdW5jdGlvblwiID8gISFzaG91bGRCbG9jayhhcmdzKSA6ICEhc2hvdWxkQmxvY2s7XG4gIH0sIFtzaG91bGRCbG9ja10pO1xuICBsZXQgYmxvY2tlciA9IHJvdXRlci5nZXRCbG9ja2VyKGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbik7IC8vIENsZWFudXAgb24gdW5tb3VudFxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiAoKSA9PiByb3V0ZXIuZGVsZXRlQmxvY2tlcihibG9ja2VyS2V5KSwgW3JvdXRlciwgYmxvY2tlcktleV0pOyAvLyBQcmVmZXIgdGhlIGJsb2NrZXIgZnJvbSBzdGF0ZSBzaW5jZSBEYXRhUm91dGVyQ29udGV4dCBpcyBtZW1vaXplZCBzbyB0aGlzXG4gIC8vIGVuc3VyZXMgd2UgdXBkYXRlIG9uIGJsb2NrZXIgc3RhdGUgdXBkYXRlc1xuXG4gIHJldHVybiBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSkgfHwgYmxvY2tlcjtcbn1cbi8qKlxuICogU3RhYmxlIHZlcnNpb24gb2YgdXNlTmF2aWdhdGUgdGhhdCBpcyB1c2VkIHdoZW4gd2UgYXJlIGluIHRoZSBjb250ZXh0IG9mXG4gKiBhIFJvdXRlclByb3ZpZGVyLlxuICovXG5cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlU3RhYmxlKCkge1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICBsZXQgaWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRlU3RhYmxlKTtcbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0bywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKSA6IHZvaWQgMDsgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgLy8gaXMgdXNlbGVzcyBiZWNhdXNlIHdlIGhhdmVuJ3Qgd2lyZWQgdXAgb3VyIHJvdXRlciBzdWJzY3JpYmVyIHlldFxuXG4gICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcm91dGVyLm5hdmlnYXRlKHRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGVyLm5hdmlnYXRlKHRvLCBfZXh0ZW5kcyh7XG4gICAgICAgIGZyb21Sb3V0ZUlkOiBpZFxuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgfSwgW3JvdXRlciwgaWRdKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuXG5jb25zdCBhbHJlYWR5V2FybmVkID0ge307XG5cbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleSwgY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZW1peCBSb3V0ZXIgaW5zdGFuY2UsIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgVUlcbiAqL1xuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIoX3JlZikge1xuICBsZXQge1xuICAgIGZhbGxiYWNrRWxlbWVudCxcbiAgICByb3V0ZXJcbiAgfSA9IF9yZWY7XG4gIC8vIE5lZWQgdG8gdXNlIGEgbGF5b3V0IGVmZmVjdCBoZXJlIHNvIHdlIGFyZSBzdWJzY3JpYmVkIGVhcmx5IGVub3VnaCB0b1xuICAvLyBwaWNrIHVwIG9uIGFueSByZW5kZXItZHJpdmVuIHJlZGlyZWN0cy9uYXZpZ2F0aW9ucyAodXNlRWZmZWN0LzxOYXZpZ2F0ZT4pXG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiByb3V0ZXIuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciwgc2V0U3RhdGVdKTtcbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogbiA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KVxuICAgIH07XG4gIH0sIFtyb3V0ZXJdKTtcbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcm91dGVyLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IGZhbHNlLFxuICAgIGJhc2VuYW1lXG4gIH0pLCBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lXSk7IC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgLy8gdXNlSWQgaGFwcHkgd2hlbiB3ZSBhcmUgc2VydmVyLXJlbmRlcmluZyBzaW5jZSB3ZSBtYXkgaGF2ZSBhIDxzY3JpcHQ+IGhlcmVcbiAgLy8gY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgc2VydmVyLXNpZGUgc3RhdGljQ29udGV4dCAoZnJvbSBTdGF0aWNSb3V0ZXJQcm92aWRlcikuXG4gIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAvLyBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBpdCByZW1haW5zIHRoZSBzYW1lIG9uIHRoZSBjbGllbnQgZXZlbiB0aG91Z2hcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgPHNjcmlwdD4gdGFnXG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0YXRlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiByb3V0ZXIuYmFzZW5hbWUsXG4gICAgbG9jYXRpb246IHJvdXRlci5zdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogcm91dGVyLnN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3JcbiAgfSwgcm91dGVyLnN0YXRlLmluaXRpYWxpemVkID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlcywge1xuICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSkgOiBmYWxsYmFja0VsZW1lbnQpKSksIG51bGwpO1xufVxuXG5mdW5jdGlvbiBEYXRhUm91dGVzKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgcm91dGVzLFxuICAgIHN0YXRlXG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlKTtcbn1cblxuLyoqXG4gKiBBIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGFsbCBlbnRyaWVzIGluIG1lbW9yeS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL21lbW9yeS1yb3V0ZXJcbiAqL1xuZnVuY3Rpb24gTWVtb3J5Um91dGVyKF9yZWYzKSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgaW5pdGlhbEVudHJpZXMsXG4gICAgaW5pdGlhbEluZGV4XG4gIH0gPSBfcmVmMztcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWYoKTtcblxuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gIH0pO1xufVxuXG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBBUEkgaXMgbW9zdGx5IHVzZWZ1bCBpbiBSZWFjdC5Db21wb25lbnQgc3ViY2xhc3NlcyB0aGF0IGFyZSBub3RcbiAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL25hdmlnYXRlXG4gKi9cbmZ1bmN0aW9uIE5hdmlnYXRlKF9yZWY0KSB7XG4gIGxldCB7XG4gICAgdG8sXG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICByZWxhdGl2ZVxuICB9ID0gX3JlZjQ7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwiPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyghUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljLCBcIjxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gXCIgKyBcIlRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBcIiArIFwib25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuXCIpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTsgLy8gUmVzb2x2ZSB0aGUgcGF0aCBvdXRzaWRlIG9mIHRoZSBlZmZlY3Qgc28gdGhhdCB3aGVuIGVmZmVjdHMgcnVuIHR3aWNlIGluXG4gIC8vIFN0cmljdE1vZGUgdGhleSBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBwbGFjZVxuXG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKHRvLCBVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSksIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlID09PSBcInBhdGhcIik7XG4gIGxldCBqc29uUGF0aCA9IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gbmF2aWdhdGUoSlNPTi5wYXJzZShqc29uUGF0aCksIHtcbiAgICByZXBsYWNlLFxuICAgIHN0YXRlLFxuICAgIHJlbGF0aXZlXG4gIH0pLCBbbmF2aWdhdGUsIGpzb25QYXRoLCByZWxhdGl2ZSwgcmVwbGFjZSwgc3RhdGVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY2hpbGQgcm91dGUncyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL291dGxldFxuICovXG5mdW5jdGlvbiBPdXRsZXQocHJvcHMpIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVcbiAqL1xuZnVuY3Rpb24gUm91dGUoX3Byb3BzKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiQSA8Um91dGU+IGlzIG9ubHkgZXZlciB0byBiZSB1c2VkIGFzIHRoZSBjaGlsZCBvZiA8Um91dGVzPiBlbGVtZW50LCBcIiArIFwibmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIDxSb3V0ZXI+IGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcbiAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgPEJyb3dzZXJSb3V0ZXI+XG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSA8U3RhdGljUm91dGVyPiBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL3JvdXRlclxuICovXG5mdW5jdGlvbiBSb3V0ZXIoX3JlZjUpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gICAgY2hpbGRyZW4gPSBudWxsLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gICAgbmF2aWdhdGlvblR5cGUgPSBBY3Rpb24uUG9wLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxuICB9ID0gX3JlZjU7XG4gICEhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIllvdSBjYW5ub3QgcmVuZGVyIGEgPFJvdXRlcj4gaW5zaWRlIGFub3RoZXIgPFJvdXRlcj4uXCIgKyBcIiBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDsgLy8gUHJlc2VydmUgdHJhaWxpbmcgc2xhc2hlcyBvbiBiYXNlbmFtZSwgc28gd2UgY2FuIGxldCB0aGUgdXNlciBjb250cm9sXG4gIC8vIHRoZSBlbmZvcmNlbWVudCBvZiB0cmFpbGluZyBzbGFzaGVzIHRocm91Z2hvdXQgdGhlIGFwcFxuXG4gIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGJhc2VuYW1lLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3BcbiAgfSksIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXSk7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuXG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxuICB9ID0gbG9jYXRpb25Qcm9wO1xuICBsZXQgbG9jYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG5cbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgcGF0aG5hbWU6IHRyYWlsaW5nUGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgaGFzaCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGtleVxuICAgICAgfSxcbiAgICAgIG5hdmlnYXRpb25UeXBlXG4gICAgfTtcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5LCBuYXZpZ2F0aW9uVHlwZV0pO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhsb2NhdGlvbkNvbnRleHQgIT0gbnVsbCwgXCI8Um91dGVyIGJhc2VuYW1lPVxcXCJcIiArIGJhc2VuYW1lICsgXCJcXFwiPiBpcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgVVJMIFwiICsgKFwiXFxcIlwiICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoICsgXCJcXFwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgXCIpICsgXCJiYXNlbmFtZSwgc28gdGhlIDxSb3V0ZXI+IHdvbid0IHJlbmRlciBhbnl0aGluZy5cIikgOiB2b2lkIDA7XG5cbiAgaWYgKGxvY2F0aW9uQ29udGV4dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbmF2aWdhdGlvbkNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHZhbHVlOiBsb2NhdGlvbkNvbnRleHRcbiAgfSkpO1xufVxuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBhIG5lc3RlZCB0cmVlIG9mIDxSb3V0ZT4gZWxlbWVudHMgdGhhdCByZW5kZXJzIHRoZSBicmFuY2hcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9yb3V0ZXNcbiAqL1xuZnVuY3Rpb24gUm91dGVzKF9yZWY2KSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgbG9jYXRpb25cbiAgfSA9IF9yZWY2O1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn1cblxuLyoqXG4gKiBDb21wb25lbnQgdG8gdXNlIGZvciByZW5kZXJpbmcgbGF6aWx5IGxvYWRlZCBkYXRhIGZyb20gcmV0dXJuaW5nIGRlZmVyKClcbiAqIGluIGEgbG9hZGVyIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIEF3YWl0KF9yZWY3KSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZXJyb3JFbGVtZW50LFxuICAgIHJlc29sdmVcbiAgfSA9IF9yZWY3O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXdhaXRFcnJvckJvdW5kYXJ5LCB7XG4gICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICBlcnJvckVsZW1lbnQ6IGVycm9yRWxlbWVudFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZXNvbHZlQXdhaXQsIG51bGwsIGNoaWxkcmVuKSk7XG59XG52YXIgQXdhaXRSZW5kZXJTdGF0dXM7XG5cbihmdW5jdGlvbiAoQXdhaXRSZW5kZXJTdGF0dXMpIHtcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJwZW5kaW5nXCJdID0gMF0gPSBcInBlbmRpbmdcIjtcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJzdWNjZXNzXCJdID0gMV0gPSBcInN1Y2Nlc3NcIjtcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJlcnJvclwiXSA9IDJdID0gXCJlcnJvclwiO1xufSkoQXdhaXRSZW5kZXJTdGF0dXMgfHwgKEF3YWl0UmVuZGVyU3RhdHVzID0ge30pKTtcblxuY29uc3QgbmV2ZXJTZXR0bGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcblxuY2xhc3MgQXdhaXRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCI8QXdhaXQ+IGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIiwgZXJyb3IsIGVycm9ySW5mbyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZXJyb3JFbGVtZW50LFxuICAgICAgcmVzb2x2ZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBwcm9taXNlID0gbnVsbDtcbiAgICBsZXQgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcblxuICAgIGlmICghKHJlc29sdmUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgLy8gRGlkbid0IGdldCBhIHByb21pc2UgLSBwcm92aWRlIGFzIGEgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2VzcztcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIC8vIENhdWdodCBhIHJlbmRlciBlcnJvciwgcHJvdmlkZSBpdCBhcyBhIHJlamVjdGVkIHByb21pc2VcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yO1xuICAgICAgbGV0IHJlbmRlckVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdCgpLmNhdGNoKCgpID0+IHt9KTsgLy8gQXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbiB3YXJuaW5nc1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHJlbmRlckVycm9yXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmUuX3RyYWNrZWQpIHtcbiAgICAgIC8vIEFscmVhZHkgdHJhY2tlZCBwcm9taXNlIC0gY2hlY2sgY29udGVudHNcbiAgICAgIHByb21pc2UgPSByZXNvbHZlO1xuICAgICAgc3RhdHVzID0gcHJvbWlzZS5fZXJyb3IgIT09IHVuZGVmaW5lZCA/IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yIDogcHJvbWlzZS5fZGF0YSAhPT0gdW5kZWZpbmVkID8gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2VzcyA6IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJhdyAodW50cmFja2VkKSBwcm9taXNlIC0gdHJhY2sgaXRcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcmVzb2x2ZS50aGVuKGRhdGEgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2RhdGFcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGRhdGFcbiAgICAgIH0pLCBlcnJvciA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgJiYgcHJvbWlzZS5fZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvcikge1xuICAgICAgLy8gRnJlZXplIHRoZSBVSSBieSB0aHJvd2luZyBhIG5ldmVyIHJlc29sdmVkIHByb21pc2VcbiAgICAgIHRocm93IG5ldmVyU2V0dGxlZFByb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgJiYgIWVycm9yRWxlbWVudCkge1xuICAgICAgLy8gTm8gZXJyb3JFbGVtZW50LCB0aHJvdyB0byB0aGUgbmVhcmVzdCByb3V0ZS1sZXZlbCBlcnJvciBib3VuZGFyeVxuICAgICAgdGhyb3cgcHJvbWlzZS5fZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IpIHtcbiAgICAgIC8vIFJlbmRlciB2aWEgb3VyIGVycm9yRWxlbWVudFxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcHJvbWlzZSxcbiAgICAgICAgY2hpbGRyZW46IGVycm9yRWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgLy8gUmVuZGVyIGNoaWxkcmVuIHdpdGggcmVzb2x2ZWQgdmFsdWVcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBd2FpdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHByb21pc2UsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfSAvLyBUaHJvdyB0byB0aGUgc3VzcGVuc2UgYm91bmRhcnlcblxuXG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxuXG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBJbmRpcmVjdGlvbiB0byBsZXZlcmFnZSB1c2VBc3luY1ZhbHVlIGZvciBhIHJlbmRlci1wcm9wIEFQSSBvbiA8QXdhaXQ+XG4gKi9cblxuXG5mdW5jdGlvbiBSZXNvbHZlQXdhaXQoX3JlZjgpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjg7XG4gIGxldCBkYXRhID0gdXNlQXN5bmNWYWx1ZSgpO1xuICBsZXQgdG9SZW5kZXIgPSB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKGRhdGEpIDogY2hpbGRyZW47XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgdG9SZW5kZXIpO1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZXMgYSByb3V0ZSBjb25maWcgZnJvbSBhIFJlYWN0IFwiY2hpbGRyZW5cIiBvYmplY3QsIHdoaWNoIGlzIHVzdWFsbHlcbiAqIGVpdGhlciBhIGA8Um91dGU+YCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZW0uIFVzZWQgaW50ZXJuYWxseSBieVxuICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9jcmVhdGUtcm91dGVzLWZyb20tY2hpbGRyZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50UGF0aCkge1xuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFtdO1xuICB9XG5cbiAgbGV0IHJvdXRlcyA9IFtdO1xuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoISAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIElnbm9yZSBub24tZWxlbWVudHMuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBtb3JlIGVhc2lseSBpbmxpbmVcbiAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICAvLyBUcmFuc3BhcmVudGx5IHN1cHBvcnQgUmVhY3QuRnJhZ21lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgIHJvdXRlcy5wdXNoLmFwcGx5KHJvdXRlcywgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHRyZWVQYXRoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgIShlbGVtZW50LnR5cGUgPT09IFJvdXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiW1wiICsgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZSkgKyBcIl0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEoIWVsZW1lbnQucHJvcHMuaW5kZXggfHwgIWVsZW1lbnQucHJvcHMuY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJBbiBpbmRleCByb3V0ZSBjYW5ub3QgaGF2ZSBjaGlsZCByb3V0ZXMuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgbGV0IHJvdXRlID0ge1xuICAgICAgaWQ6IGVsZW1lbnQucHJvcHMuaWQgfHwgdHJlZVBhdGguam9pbihcIi1cIiksXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBlbGVtZW50LnByb3BzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICBDb21wb25lbnQ6IGVsZW1lbnQucHJvcHMuQ29tcG9uZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGgsXG4gICAgICBsb2FkZXI6IGVsZW1lbnQucHJvcHMubG9hZGVyLFxuICAgICAgYWN0aW9uOiBlbGVtZW50LnByb3BzLmFjdGlvbixcbiAgICAgIGVycm9yRWxlbWVudDogZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQsXG4gICAgICBFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnksXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnkgIT0gbnVsbCB8fCBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCAhPSBudWxsLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZWxlbWVudC5wcm9wcy5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgaGFuZGxlOiBlbGVtZW50LnByb3BzLmhhbmRsZSxcbiAgICAgIGxhenk6IGVsZW1lbnQucHJvcHMubGF6eVxuICAgIH07XG5cbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpO1xuICAgIH1cblxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG4gIHJldHVybiByb3V0ZXM7XG59XG4vKipcbiAqIFJlbmRlcnMgdGhlIHJlc3VsdCBvZiBgbWF0Y2hSb3V0ZXMoKWAgaW50byBhIFJlYWN0IGVsZW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cblxuZnVuY3Rpb24gbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSB7XG4gIGxldCB1cGRhdGVzID0ge1xuICAgIC8vIE5vdGU6IHRoaXMgY2hlY2sgYWxzbyBvY2N1cnMgaW4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIHNvIHVwZGF0ZVxuICAgIC8vIHRoZXJlIGlmIHlvdSBjaGFuZ2UgdGhpcyAtLSBwbGVhc2UgYW5kIHRoYW5rIHlvdSFcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGxcbiAgfTtcblxuICBpZiAocm91dGUuQ29tcG9uZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBDb21wb25lbnRgIGFuZCBgZWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgQ29tcG9uZW50YCB3aWxsIGJlIHVzZWQuXCIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuQ29tcG9uZW50KSxcbiAgICAgIENvbXBvbmVudDogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuRXJyb3JCb3VuZGFyeSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChyb3V0ZS5lcnJvckVsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBFcnJvckJvdW5kYXJ5YCBhbmQgYGVycm9yRWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgRXJyb3JCb3VuZGFyeWAgd2lsbCBiZSB1c2VkLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVycm9yRWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXG4gICAgICBFcnJvckJvdW5kYXJ5OiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICB9KSxcbiAgICBoaXN0b3J5OiBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmluaXRpYWxJbmRleFxuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzXG4gIH0pLmluaXRpYWxpemUoKTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgeyBBd2FpdCwgTWVtb3J5Um91dGVyLCBOYXZpZ2F0ZSwgT3V0bGV0LCBSb3V0ZSwgUm91dGVyLCBSb3V0ZXJQcm92aWRlciwgUm91dGVzLCBEYXRhUm91dGVyQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgYXMgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsIExvY2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTG9jYXRpb25Db250ZXh0LCBOYXZpZ2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIFJvdXRlQ29udGV4dCBhcyBVTlNBRkVfUm91dGVDb250ZXh0LCBtYXBSb3V0ZVByb3BlcnRpZXMgYXMgVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcywgdXNlUm91dGVJZCBhcyBVTlNBRkVfdXNlUm91dGVJZCwgdXNlUm91dGVzSW1wbCBhcyBVTlNBRkVfdXNlUm91dGVzSW1wbCwgY3JlYXRlTWVtb3J5Um91dGVyLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBhcyBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsIHJlbmRlck1hdGNoZXMsIHVzZUJsb2NrZXIgYXMgdW5zdGFibGVfdXNlQmxvY2tlciwgdXNlQWN0aW9uRGF0YSwgdXNlQXN5bmNFcnJvciwgdXNlQXN5bmNWYWx1ZSwgdXNlSHJlZiwgdXNlSW5Sb3V0ZXJDb250ZXh0LCB1c2VMb2FkZXJEYXRhLCB1c2VMb2NhdGlvbiwgdXNlTWF0Y2gsIHVzZU1hdGNoZXMsIHVzZU5hdmlnYXRlLCB1c2VOYXZpZ2F0aW9uLCB1c2VOYXZpZ2F0aW9uVHlwZSwgdXNlT3V0bGV0LCB1c2VPdXRsZXRDb250ZXh0LCB1c2VQYXJhbXMsIHVzZVJlc29sdmVkUGF0aCwgdXNlUmV2YWxpZGF0b3IsIHVzZVJvdXRlRXJyb3IsIHVzZVJvdXRlTG9hZGVyRGF0YSwgdXNlUm91dGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlVOU0FGRV9pbnZhcmlhbnQiLCJqb2luUGF0aHMiLCJtYXRjaFBhdGgiLCJVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJVTlNBRkVfd2FybmluZyIsInJlc29sdmVUbyIsInBhcnNlUGF0aCIsIm1hdGNoUm91dGVzIiwiQWN0aW9uIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJjcmVhdGVNZW1vcnlIaXN0b3J5Iiwic3RyaXBCYXNlbmFtZSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiY3JlYXRlUm91dGVyIiwiTmF2aWdhdGlvblR5cGUiLCJjcmVhdGVQYXRoIiwiZGVmZXIiLCJnZW5lcmF0ZVBhdGgiLCJqc29uIiwicmVkaXJlY3QiLCJyZXNvbHZlUGF0aCIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIkRhdGFSb3V0ZXJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSIsIkRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJBd2FpdENvbnRleHQiLCJOYXZpZ2F0aW9uQ29udGV4dCIsIkxvY2F0aW9uQ29udGV4dCIsIlJvdXRlQ29udGV4dCIsIm91dGxldCIsIm1hdGNoZXMiLCJpc0RhdGFSb3V0ZSIsIlJvdXRlRXJyb3JDb250ZXh0IiwidXNlSHJlZiIsInRvIiwiX3RlbXAiLCJyZWxhdGl2ZSIsInVzZUluUm91dGVyQ29udGV4dCIsImJhc2VuYW1lIiwibmF2aWdhdG9yIiwidXNlQ29udGV4dCIsImhhc2giLCJwYXRobmFtZSIsInNlYXJjaCIsInVzZVJlc29sdmVkUGF0aCIsImpvaW5lZFBhdGhuYW1lIiwiY3JlYXRlSHJlZiIsInVzZUxvY2F0aW9uIiwibG9jYXRpb24iLCJ1c2VOYXZpZ2F0aW9uVHlwZSIsIm5hdmlnYXRpb25UeXBlIiwidXNlTWF0Y2giLCJwYXR0ZXJuIiwidXNlTWVtbyIsIm5hdmlnYXRlRWZmZWN0V2FybmluZyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjYiIsImlzU3RhdGljIiwic3RhdGljIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTmF2aWdhdGUiLCJ1c2VOYXZpZ2F0ZVN0YWJsZSIsInVzZU5hdmlnYXRlVW5zdGFibGUiLCJkYXRhUm91dGVyQ29udGV4dCIsImxvY2F0aW9uUGF0aG5hbWUiLCJyb3V0ZVBhdGhuYW1lc0pzb24iLCJKU09OIiwic3RyaW5naWZ5IiwibWFwIiwibWF0Y2giLCJwYXRobmFtZUJhc2UiLCJhY3RpdmVSZWYiLCJ1c2VSZWYiLCJjdXJyZW50IiwibmF2aWdhdGUiLCJ1c2VDYWxsYmFjayIsIm9wdGlvbnMiLCJnbyIsInBhdGgiLCJwYXJzZSIsInJlcGxhY2UiLCJwdXNoIiwic3RhdGUiLCJPdXRsZXRDb250ZXh0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZU91dGxldCIsImNvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZVBhcmFtcyIsInJvdXRlTWF0Y2giLCJwYXJhbXMiLCJfdGVtcDIiLCJ1c2VSb3V0ZXMiLCJyb3V0ZXMiLCJsb2NhdGlvbkFyZyIsInVzZVJvdXRlc0ltcGwiLCJkYXRhUm91dGVyU3RhdGUiLCJwYXJlbnRNYXRjaGVzIiwicGFyZW50UGFyYW1zIiwicGFyZW50UGF0aG5hbWUiLCJwYXJlbnRQYXRobmFtZUJhc2UiLCJwYXJlbnRSb3V0ZSIsInJvdXRlIiwicGFyZW50UGF0aCIsIndhcm5pbmdPbmNlIiwiZW5kc1dpdGgiLCJsb2NhdGlvbkZyb21Db250ZXh0IiwiX3BhcnNlZExvY2F0aW9uQXJnJHBhIiwicGFyc2VkTG9jYXRpb25BcmciLCJzdGFydHNXaXRoIiwicmVtYWluaW5nUGF0aG5hbWUiLCJzbGljZSIsImVsZW1lbnQiLCJ1bmRlZmluZWQiLCJDb21wb25lbnQiLCJyZW5kZXJlZE1hdGNoZXMiLCJfcmVuZGVyTWF0Y2hlcyIsImVuY29kZUxvY2F0aW9uIiwiUG9wIiwiRGVmYXVsdEVycm9yQ29tcG9uZW50IiwiZXJyb3IiLCJ1c2VSb3V0ZUVycm9yIiwibWVzc2FnZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJFcnJvciIsInN0YWNrIiwibGlnaHRncmV5IiwicHJlU3R5bGVzIiwicGFkZGluZyIsImJhY2tncm91bmRDb2xvciIsImNvZGVTdHlsZXMiLCJkZXZJbmZvIiwiY29uc29sZSIsIkZyYWdtZW50Iiwic3R5bGUiLCJmb250U3R5bGUiLCJkZWZhdWx0RXJyb3JFbGVtZW50IiwiUmVuZGVyRXJyb3JCb3VuZGFyeSIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJyZXZhbGlkYXRpb24iLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnREaWRDYXRjaCIsImVycm9ySW5mbyIsInJlbmRlciIsInJvdXRlQ29udGV4dCIsImNoaWxkcmVuIiwiY29tcG9uZW50IiwiUmVuZGVyZWRSb3V0ZSIsIl9yZWYiLCJzdGF0aWNDb250ZXh0IiwiZXJyb3JFbGVtZW50IiwiRXJyb3JCb3VuZGFyeSIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwiaWQiLCJfZGF0YVJvdXRlclN0YXRlMiIsIl9kYXRhUm91dGVyU3RhdGUiLCJlcnJvcnMiLCJlcnJvckluZGV4IiwiZmluZEluZGV4IiwibSIsImtleXMiLCJqb2luIiwiTWF0aCIsIm1pbiIsInJlZHVjZVJpZ2h0IiwiaW5kZXgiLCJjb25jYXQiLCJnZXRDaGlsZHJlbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwidXNlRGF0YVJvdXRlclN0YXRlIiwidXNlUm91dGVDb250ZXh0IiwidXNlQ3VycmVudFJvdXRlSWQiLCJ0aGlzUm91dGUiLCJ1c2VSb3V0ZUlkIiwiVXNlUm91dGVJZCIsInVzZU5hdmlnYXRpb24iLCJVc2VOYXZpZ2F0aW9uIiwibmF2aWdhdGlvbiIsInVzZVJldmFsaWRhdG9yIiwiVXNlUmV2YWxpZGF0b3IiLCJyZXZhbGlkYXRlIiwicm91dGVyIiwidXNlTWF0Y2hlcyIsImxvYWRlckRhdGEiLCJVc2VNYXRjaGVzIiwiZGF0YSIsImhhbmRsZSIsInVzZUxvYWRlckRhdGEiLCJVc2VMb2FkZXJEYXRhIiwicm91dGVJZCIsInVzZVJvdXRlTG9hZGVyRGF0YSIsIlVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZUFjdGlvbkRhdGEiLCJVc2VBY3Rpb25EYXRhIiwidmFsdWVzIiwiYWN0aW9uRGF0YSIsIl9zdGF0ZSRlcnJvcnMiLCJVc2VSb3V0ZUVycm9yIiwidXNlQXN5bmNWYWx1ZSIsIl9kYXRhIiwidXNlQXN5bmNFcnJvciIsIl9lcnJvciIsImJsb2NrZXJJZCIsInVzZUJsb2NrZXIiLCJzaG91bGRCbG9jayIsIlVzZUJsb2NrZXIiLCJibG9ja2VyS2V5IiwidXNlU3RhdGUiLCJTdHJpbmciLCJibG9ja2VyRnVuY3Rpb24iLCJhcmdzIiwiYmxvY2tlciIsImdldEJsb2NrZXIiLCJ1c2VFZmZlY3QiLCJkZWxldGVCbG9ja2VyIiwiYmxvY2tlcnMiLCJnZXQiLCJVc2VOYXZpZ2F0ZVN0YWJsZSIsImZyb21Sb3V0ZUlkIiwiYWxyZWFkeVdhcm5lZCIsImNvbmQiLCJSb3V0ZXJQcm92aWRlciIsImZhbGxiYWNrRWxlbWVudCIsInNldFN0YXRlIiwic3Vic2NyaWJlIiwibiIsIm9wdHMiLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJSb3V0ZXIiLCJoaXN0b3J5QWN0aW9uIiwiaW5pdGlhbGl6ZWQiLCJEYXRhUm91dGVzIiwiX3JlZjIiLCJNZW1vcnlSb3V0ZXIiLCJfcmVmMyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwiaGlzdG9yeVJlZiIsInY1Q29tcGF0IiwiaGlzdG9yeSIsImFjdGlvbiIsImxpc3RlbiIsIk5hdmlnYXRlIiwiX3JlZjQiLCJqc29uUGF0aCIsIk91dGxldCIsIlJvdXRlIiwiX3Byb3BzIiwiX3JlZjUiLCJiYXNlbmFtZVByb3AiLCJsb2NhdGlvblByb3AiLCJzdGF0aWNQcm9wIiwibmF2aWdhdGlvbkNvbnRleHQiLCJsb2NhdGlvbkNvbnRleHQiLCJ0cmFpbGluZ1BhdGhuYW1lIiwiUm91dGVzIiwiX3JlZjYiLCJjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4iLCJBd2FpdCIsIl9yZWY3IiwicmVzb2x2ZSIsIkF3YWl0RXJyb3JCb3VuZGFyeSIsIlJlc29sdmVBd2FpdCIsIkF3YWl0UmVuZGVyU3RhdHVzIiwibmV2ZXJTZXR0bGVkUHJvbWlzZSIsIlByb21pc2UiLCJwcm9taXNlIiwicGVuZGluZyIsInN1Y2Nlc3MiLCJkZWZpbmVQcm9wZXJ0eSIsInJlbmRlckVycm9yIiwicmVqZWN0IiwiY2F0Y2giLCJfdHJhY2tlZCIsInRoZW4iLCJfcmVmOCIsInRvUmVuZGVyIiwiQ2hpbGRyZW4iLCJmb3JFYWNoIiwiaXNWYWxpZEVsZW1lbnQiLCJ0cmVlUGF0aCIsInR5cGUiLCJuYW1lIiwiY2FzZVNlbnNpdGl2ZSIsImxvYWRlciIsImhhc0Vycm9yQm91bmRhcnkiLCJzaG91bGRSZXZhbGlkYXRlIiwibGF6eSIsInJlbmRlck1hdGNoZXMiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJ1cGRhdGVzIiwiY3JlYXRlTWVtb3J5Um91dGVyIiwiZnV0dXJlIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwiaHlkcmF0aW9uRGF0YSIsImluaXRpYWxpemUiLCJVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQiLCJVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIlVOU0FGRV9Mb2NhdGlvbkNvbnRleHQiLCJVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQiLCJVTlNBRkVfUm91dGVDb250ZXh0IiwiVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyIsIlVOU0FGRV91c2VSb3V0ZUlkIiwiVU5TQUZFX3VzZVJvdXRlc0ltcGwiLCJjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMiLCJ1bnN0YWJsZV91c2VCbG9ja2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/react-router/dist/index.js\n");

/***/ })

};
;