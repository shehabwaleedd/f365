"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router-dom";
exports.ids = ["vendor-chunks/react-router-dom"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/react-router-dom/dist/index.js":
/*!************************************************************!*\
  !*** ../../../node_modules/react-router-dom/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Await),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.MemoryRouter),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Outlet),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Router),\n/* harmony export */   RouterProvider: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Routes),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext),\n/* harmony export */   UNSAFE_useRouteId: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_useRouteId),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   unstable_useBlocker: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.unstable_useBlocker),\n/* harmony export */   unstable_usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router */ \"(ssr)/../../../node_modules/react-router/dist/index.js\");\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"(ssr)/../../../node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router DOM v6.11.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */ function createSearchParams(init) {\n    if (init === void 0) {\n        init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key)=>{\n        let value = init[key];\n        return memo.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        for (let key of defaultSearchParams.keys()){\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach((value)=>{\n                    searchParams.append(key, value);\n                });\n            }\n        }\n    }\n    return searchParams;\n}\nfunction getFormSubmissionInfo(target, options, basename) {\n    let method;\n    let action = null;\n    let encType;\n    let formData;\n    if (isFormElement(target)) {\n        let submissionTrigger = options.submissionTrigger;\n        if (options.action) {\n            action = options.action;\n        } else {\n            // When grabbing the action from the element, it will have had the basename\n            // prefixed to ensure non-JS scenarios work, so strip it since we'll\n            // re-prefix in the router\n            let attr = target.getAttribute(\"action\");\n            action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(attr, basename) : null;\n        }\n        method = options.method || target.getAttribute(\"method\") || defaultMethod;\n        encType = options.encType || target.getAttribute(\"enctype\") || defaultEncType;\n        formData = new FormData(target);\n        if (submissionTrigger && submissionTrigger.name) {\n            formData.append(submissionTrigger.name, submissionTrigger.value);\n        }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) {\n            throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n        } // <button>/<input type=\"submit\"> may override attributes of <form>\n        if (options.action) {\n            action = options.action;\n        } else {\n            // When grabbing the action from the element, it will have had the basename\n            // prefixed to ensure non-JS scenarios work, so strip it since we'll\n            // re-prefix in the router\n            let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n            action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(attr, basename) : null;\n        }\n        method = options.method || target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = options.encType || target.getAttribute(\"formenctype\") || form.getAttribute(\"enctype\") || defaultEncType;\n        formData = new FormData(form); // Include name + value from a <button>, appending in case the button name\n        // matches an existing input name\n        if (target.name) {\n            formData.append(target.name, target.value);\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + '<input type=\"submit|image\">');\n    } else {\n        method = options.method || defaultMethod;\n        action = options.action || null;\n        encType = options.encType || defaultEncType;\n        if (target instanceof FormData) {\n            formData = target;\n        } else {\n            formData = new FormData();\n            if (target instanceof URLSearchParams) {\n                for (let [name, value] of target){\n                    formData.append(name, value);\n                }\n            } else if (target != null) {\n                for (let name of Object.keys(target)){\n                    formData.append(name, target[name]);\n                }\n            }\n        }\n    }\n    return {\n        action,\n        method: method.toLowerCase(),\n        encType,\n        formData\n    };\n}\nconst _excluded = [\n    \"onClick\",\n    \"relative\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"target\",\n    \"to\",\n    \"preventScrollReset\"\n], _excluded2 = [\n    \"aria-current\",\n    \"caseSensitive\",\n    \"className\",\n    \"end\",\n    \"style\",\n    \"to\",\n    \"children\"\n], _excluded3 = [\n    \"reloadDocument\",\n    \"replace\",\n    \"method\",\n    \"action\",\n    \"onSubmit\",\n    \"fetcherKey\",\n    \"routeId\",\n    \"relative\",\n    \"preventScrollReset\"\n];\nfunction createBrowserRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_mapRouteProperties\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_mapRouteProperties\n    }).initialize();\n}\nfunction parseHydrationData() {\n    var _window;\n    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = _extends({}, state, {\n            errors: deserializeErrors(state.errors)\n        });\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        // Hey you!  If you change this, please change the corresponding logic in\n        // serializeErrors in react-router-dom/server.tsx :)\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_1__.ErrorResponse(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            let error = new Error(val.message); // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don't serialize SSR stack traces for security reasons\n            error.stack = \"\";\n            serialized[key] = error;\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */ function BrowserRouter(_ref) {\n    let { basename, children, window: window1 } = _ref;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */ function HashRouter(_ref2) {\n    let { basename, children, window: window1 } = _ref2;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */ function HistoryRouter(_ref3) {\n    let { basename, children, history } = _ref3;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nif (true) {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser =  false && 0;\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware <a>.\n */ const Link = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref4, ref) {\n    let { onClick, relative, reloadDocument, replace, state, target, to, preventScrollReset } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext); // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n        // Render the absolute href server- and client-side\n        absoluteHref = to; // Only check for external origins client-side\n        if (isBrowser) {\n            try {\n                let currentUrl = new URL(window.location.href);\n                let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                let path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    // Strip the protocol/origin/basename for same-origin absolute URLs\n                    to = path + targetUrl.search + targetUrl.hash;\n                } else {\n                    isExternal = true;\n                }\n            } catch (e) {\n                // We can't do external URL detection without a valid URL\n                 true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, '<Link to=\"' + to + '\"> contains an invalid URL which will probably break ' + \"when clicked - please update to a valid URL path.\") : 0;\n            }\n        }\n    } // Rendered into <a href> for relative URLs\n    let href = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useHref)(to, {\n        relative\n    });\n    let internalOnClick = useLinkClickHandler(to, {\n        replace,\n        state,\n        target,\n        preventScrollReset,\n        relative\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n    })));\n});\nif (true) {\n    Link.displayName = \"Link\";\n}\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */ const NavLink = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref5, ref) {\n    let { \"aria-current\": ariaCurrentProp = \"page\", caseSensitive = false, className: classNameProp = \"\", end = false, style: styleProp, to, children } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {\n        relative: rest.relative\n    });\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);\n    let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    let className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp({\n            isActive,\n            isPending\n        });\n    } else {\n        // If the className prop is not a function, we use a default `active`\n        // class for <NavLink />s that are active. In v5 `active` was the default\n        // value for `activeClassName`, but we are removing that API and can still\n        // use the old default behavior for a cleaner upgrade path and keep the\n        // simple styling rules working as they currently do.\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp({\n        isActive,\n        isPending\n    }) : styleProp;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\n        \"aria-current\": ariaCurrent,\n        className: className,\n        ref: ref,\n        style: style,\n        to: to\n    }), typeof children === \"function\" ? children({\n        isActive,\n        isPending\n    }) : children);\n});\nif (true) {\n    NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */ const Form = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {\n        ref: ref\n    }));\n});\nif (true) {\n    Form.displayName = \"Form\";\n}\nconst FormImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref6, forwardedRef)=>{\n    let { reloadDocument, replace, method = defaultMethod, action, onSubmit, fetcherKey, routeId, relative, preventScrollReset } = _ref6, props = _objectWithoutPropertiesLoose(_ref6, _excluded3);\n    let submit = useSubmitImpl(fetcherKey, routeId);\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let formAction = useFormAction(action, {\n        relative\n    });\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n        submit(submitter || event.currentTarget, {\n            method: submitMethod,\n            replace,\n            relative,\n            preventScrollReset\n        });\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", _extends({\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n});\nif (true) {\n    FormImpl.displayName = \"FormImpl\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */ function ScrollRestoration(_ref7) {\n    let { getKey, storageKey } = _ref7;\n    useScrollRestoration({\n        getKey,\n        storageKey\n    });\n    return null;\n}\nif (true) {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmitImpl\"] = \"useSubmitImpl\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext);\n    !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);\n    !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */ function useLinkClickHandler(to, _temp) {\n    let { target, replace: replaceProp, state, preventScrollReset, relative } = _temp === void 0 ? {} : _temp;\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {\n        relative\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>{\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of\n            // a push, so do the same here unless the replace prop is explicitly set\n            let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);\n            navigate(to, {\n                replace,\n                state,\n                preventScrollReset,\n                relative\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative\n    ]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */ function useSearchParams(defaultInit) {\n     true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : 0;\n    let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>// Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();\n    let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */ function useSubmit() {\n    return useSubmitImpl();\n}\nfunction useSubmitImpl(fetcherKey, fetcherRouteId) {\n    let { router } = useDataRouterContext(DataRouterHook.UseSubmitImpl);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\n    let currentRouteId = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_useRouteId)();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        if (typeof document === \"undefined\") {\n            throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n        }\n        let { action, method, encType, formData } = getFormSubmissionInfo(target, options, basename); // Base options shared between fetch() and navigate()\n        let opts = {\n            preventScrollReset: options.preventScrollReset,\n            formData,\n            formMethod: method,\n            formEncType: encType\n        };\n        if (fetcherKey) {\n            !(fetcherRouteId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"No routeId available for useFetcher()\") : 0 : void 0;\n            router.fetch(fetcherKey, fetcherRouteId, action, opts);\n        } else {\n            router.navigate(action, _extends({}, opts, {\n                replace: options.replace,\n                fromRouteId: currentRouteId\n            }));\n        }\n    }, [\n        router,\n        basename,\n        fetcherKey,\n        fetcherRouteId,\n        currentRouteId\n    ]);\n} // v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\n    let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);\n    !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"useFormAction must be used inside a RouteContext\") : 0 : void 0;\n    let [match] = routeContext.matches.slice(-1); // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(action ? action : \".\", {\n        relative\n    })); // Previously we set the default action to \".\". The problem with this is that\n    // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\n    // URL. This is the intended behavior of when \".\" is specifically provided as\n    // the form action, but inconsistent w/ browsers when the action is omitted.\n    // https://github.com/remix-run/remix/issues/927\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    if (action == null) {\n        // Safe to write to these directly here since if action was undefined, we\n        // would have called useResolvedPath(\".\") which will never include a search\n        // or hash\n        path.search = location.search;\n        path.hash = location.hash; // When grabbing search params from the URL, remove the automatically\n        // inserted ?index param so we match the useResolvedPath search behavior\n        // which would not include ?index\n        if (match.route.index) {\n            let params = new URLSearchParams(path.search);\n            params.delete(\"index\");\n            path.search = params.toString() ? \"?\" + params.toString() : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    } // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n            basename,\n            path.pathname\n        ]);\n    }\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);\n}\nfunction createFetcherForm(fetcherKey, routeId) {\n    let FetcherForm = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {\n            ref: ref,\n            fetcherKey: fetcherKey,\n            routeId: routeId\n        }));\n    });\n    if (true) {\n        FetcherForm.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm;\n}\nlet fetcherId = 0;\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */ function useFetcher() {\n    var _route$matches;\n    let { router } = useDataRouterContext(DataRouterHook.UseFetcher);\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);\n    !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"useFetcher must be used inside a RouteContext\") : 0 : void 0;\n    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, 'useFetcher can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    let [fetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>String(++fetcherId));\n    let [Form] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"No routeId available for fetcher.Form()\") : 0 : void 0;\n        return createFetcherForm(fetcherKey, routeId);\n    });\n    let [load] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>(href)=>{\n            !router ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"No router available for fetcher.load()\") : 0 : void 0;\n            !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"No routeId available for fetcher.load()\") : 0 : void 0;\n            router.fetch(fetcherKey, routeId, href);\n        });\n    let submit = useSubmitImpl(fetcherKey, routeId);\n    let fetcher = router.getFetcher(fetcherKey);\n    let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>_extends({\n            Form,\n            submit,\n            load\n        }, fetcher), [\n        fetcher,\n        Form,\n        submit,\n        load\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Is this busted when the React team gets real weird and calls effects\n        // twice on mount?  We really just need to garbage collect here when this\n        // fetcher is no longer around.\n        return ()=>{\n            if (!router) {\n                console.warn(\"No router available to clean up from useFetcher()\");\n                return;\n            }\n            router.deleteFetcher(fetcherKey);\n        };\n    }, [\n        router,\n        fetcherKey\n    ]);\n    return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */ function useFetchers() {\n    let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return [\n        ...state.fetchers.values()\n    ];\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */ function useScrollRestoration(_temp3) {\n    let { getKey, storageKey } = _temp3 === void 0 ? {} : _temp3;\n    let { router } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n    let { restoreScrollPosition, preventScrollReset } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches)();\n    let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation)(); // Trigger manual scroll restoration while we're active\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []); // Save positions on pagehide\n    usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = (getKey ? getKey(location, matches) : null) || location.key;\n            savedScrollPositions[key] = window.scrollY;\n        }\n        sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        storageKey,\n        getKey,\n        navigation.state,\n        location,\n        matches\n    ])); // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            } catch (e) {}\n        }, [\n            storageKey\n        ]); // Enable scroll restoration in the router\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, getKey);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            getKey\n        ]); // Restore scrolling when state.restoreScrollPosition changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            // Explicit false means don't do anything (used for submissions)\n            if (restoreScrollPosition === false) {\n                return;\n            } // been here before, scroll to it\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            } // try to scroll to the hash\n            if (location.hash) {\n                let el = document.getElementById(location.hash.slice(1));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            } // Don't reset if this navigation opted out\n            if (preventScrollReset === true) {\n                return;\n            } // otherwise go to the top on new locations\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function useBeforeUnload(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function usePageHide(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */ function usePrompt(_ref8) {\n    let { when, message } = _ref8;\n    let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.unstable_useBlocker)(when);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [\n        blocker,\n        when\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) {\n                setTimeout(blocker.proceed, 0);\n            } else {\n                blocker.reset();\n            }\n        }\n    }, [\n        blocker,\n        message\n    ]);\n}\n//#endregion\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUM4QjtBQUM2UTtBQUM4ZjtBQUNyb0I7QUFFckssU0FBUzZEO0lBQ1BBLFdBQVdDLE9BQU9DLE1BQU0sR0FBR0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUNoRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUV6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlQLE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPTDtJQUNUO0lBQ0EsT0FBT0osU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFQSxTQUFTUSw4QkFBOEJOLE1BQU0sRUFBRU8sUUFBUTtJQUNyRCxJQUFJUCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQzVCLElBQUlKLFNBQVMsQ0FBQztJQUNkLElBQUlZLGFBQWFmLE9BQU9nQixJQUFJLENBQUNUO0lBQzdCLElBQUlDLEtBQUtKO0lBRVQsSUFBS0EsSUFBSSxHQUFHQSxJQUFJVyxXQUFXVCxNQUFNLEVBQUVGLElBQUs7UUFDdENJLE1BQU1PLFVBQVUsQ0FBQ1gsRUFBRTtRQUNuQixJQUFJVSxTQUFTRyxPQUFPLENBQUNULFFBQVEsR0FBRztRQUNoQ0wsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFB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LE9BQU87WUFDM0JBO1FBQ0YsSUFBSTdHO1FBQ0psRyxPQUFPZ04sZ0JBQWdCLENBQUMsWUFBWUYsVUFBVWxOO1FBQzlDLE9BQU87WUFDTEksT0FBT2lOLG1CQUFtQixDQUFDLFlBQVlILFVBQVVsTjtRQUNuRDtJQUNGLEdBQUc7UUFBQ2tOO1FBQVVDO0tBQVE7QUFDeEI7QUFDQTs7Ozs7OztDQU9DLEdBR0QsU0FBU0csVUFBVUMsS0FBSztJQUN0QixJQUFJLEVBQ0ZDLElBQUksRUFDSmhNLE9BQU8sRUFDUixHQUFHK0w7SUFDSixJQUFJRSxVQUFVblYsaUVBQW1CQSxDQUFDa1Y7SUFDbENoVyw0Q0FBZSxDQUFDO1FBQ2QsSUFBSWlXLFFBQVE5TSxLQUFLLEtBQUssYUFBYSxDQUFDNk0sTUFBTTtZQUN4Q0MsUUFBUUMsS0FBSztRQUNmO0lBQ0YsR0FBRztRQUFDRDtRQUFTRDtLQUFLO0lBQ2xCaFcsNENBQWUsQ0FBQztRQUNkLElBQUlpVyxRQUFROU0sS0FBSyxLQUFLLFdBQVc7WUFDL0IsSUFBSWdOLFVBQVV2TixPQUFPd04sT0FBTyxDQUFDcE07WUFFN0IsSUFBSW1NLFNBQVM7Z0JBQ1hFLFdBQVdKLFFBQVFFLE9BQU8sRUFBRTtZQUM5QixPQUFPO2dCQUNMRixRQUFRQyxLQUFLO1lBQ2Y7UUFDRjtJQUNGLEdBQUc7UUFBQ0Q7UUFBU2pNO0tBQVE7QUFDdkI7QUFDQyxZQUFZO0FBRW9XLENBQ2pYLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2YzNTYvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZGlzdC9pbmRleC5qcz8zYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3QgUm91dGVyIERPTSB2Ni4xMS4yXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsIFJvdXRlciwgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LCB1c2VIcmVmLCB1c2VSZXNvbHZlZFBhdGgsIHVzZUxvY2F0aW9uLCBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCwgdXNlTmF2aWdhdGUsIGNyZWF0ZVBhdGgsIFVOU0FGRV91c2VSb3V0ZUlkLCBVTlNBRkVfUm91dGVDb250ZXh0LCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0aW9uLCB1bnN0YWJsZV91c2VCbG9ja2VyLCBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuZXhwb3J0IHsgQWJvcnRlZERlZmVycmVkRXJyb3IsIEF3YWl0LCBNZW1vcnlSb3V0ZXIsIE5hdmlnYXRlLCBOYXZpZ2F0aW9uVHlwZSwgT3V0bGV0LCBSb3V0ZSwgUm91dGVyLCBSb3V0ZXJQcm92aWRlciwgUm91dGVzLCBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LCBVTlNBRkVfTG9jYXRpb25Db250ZXh0LCBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIFVOU0FGRV9Sb3V0ZUNvbnRleHQsIFVOU0FGRV91c2VSb3V0ZUlkLCBjcmVhdGVNZW1vcnlSb3V0ZXIsIGNyZWF0ZVBhdGgsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiwgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgcGFyc2VQYXRoLCByZWRpcmVjdCwgcmVuZGVyTWF0Y2hlcywgcmVzb2x2ZVBhdGgsIHVuc3RhYmxlX3VzZUJsb2NrZXIsIHVzZUFjdGlvbkRhdGEsIHVzZUFzeW5jRXJyb3IsIHVzZUFzeW5jVmFsdWUsIHVzZUhyZWYsIHVzZUluUm91dGVyQ29udGV4dCwgdXNlTG9hZGVyRGF0YSwgdXNlTG9jYXRpb24sIHVzZU1hdGNoLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvbiwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVJldmFsaWRhdG9yLCB1c2VSb3V0ZUVycm9yLCB1c2VSb3V0ZUxvYWRlckRhdGEsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5pbXBvcnQgeyBzdHJpcEJhc2VuYW1lLCBjcmVhdGVSb3V0ZXIsIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgRXJyb3JSZXNwb25zZSwgVU5TQUZFX3dhcm5pbmcsIFVOU0FGRV9pbnZhcmlhbnQsIGpvaW5QYXRocyB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuY29uc3QgZGVmYXVsdE1ldGhvZCA9IFwiZ2V0XCI7XG5jb25zdCBkZWZhdWx0RW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC50YWdOYW1lID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNCdXR0b25FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYnV0dG9uXCI7XG59XG5mdW5jdGlvbiBpc0Zvcm1FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZm9ybVwiO1xufVxuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiO1xufVxuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAoIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAhdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KSAvLyBJZ25vcmUgY2xpY2tzIHdpdGggbW9kaWZpZXIga2V5c1xuICA7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBpbml0aWFsaXplci5cbiAqXG4gKiBUaGlzIGlzIGlkZW50aWNhbCB0byBgbmV3IFVSTFNlYXJjaFBhcmFtcyhpbml0KWAgZXhjZXB0IGl0IGFsc29cbiAqIHN1cHBvcnRzIGFycmF5cyBhcyB2YWx1ZXMgaW4gdGhlIG9iamVjdCBmb3JtIG9mIHRoZSBpbml0aWFsaXplclxuICogaW5zdGVhZCBvZiBqdXN0IHN0cmluZ3MuIFRoaXMgaXMgY29udmVuaWVudCB3aGVuIHlvdSBuZWVkIG11bHRpcGxlXG4gKiB2YWx1ZXMgZm9yIGEgZ2l2ZW4ga2V5LCBidXQgZG9uJ3Qgd2FudCB0byB1c2UgYW4gYXJyYXkgaW5pdGlhbGl6ZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Y6XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gKiAgICAgWydzb3J0JywgJ25hbWUnXSxcbiAqICAgICBbJ3NvcnQnLCAncHJpY2UnXVxuICogICBdKTtcbiAqXG4gKiB5b3UgY2FuIGRvOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh7XG4gKiAgICAgc29ydDogWyduYW1lJywgJ3ByaWNlJ11cbiAqICAgfSk7XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKGluaXQpIHtcbiAgaWYgKGluaXQgPT09IHZvaWQgMCkge1xuICAgIGluaXQgPSBcIlwiO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXModHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShpbml0KSB8fCBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID8gaW5pdCA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgIHJldHVybiBtZW1vLmNvbmNhdChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh2ID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dKTtcbiAgfSwgW10pKTtcbn1cbmZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uU2VhcmNoLCBkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xuXG4gIGlmIChkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGRlZmF1bHRTZWFyY2hQYXJhbXMua2V5cygpKSB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmdldEFsbChrZXkpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG5mdW5jdGlvbiBnZXRGb3JtU3VibWlzc2lvbkluZm8odGFyZ2V0LCBvcHRpb25zLCBiYXNlbmFtZSkge1xuICBsZXQgbWV0aG9kO1xuICBsZXQgYWN0aW9uID0gbnVsbDtcbiAgbGV0IGVuY1R5cGU7XG4gIGxldCBmb3JtRGF0YTtcblxuICBpZiAoaXNGb3JtRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgbGV0IHN1Ym1pc3Npb25UcmlnZ2VyID0gb3B0aW9ucy5zdWJtaXNzaW9uVHJpZ2dlcjtcblxuICAgIGlmIChvcHRpb25zLmFjdGlvbikge1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gZ3JhYmJpbmcgdGhlIGFjdGlvbiBmcm9tIHRoZSBlbGVtZW50LCBpdCB3aWxsIGhhdmUgaGFkIHRoZSBiYXNlbmFtZVxuICAgICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAgIC8vIHJlLXByZWZpeCBpbiB0aGUgcm91dGVyXG4gICAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIH1cblxuICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gb3B0aW9ucy5lbmNUeXBlIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG5cbiAgICBpZiAoc3VibWlzc2lvblRyaWdnZXIgJiYgc3VibWlzc2lvblRyaWdnZXIubmFtZSkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKHN1Ym1pc3Npb25UcmlnZ2VyLm5hbWUsIHN1Ym1pc3Npb25UcmlnZ2VyLnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuXG4gICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IG9yIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiPiB3aXRob3V0IGEgPGZvcm0+XCIpO1xuICAgIH0gLy8gPGJ1dHRvbj4vPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gbWF5IG92ZXJyaWRlIGF0dHJpYnV0ZXMgb2YgPGZvcm0+XG5cblxuICAgIGlmIChvcHRpb25zLmFjdGlvbikge1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gZ3JhYmJpbmcgdGhlIGFjdGlvbiBmcm9tIHRoZSBlbGVtZW50LCBpdCB3aWxsIGhhdmUgaGFkIHRoZSBiYXNlbmFtZVxuICAgICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcbiAgICAgIC8vIHJlLXByZWZpeCBpbiB0aGUgcm91dGVyXG4gICAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtYWN0aW9uXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICB9XG5cbiAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1lbmN0eXBlXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKTsgLy8gSW5jbHVkZSBuYW1lICsgdmFsdWUgZnJvbSBhIDxidXR0b24+LCBhcHBlbmRpbmcgaW4gY2FzZSB0aGUgYnV0dG9uIG5hbWVcbiAgICAvLyBtYXRjaGVzIGFuIGV4aXN0aW5nIGlucHV0IG5hbWVcblxuICAgIGlmICh0YXJnZXQubmFtZSkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKHRhcmdldC5uYW1lLCB0YXJnZXQudmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3VibWl0IGVsZW1lbnQgdGhhdCBpcyBub3QgPGZvcm0+LCA8YnV0dG9uPiwgb3IgXCIgKyBcIjxpbnB1dCB0eXBlPVxcXCJzdWJtaXR8aW1hZ2VcXFwiPlwiKTtcbiAgfSBlbHNlIHtcbiAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uIHx8IG51bGw7XG4gICAgZW5jVHlwZSA9IG9wdGlvbnMuZW5jVHlwZSB8fCBkZWZhdWx0RW5jVHlwZTtcblxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgZm9ybURhdGEgPSB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiB0YXJnZXQpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IG5hbWUgb2YgT2JqZWN0LmtleXModGFyZ2V0KSkge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhY3Rpb24sXG4gICAgbWV0aG9kOiBtZXRob2QudG9Mb3dlckNhc2UoKSxcbiAgICBlbmNUeXBlLFxuICAgIGZvcm1EYXRhXG4gIH07XG59XG5cbmNvbnN0IF9leGNsdWRlZCA9IFtcIm9uQ2xpY2tcIiwgXCJyZWxhdGl2ZVwiLCBcInJlbG9hZERvY3VtZW50XCIsIFwicmVwbGFjZVwiLCBcInN0YXRlXCIsIFwidGFyZ2V0XCIsIFwidG9cIiwgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIl0sXG4gICAgICBfZXhjbHVkZWQyID0gW1wiYXJpYS1jdXJyZW50XCIsIFwiY2FzZVNlbnNpdGl2ZVwiLCBcImNsYXNzTmFtZVwiLCBcImVuZFwiLCBcInN0eWxlXCIsIFwidG9cIiwgXCJjaGlsZHJlblwiXSxcbiAgICAgIF9leGNsdWRlZDMgPSBbXCJyZWxvYWREb2N1bWVudFwiLCBcInJlcGxhY2VcIiwgXCJtZXRob2RcIiwgXCJhY3Rpb25cIiwgXCJvblN1Ym1pdFwiLCBcImZldGNoZXJLZXlcIiwgXCJyb3V0ZUlkXCIsIFwicmVsYXRpdmVcIiwgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIl07XG5mdW5jdGlvbiBjcmVhdGVCcm93c2VyUm91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iYXNlbmFtZSxcbiAgICBmdXR1cmU6IF9leHRlbmRzKHt9LCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmZ1dHVyZSwge1xuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlXG4gICAgfSksXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3Rvcnkoe1xuICAgICAgd2luZG93OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLndpbmRvd1xuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmh5ZHJhdGlvbkRhdGEpIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXNcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzaFJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgIH0pLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUhhc2hIaXN0b3J5KHtcbiAgICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgICB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhKSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzOiBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIeWRyYXRpb25EYXRhKCkge1xuICB2YXIgX3dpbmRvdztcblxuICBsZXQgc3RhdGUgPSAoX3dpbmRvdyA9IHdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3cuX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhO1xuXG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3JzKGVycm9ycykge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQgPSB7fTtcblxuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICAvLyBIZXkgeW91ISAgSWYgeW91IGNoYW5nZSB0aGlzLCBwbGVhc2UgY2hhbmdlIHRoZSBjb3JyZXNwb25kaW5nIGxvZ2ljIGluXG4gICAgLy8gc2VyaWFsaXplRXJyb3JzIGluIHJlYWN0LXJvdXRlci1kb20vc2VydmVyLnRzeCA6KVxuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2UodmFsLnN0YXR1cywgdmFsLnN0YXR1c1RleHQsIHZhbC5kYXRhLCB2YWwuaW50ZXJuYWwgPT09IHRydWUpO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiRXJyb3JcIikge1xuICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTsgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXG4gICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHNlcmlhbGl6ZSBTU1Igc3RhY2sgdHJhY2VzIGZvciBzZWN1cml0eSByZWFzb25zXG5cbiAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gUHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKi9cblxuXG5mdW5jdGlvbiBCcm93c2VyUm91dGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICB3aW5kb3dcbiAgfSA9IF9yZWY7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmKCk7XG5cbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnkoe1xuICAgICAgd2luZG93LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gIH0pO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFN0b3JlcyB0aGUgbG9jYXRpb24gaW4gdGhlIGhhc2hcbiAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxuICovXG5cbmZ1bmN0aW9uIEhhc2hSb3V0ZXIoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICB3aW5kb3dcbiAgfSA9IF9yZWYyO1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuXG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUhhc2hIaXN0b3J5KHtcbiAgICAgIHdpbmRvdyxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICB9KTtcbn1cbi8qKlxuICogQSBgPFJvdXRlcj5gIHRoYXQgYWNjZXB0cyBhIHByZS1pbnN0YW50aWF0ZWQgaGlzdG9yeSBvYmplY3QuIEl0J3MgaW1wb3J0YW50XG4gKiB0byBub3RlIHRoYXQgdXNpbmcgeW91ciBvd24gaGlzdG9yeSBvYmplY3QgaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGFuZCBtYXkgYWRkXG4gKiB0d28gdmVyc2lvbnMgb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0byB5b3VyIGJ1bmRsZXMgdW5sZXNzIHlvdSB1c2UgdGhlIHNhbWVcbiAqIHZlcnNpb24gb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0aGF0IFJlYWN0IFJvdXRlciB1c2VzIGludGVybmFsbHkuXG4gKi9cblxuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcihfcmVmMykge1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuLFxuICAgIGhpc3RvcnlcbiAgfSA9IF9yZWYzO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xufVxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5cbmNvbnN0IExpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5rV2l0aFJlZihfcmVmNCwgcmVmKSB7XG4gIGxldCB7XG4gICAgb25DbGljayxcbiAgICByZWxhdGl2ZSxcbiAgICByZWxvYWREb2N1bWVudCxcbiAgICByZXBsYWNlLFxuICAgIHN0YXRlLFxuICAgIHRhcmdldCxcbiAgICB0byxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgfSA9IF9yZWY0LFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY0LCBfZXhjbHVkZWQpO1xuXG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTsgLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgYWJzb2x1dGUgVVJMc1xuXG4gIGxldCBhYnNvbHV0ZUhyZWY7XG4gIGxldCBpc0V4dGVybmFsID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh0bykpIHtcbiAgICAvLyBSZW5kZXIgdGhlIGFic29sdXRlIGhyZWYgc2VydmVyLSBhbmQgY2xpZW50LXNpZGVcbiAgICBhYnNvbHV0ZUhyZWYgPSB0bzsgLy8gT25seSBjaGVjayBmb3IgZXh0ZXJuYWwgb3JpZ2lucyBjbGllbnQtc2lkZVxuXG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgbGV0IHRhcmdldFVybCA9IHRvLnN0YXJ0c1dpdGgoXCIvL1wiKSA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIHRvKSA6IG5ldyBVUkwodG8pO1xuICAgICAgICBsZXQgcGF0aCA9IHN0cmlwQmFzZW5hbWUodGFyZ2V0VXJsLnBhdGhuYW1lLCBiYXNlbmFtZSk7XG5cbiAgICAgICAgaWYgKHRhcmdldFVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIHBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFN0cmlwIHRoZSBwcm90b2NvbC9vcmlnaW4vYmFzZW5hbWUgZm9yIHNhbWUtb3JpZ2luIGFic29sdXRlIFVSTHNcbiAgICAgICAgICB0byA9IHBhdGggKyB0YXJnZXRVcmwuc2VhcmNoICsgdGFyZ2V0VXJsLmhhc2g7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgZG8gZXh0ZXJuYWwgVVJMIGRldGVjdGlvbiB3aXRob3V0IGEgdmFsaWQgVVJMXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIjxMaW5rIHRvPVxcXCJcIiArIHRvICsgXCJcXFwiPiBjb250YWlucyBhbiBpbnZhbGlkIFVSTCB3aGljaCB3aWxsIHByb2JhYmx5IGJyZWFrIFwiICsgXCJ3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguXCIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW5kZXJlZCBpbnRvIDxhIGhyZWY+IGZvciByZWxhdGl2ZSBVUkxzXG5cblxuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8sIHtcbiAgICByZWxhdGl2ZVxuICB9KTtcbiAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICByZXBsYWNlLFxuICAgIHN0YXRlLFxuICAgIHRhcmdldCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVsYXRpdmVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBocmVmOiBhYnNvbHV0ZUhyZWYgfHwgaHJlZixcbiAgICAgIG9uQ2xpY2s6IGlzRXh0ZXJuYWwgfHwgcmVsb2FkRG9jdW1lbnQgPyBvbkNsaWNrIDogaGFuZGxlQ2xpY2ssXG4gICAgICByZWY6IHJlZixcbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfSkpXG4gICk7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG59XG4vKipcbiAqIEEgPExpbms+IHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG5cblxuY29uc3QgTmF2TGluayA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKF9yZWY1LCByZWYpIHtcbiAgbGV0IHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICBlbmQgPSBmYWxzZSxcbiAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgIHRvLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmNSxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmNSwgX2V4Y2x1ZGVkMik7XG5cbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICByZWxhdGl2ZTogcmVzdC5yZWxhdGl2ZVxuICB9KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlclN0YXRlID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbmF2aWdhdG9yXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB0b1BhdGhuYW1lID0gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKHBhdGgpLnBhdGhuYW1lIDogcGF0aC5wYXRobmFtZTtcbiAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgbGV0IG5leHRMb2NhdGlvblBhdGhuYW1lID0gcm91dGVyU3RhdGUgJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbiAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uID8gcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbi5wYXRobmFtZSA6IG51bGw7XG5cbiAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGxldCBpc0FjdGl2ZSA9IGxvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHwgIWVuZCAmJiBsb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiYgbG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIjtcbiAgbGV0IGlzUGVuZGluZyA9IG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiYgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG4gIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdW5kZWZpbmVkO1xuICBsZXQgY2xhc3NOYW1lO1xuXG4gIGlmICh0eXBlb2YgY2xhc3NOYW1lUHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJvcCh7XG4gICAgICBpc0FjdGl2ZSxcbiAgICAgIGlzUGVuZGluZ1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSBjbGFzc05hbWUgcHJvcCBpcyBub3QgYSBmdW5jdGlvbiwgd2UgdXNlIGEgZGVmYXVsdCBgYWN0aXZlYFxuICAgIC8vIGNsYXNzIGZvciA8TmF2TGluayAvPnMgdGhhdCBhcmUgYWN0aXZlLiBJbiB2NSBgYWN0aXZlYCB3YXMgdGhlIGRlZmF1bHRcbiAgICAvLyB2YWx1ZSBmb3IgYGFjdGl2ZUNsYXNzTmFtZWAsIGJ1dCB3ZSBhcmUgcmVtb3ZpbmcgdGhhdCBBUEkgYW5kIGNhbiBzdGlsbFxuICAgIC8vIHVzZSB0aGUgb2xkIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgY2xlYW5lciB1cGdyYWRlIHBhdGggYW5kIGtlZXAgdGhlXG4gICAgLy8gc2ltcGxlIHN0eWxpbmcgcnVsZXMgd29ya2luZyBhcyB0aGV5IGN1cnJlbnRseSBkby5cbiAgICBjbGFzc05hbWUgPSBbY2xhc3NOYW1lUHJvcCwgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbCwgaXNQZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBudWxsXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gIH1cblxuICBsZXQgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3Aoe1xuICAgIGlzQWN0aXZlLFxuICAgIGlzUGVuZGluZ1xuICB9KSA6IHN0eWxlUHJvcDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpbmssIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgcmVmOiByZWYsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHRvOiB0b1xuICB9KSwgdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbih7XG4gICAgaXNBY3RpdmUsXG4gICAgaXNQZW5kaW5nXG4gIH0pIDogY2hpbGRyZW4pO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xufVxuLyoqXG4gKiBBIGBAcmVtaXgtcnVuL3JvdXRlcmAtYXdhcmUgYDxmb3JtPmAuIEl0IGJlaGF2ZXMgbGlrZSBhIG5vcm1hbCBmb3JtIGV4Y2VwdFxuICogdGhhdCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2VydmVyIGlzIHdpdGggYGZldGNoYCBpbnN0ZWFkIG9mIG5ldyBkb2N1bWVudFxuICogcmVxdWVzdHMsIGFsbG93aW5nIGNvbXBvbmVudHMgdG8gYWRkIG5pY2VyIFVYIHRvIHRoZSBwYWdlIGFzIHRoZSBmb3JtIGlzXG4gKiBzdWJtaXR0ZWQgYW5kIHJldHVybnMgd2l0aCBkYXRhLlxuICovXG5cblxuY29uc3QgRm9ybSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtSW1wbCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgcmVmOiByZWZcbiAgfSkpO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybVwiO1xufVxuXG5jb25zdCBGb3JtSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChfcmVmNiwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGxldCB7XG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZSxcbiAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kLFxuICAgIGFjdGlvbixcbiAgICBvblN1Ym1pdCxcbiAgICBmZXRjaGVyS2V5LFxuICAgIHJvdXRlSWQsXG4gICAgcmVsYXRpdmUsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0XG4gIH0gPSBfcmVmNixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjYsIF9leGNsdWRlZDMpO1xuXG4gIGxldCBzdWJtaXQgPSB1c2VTdWJtaXRJbXBsKGZldGNoZXJLZXksIHJvdXRlSWQpO1xuICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG5cbiAgbGV0IHN1Ym1pdEhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgb25TdWJtaXQgJiYgb25TdWJtaXQoZXZlbnQpO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgc3VibWl0dGVyID0gZXZlbnQubmF0aXZlRXZlbnQuc3VibWl0dGVyO1xuICAgIGxldCBzdWJtaXRNZXRob2QgPSAoc3VibWl0dGVyID09IG51bGwgPyB2b2lkIDAgOiBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSkgfHwgbWV0aG9kO1xuICAgIHN1Ym1pdChzdWJtaXR0ZXIgfHwgZXZlbnQuY3VycmVudFRhcmdldCwge1xuICAgICAgbWV0aG9kOiBzdWJtaXRNZXRob2QsXG4gICAgICByZXBsYWNlLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICBtZXRob2Q6IGZvcm1NZXRob2QsXG4gICAgYWN0aW9uOiBmb3JtQWN0aW9uLFxuICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlclxuICB9LCBwcm9wcykpO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRm9ybUltcGwuZGlzcGxheU5hbWUgPSBcIkZvcm1JbXBsXCI7XG59XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgZW11bGF0ZSB0aGUgYnJvd3NlcidzIHNjcm9sbCByZXN0b3JhdGlvbiBvbiBsb2NhdGlvblxuICogY2hhbmdlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKF9yZWY3KSB7XG4gIGxldCB7XG4gICAgZ2V0S2V5LFxuICAgIHN0b3JhZ2VLZXlcbiAgfSA9IF9yZWY3O1xuICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gICAgZ2V0S2V5LFxuICAgIHN0b3JhZ2VLZXlcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xufSAvLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSG9va3Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIERhdGFSb3V0ZXJIb29rO1xuXG4oZnVuY3Rpb24gKERhdGFSb3V0ZXJIb29rKSB7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlU2Nyb2xsUmVzdG9yYXRpb25cIl0gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlU3VibWl0SW1wbFwiXSA9IFwidXNlU3VibWl0SW1wbFwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZUZldGNoZXJcIl0gPSBcInVzZUZldGNoZXJcIjtcbn0pKERhdGFSb3V0ZXJIb29rIHx8IChEYXRhUm91dGVySG9vayA9IHt9KSk7XG5cbnZhciBEYXRhUm91dGVyU3RhdGVIb29rO1xuXG4oZnVuY3Rpb24gKERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUZldGNoZXJzXCJdID0gXCJ1c2VGZXRjaGVyc1wiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlU2Nyb2xsUmVzdG9yYXRpb25cIl0gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCI7XG59KShEYXRhUm91dGVyU3RhdGVIb29rIHx8IChEYXRhUm91dGVyU3RhdGVIb29rID0ge30pKTtcblxuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xuICByZXR1cm4gaG9va05hbWUgKyBcIiBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVycy9waWNraW5nLWEtcm91dGVyLlwiO1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQpO1xuICAhY3R4ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBjdHg7XG59XG5cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgIXN0YXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBzdGF0ZTtcbn1cbi8qKlxuICogSGFuZGxlcyB0aGUgY2xpY2sgYmVoYXZpb3IgZm9yIHJvdXRlciBgPExpbms+YCBjb21wb25lbnRzLiBUaGlzIGlzIHVzZWZ1bCBpZlxuICogeW91IG5lZWQgdG8gY3JlYXRlIGN1c3RvbSBgPExpbms+YCBjb21wb25lbnRzIHdpdGggdGhlIHNhbWUgY2xpY2sgYmVoYXZpb3Igd2VcbiAqIHVzZSBpbiBvdXIgZXhwb3J0ZWQgYDxMaW5rPmAuXG4gKi9cblxuXG5mdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHRhcmdldCxcbiAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgICBzdGF0ZSxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVsYXRpdmVcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlXG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBJZiB0aGUgVVJMIGhhc24ndCBjaGFuZ2VkLCBhIHJlZ3VsYXIgPGE+IHdpbGwgZG8gYSByZXBsYWNlIGluc3RlYWQgb2ZcbiAgICAgIC8vIGEgcHVzaCwgc28gZG8gdGhlIHNhbWUgaGVyZSB1bmxlc3MgdGhlIHJlcGxhY2UgcHJvcCBpcyBleHBsaWNpdGx5IHNldFxuXG4gICAgICBsZXQgcmVwbGFjZSA9IHJlcGxhY2VQcm9wICE9PSB1bmRlZmluZWQgPyByZXBsYWNlUHJvcCA6IGNyZWF0ZVBhdGgobG9jYXRpb24pID09PSBjcmVhdGVQYXRoKHBhdGgpO1xuICAgICAgbmF2aWdhdGUodG8sIHtcbiAgICAgICAgcmVwbGFjZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgcmVsYXRpdmVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2xvY2F0aW9uLCBuYXZpZ2F0ZSwgcGF0aCwgcmVwbGFjZVByb3AsIHN0YXRlLCB0YXJnZXQsIHRvLCBwcmV2ZW50U2Nyb2xsUmVzZXQsIHJlbGF0aXZlXSk7XG59XG4vKipcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gKi9cblxuZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09IFwidW5kZWZpbmVkXCIsIFwiWW91IGNhbm5vdCB1c2UgdGhlIGB1c2VTZWFyY2hQYXJhbXNgIGhvb2sgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3QgXCIgKyBcInN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgXCIgKyBcIkV4cGxvcmVyIDExLCB3ZSByZWNvbW1lbmQgeW91IGxvYWQgYSBwb2x5ZmlsbCBzdWNoIGFzIFwiICsgXCJodHRwczovL2dpdGh1Yi5jb20vdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXNcXG5cXG5cIiArIFwiSWYgeW91J3JlIHVuc3VyZSBob3cgdG8gbG9hZCBwb2x5ZmlsbHMsIHdlIHJlY29tbWVuZCB5b3UgY2hlY2sgb3V0IFwiICsgXCJodHRwczovL3BvbHlmaWxsLmlvL3YzLyB3aGljaCBwcm92aWRlcyBzb21lIHJlY29tbWVuZGF0aW9ucyBhYm91dCBob3cgXCIgKyBcInRvIGxvYWQgcG9seWZpbGxzIG9ubHkgZm9yIHVzZXJzIHRoYXQgbmVlZCB0aGVtLCBpbnN0ZWFkIG9mIGZvciBldmVyeSBcIiArIFwidXNlci5cIikgOiB2b2lkIDA7XG4gIGxldCBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuICBsZXQgaGFzU2V0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gLy8gT25seSBtZXJnZSBpbiB0aGUgZGVmYXVsdHMgaWYgd2UgaGF2ZW4ndCB5ZXQgY2FsbGVkIHNldFNlYXJjaFBhcmFtcy5cbiAgLy8gT25jZSB3ZSBjYWxsIHRoYXQgd2Ugd2FudCB0aG9zZSB0byB0YWtlIHByZWNlZGVuY2UsIG90aGVyd2lzZSB5b3UgY2FuJ3RcbiAgLy8gcmVtb3ZlIGEgcGFyYW0gd2l0aCBzZXRTZWFyY2hQYXJhbXMoe30pIGlmIGl0IGhhcyBhbiBpbml0aWFsIHZhbHVlXG4gIGdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uKGxvY2F0aW9uLnNlYXJjaCwgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPyBudWxsIDogZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50KSwgW2xvY2F0aW9uLnNlYXJjaF0pO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QudXNlQ2FsbGJhY2soKG5leHRJbml0LCBuYXZpZ2F0ZU9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBuZXdTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXModHlwZW9mIG5leHRJbml0ID09PSBcImZ1bmN0aW9uXCIgPyBuZXh0SW5pdChzZWFyY2hQYXJhbXMpIDogbmV4dEluaXQpO1xuICAgIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBuYXZpZ2F0ZShcIj9cIiArIG5ld1NlYXJjaFBhcmFtcywgbmF2aWdhdGVPcHRpb25zKTtcbiAgfSwgW25hdmlnYXRlLCBzZWFyY2hQYXJhbXNdKTtcbiAgcmV0dXJuIFtzZWFyY2hQYXJhbXMsIHNldFNlYXJjaFBhcmFtc107XG59XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgc3VibWl0IGEgZm9ybSAob3JcbiAqIHNvbWUgYXJiaXRyYXJ5IGRhdGEpIHRvIHRoZSBzZXJ2ZXIuXG4gKi9cblxuZnVuY3Rpb24gdXNlU3VibWl0KCkge1xuICByZXR1cm4gdXNlU3VibWl0SW1wbCgpO1xufVxuXG5mdW5jdGlvbiB1c2VTdWJtaXRJbXBsKGZldGNoZXJLZXksIGZldGNoZXJSb3V0ZUlkKSB7XG4gIGxldCB7XG4gICAgcm91dGVyXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTdWJtaXRJbXBsKTtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgY3VycmVudFJvdXRlSWQgPSBVTlNBRkVfdXNlUm91dGVJZCgpO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIGNhbGxpbmcgc3VibWl0IGR1cmluZyB0aGUgc2VydmVyIHJlbmRlci4gXCIgKyBcIlRyeSBjYWxsaW5nIHN1Ym1pdCB3aXRoaW4gYSBgdXNlRWZmZWN0YCBvciBjYWxsYmFjayBpbnN0ZWFkLlwiKTtcbiAgICB9XG5cbiAgICBsZXQge1xuICAgICAgYWN0aW9uLFxuICAgICAgbWV0aG9kLFxuICAgICAgZW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhXG4gICAgfSA9IGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIG9wdGlvbnMsIGJhc2VuYW1lKTsgLy8gQmFzZSBvcHRpb25zIHNoYXJlZCBiZXR3ZWVuIGZldGNoKCkgYW5kIG5hdmlnYXRlKClcblxuICAgIGxldCBvcHRzID0ge1xuICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgZm9ybU1ldGhvZDogbWV0aG9kLFxuICAgICAgZm9ybUVuY1R5cGU6IGVuY1R5cGVcbiAgICB9O1xuXG4gICAgaWYgKGZldGNoZXJLZXkpIHtcbiAgICAgICEoZmV0Y2hlclJvdXRlSWQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciB1c2VGZXRjaGVyKClcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHJvdXRlci5mZXRjaChmZXRjaGVyS2V5LCBmZXRjaGVyUm91dGVJZCwgYWN0aW9uLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGVyLm5hdmlnYXRlKGFjdGlvbiwgX2V4dGVuZHMoe30sIG9wdHMsIHtcbiAgICAgICAgcmVwbGFjZTogb3B0aW9ucy5yZXBsYWNlLFxuICAgICAgICBmcm9tUm91dGVJZDogY3VycmVudFJvdXRlSWRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBmZXRjaGVyS2V5LCBmZXRjaGVyUm91dGVJZCwgY3VycmVudFJvdXRlSWRdKTtcbn0gLy8gdjc6IEV2ZW50dWFsbHkgd2Ugc2hvdWxkIGRlcHJlY2F0ZSB0aGlzIGVudGlyZWx5IGluIGZhdm9yIG9mIHVzaW5nIHRoZVxuLy8gcm91dGVyIG1ldGhvZCBkaXJlY3RseT9cblxuXG5mdW5jdGlvbiB1c2VGb3JtQWN0aW9uKGFjdGlvbiwgX3RlbXAyKSB7XG4gIGxldCB7XG4gICAgcmVsYXRpdmVcbiAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHJvdXRlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX1JvdXRlQ29udGV4dCk7XG4gICFyb3V0ZUNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZvcm1BY3Rpb24gbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQgW21hdGNoXSA9IHJvdXRlQ29udGV4dC5tYXRjaGVzLnNsaWNlKC0xKTsgLy8gU2hhbGxvdyBjbG9uZSBwYXRoIHNvIHdlIGNhbiBtb2RpZnkgaXQgYmVsb3csIG90aGVyd2lzZSB3ZSBtb2RpZnkgdGhlXG4gIC8vIG9iamVjdCByZWZlcmVuY2VkIGJ5IHVzZU1lbW8gaW5zaWRlIHVzZVJlc29sdmVkUGF0aFxuXG4gIGxldCBwYXRoID0gX2V4dGVuZHMoe30sIHVzZVJlc29sdmVkUGF0aChhY3Rpb24gPyBhY3Rpb24gOiBcIi5cIiwge1xuICAgIHJlbGF0aXZlXG4gIH0pKTsgLy8gUHJldmlvdXNseSB3ZSBzZXQgdGhlIGRlZmF1bHQgYWN0aW9uIHRvIFwiLlwiLiBUaGUgcHJvYmxlbSB3aXRoIHRoaXMgaXMgdGhhdFxuICAvLyBgdXNlUmVzb2x2ZWRQYXRoKFwiLlwiKWAgZXhjbHVkZXMgc2VhcmNoIHBhcmFtcyBhbmQgdGhlIGhhc2ggb2YgdGhlIHJlc29sdmVkXG4gIC8vIFVSTC4gVGhpcyBpcyB0aGUgaW50ZW5kZWQgYmVoYXZpb3Igb2Ygd2hlbiBcIi5cIiBpcyBzcGVjaWZpY2FsbHkgcHJvdmlkZWQgYXNcbiAgLy8gdGhlIGZvcm0gYWN0aW9uLCBidXQgaW5jb25zaXN0ZW50IHcvIGJyb3dzZXJzIHdoZW4gdGhlIGFjdGlvbiBpcyBvbWl0dGVkLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlbWl4L2lzc3Vlcy85MjdcblxuXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XG4gICAgLy8gU2FmZSB0byB3cml0ZSB0byB0aGVzZSBkaXJlY3RseSBoZXJlIHNpbmNlIGlmIGFjdGlvbiB3YXMgdW5kZWZpbmVkLCB3ZVxuICAgIC8vIHdvdWxkIGhhdmUgY2FsbGVkIHVzZVJlc29sdmVkUGF0aChcIi5cIikgd2hpY2ggd2lsbCBuZXZlciBpbmNsdWRlIGEgc2VhcmNoXG4gICAgLy8gb3IgaGFzaFxuICAgIHBhdGguc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHBhdGguaGFzaCA9IGxvY2F0aW9uLmhhc2g7IC8vIFdoZW4gZ3JhYmJpbmcgc2VhcmNoIHBhcmFtcyBmcm9tIHRoZSBVUkwsIHJlbW92ZSB0aGUgYXV0b21hdGljYWxseVxuICAgIC8vIGluc2VydGVkID9pbmRleCBwYXJhbSBzbyB3ZSBtYXRjaCB0aGUgdXNlUmVzb2x2ZWRQYXRoIHNlYXJjaCBiZWhhdmlvclxuICAgIC8vIHdoaWNoIHdvdWxkIG5vdCBpbmNsdWRlID9pbmRleFxuXG4gICAgaWYgKG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBwYXRoLnNlYXJjaCA9IHBhcmFtcy50b1N0cmluZygpID8gXCI/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKCghYWN0aW9uIHx8IGFjdGlvbiA9PT0gXCIuXCIpICYmIG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaCA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xuICB9IC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgLy8gdG8gY3JlYXRpbmcgdGhlIGZvcm0gYWN0aW9uLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZVxuICAvLyB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGVcbiAgLy8gcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGFjdGlvbnNcblxuXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaGVyRm9ybShmZXRjaGVyS2V5LCByb3V0ZUlkKSB7XG4gIGxldCBGZXRjaGVyRm9ybSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1JbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZmV0Y2hlcktleTogZmV0Y2hlcktleSxcbiAgICAgIHJvdXRlSWQ6IHJvdXRlSWRcbiAgICB9KSk7XG4gIH0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBGZXRjaGVyRm9ybS5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gIH1cblxuICByZXR1cm4gRmV0Y2hlckZvcm07XG59XG5cbmxldCBmZXRjaGVySWQgPSAwO1xuLyoqXG4gKiBJbnRlcmFjdHMgd2l0aCByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHdpdGhvdXQgY2F1c2luZyBhIG5hdmlnYXRpb24uIEdyZWF0XG4gKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cbiAqL1xuXG5mdW5jdGlvbiB1c2VGZXRjaGVyKCkge1xuICB2YXIgX3JvdXRlJG1hdGNoZXM7XG5cbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUZldGNoZXIpO1xuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9Sb3V0ZUNvbnRleHQpO1xuICAhcm91dGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQgcm91dGVJZCA9IChfcm91dGUkbWF0Y2hlcyA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZSRtYXRjaGVzLnJvdXRlLmlkO1xuICAhKHJvdXRlSWQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFxcXCJpZFxcXCJcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IFtmZXRjaGVyS2V5XSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IFN0cmluZygrK2ZldGNoZXJJZCkpO1xuICBsZXQgW0Zvcm1dID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgICFyb3V0ZUlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5Gb3JtKClcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gY3JlYXRlRmV0Y2hlckZvcm0oZmV0Y2hlcktleSwgcm91dGVJZCk7XG4gIH0pO1xuICBsZXQgW2xvYWRdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gaHJlZiA9PiB7XG4gICAgIXJvdXRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiTm8gcm91dGVyIGF2YWlsYWJsZSBmb3IgZmV0Y2hlci5sb2FkKClcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhcm91dGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcm91dGVyLmZldGNoKGZldGNoZXJLZXksIHJvdXRlSWQsIGhyZWYpO1xuICB9KTtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEltcGwoZmV0Y2hlcktleSwgcm91dGVJZCk7XG4gIGxldCBmZXRjaGVyID0gcm91dGVyLmdldEZldGNoZXIoZmV0Y2hlcktleSk7XG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IF9leHRlbmRzKHtcbiAgICBGb3JtLFxuICAgIHN1Ym1pdCxcbiAgICBsb2FkXG4gIH0sIGZldGNoZXIpLCBbZmV0Y2hlciwgRm9ybSwgc3VibWl0LCBsb2FkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSXMgdGhpcyBidXN0ZWQgd2hlbiB0aGUgUmVhY3QgdGVhbSBnZXRzIHJlYWwgd2VpcmQgYW5kIGNhbGxzIGVmZmVjdHNcbiAgICAvLyB0d2ljZSBvbiBtb3VudD8gIFdlIHJlYWxseSBqdXN0IG5lZWQgdG8gZ2FyYmFnZSBjb2xsZWN0IGhlcmUgd2hlbiB0aGlzXG4gICAgLy8gZmV0Y2hlciBpcyBubyBsb25nZXIgYXJvdW5kLlxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJObyByb3V0ZXIgYXZhaWxhYmxlIHRvIGNsZWFuIHVwIGZyb20gdXNlRmV0Y2hlcigpXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJvdXRlci5kZWxldGVGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIH07XG4gIH0sIFtyb3V0ZXIsIGZldGNoZXJLZXldKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGZldGNoZXJzIGN1cnJlbnRseSBvbiB0aGUgcGFnZS4gVXNlZnVsIGZvciBsYXlvdXRzIGFuZCBwYXJlbnRcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlRmV0Y2hlcnMpO1xuICByZXR1cm4gWy4uLnN0YXRlLmZldGNoZXJzLnZhbHVlcygpXTtcbn1cbmNvbnN0IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLXNjcm9sbC1wb3NpdGlvbnNcIjtcbmxldCBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IHt9O1xuLyoqXG4gKiBXaGVuIHJlbmRlcmVkIGluc2lkZSBhIFJvdXRlclByb3ZpZGVyLCB3aWxsIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9ucyBvbiBuYXZpZ2F0aW9uc1xuICovXG5cbmZ1bmN0aW9uIHVzZVNjcm9sbFJlc3RvcmF0aW9uKF90ZW1wMykge1xuICBsZXQge1xuICAgIGdldEtleSxcbiAgICBzdG9yYWdlS2V5XG4gIH0gPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzO1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xuICBsZXQge1xuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbixcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpOyAvLyBUcmlnZ2VyIG1hbnVhbCBzY3JvbGwgcmVzdG9yYXRpb24gd2hpbGUgd2UncmUgYWN0aXZlXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfTtcbiAgfSwgW10pOyAvLyBTYXZlIHBvc2l0aW9ucyBvbiBwYWdlaGlkZVxuXG4gIHVzZVBhZ2VIaWRlKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAobmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIGxldCBrZXkgPSAoZ2V0S2V5ID8gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKSA6IG51bGwpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG5cbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzYXZlZFNjcm9sbFBvc2l0aW9ucykpO1xuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gIH0sIFtzdG9yYWdlS2V5LCBnZXRLZXksIG5hdmlnYXRpb24uc3RhdGUsIGxvY2F0aW9uLCBtYXRjaGVzXSkpOyAvLyBSZWFkIGluIGFueSBzYXZlZCBzY3JvbGwgbG9jYXRpb25zXG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkpO1xuXG4gICAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7Ly8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxuICAgICAgfVxuICAgIH0sIFtzdG9yYWdlS2V5XSk7IC8vIEVuYWJsZSBzY3JvbGwgcmVzdG9yYXRpb24gaW4gdGhlIHJvdXRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gPSByb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJvdXRlci5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihzYXZlZFNjcm9sbFBvc2l0aW9ucywgKCkgPT4gd2luZG93LnNjcm9sbFksIGdldEtleSk7XG4gICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgIH0sIFtyb3V0ZXIsIGdldEtleV0pOyAvLyBSZXN0b3JlIHNjcm9sbGluZyB3aGVuIHN0YXRlLnJlc3RvcmVTY3JvbGxQb3NpdGlvbiBjaGFuZ2VzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG5cbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gRXhwbGljaXQgZmFsc2UgbWVhbnMgZG9uJ3QgZG8gYW55dGhpbmcgKHVzZWQgZm9yIHN1Ym1pc3Npb25zKVxuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcblxuXG4gICAgICBpZiAodHlwZW9mIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyB0cnkgdG8gc2Nyb2xsIHRvIHRoZSBoYXNoXG5cblxuICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobG9jYXRpb24uaGFzaC5zbGljZSgxKSk7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgZWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRG9uJ3QgcmVzZXQgaWYgdGhpcyBuYXZpZ2F0aW9uIG9wdGVkIG91dFxuXG5cbiAgICAgIGlmIChwcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBvdGhlcndpc2UgZ28gdG8gdGhlIHRvcCBvbiBuZXcgbG9jYXRpb25zXG5cblxuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbiwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXRdKTtcbiAgfVxufVxuLyoqXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQge1xuICAgIGNhcHR1cmVcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7XG4gICAgICBjYXB0dXJlXG4gICAgfSA6IHVuZGVmaW5lZDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYHBhZ2VoaWRlYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLiAgVGhpcyBldmVudCBpcyBiZXR0ZXIgc3VwcG9ydGVkIHRoYW4gYmVmb3JldW5sb2FkIGFjcm9zcyBicm93c2Vycy5cbiAqXG4gKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VQYWdlSGlkZShjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQge1xuICAgIGNhcHR1cmVcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7XG4gICAgICBjYXB0dXJlXG4gICAgfSA6IHVuZGVmaW5lZDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIHVzZUJsb2NrZXIgdG8gc2hvdyBhIHdpbmRvdy5jb25maXJtIHByb21wdCB0byB1c2VycyBpbnN0ZWFkXG4gKiBvZiBidWlsZGluZyBhIGN1c3RvbSBVSSB3aXRoIHVzZUJsb2NrZXIuXG4gKlxuICogV2FybmluZzogVGhpcyBoYXMgKmEgbG90IG9mIHJvdWdoIGVkZ2VzKiBhbmQgYmVoYXZlcyB2ZXJ5IGRpZmZlcmVudGx5IChhbmRcbiAqIHZlcnkgaW5jb3JyZWN0bHkgaW4gc29tZSBjYXNlcykgYWNyb3NzIGJyb3dzZXJzIGlmIHVzZXIgY2xpY2sgYWRkaXRpb25cbiAqIGJhY2svZm9yd2FyZCBuYXZpZ2F0aW9ucyB3aGlsZSB0aGUgY29uZmlybSBpcyBvcGVuLiAgVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gKi9cblxuXG5mdW5jdGlvbiB1c2VQcm9tcHQoX3JlZjgpIHtcbiAgbGV0IHtcbiAgICB3aGVuLFxuICAgIG1lc3NhZ2VcbiAgfSA9IF9yZWY4O1xuICBsZXQgYmxvY2tlciA9IHVuc3RhYmxlX3VzZUJsb2NrZXIod2hlbik7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmICF3aGVuKSB7XG4gICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgfVxuICB9LCBbYmxvY2tlciwgd2hlbl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIikge1xuICAgICAgbGV0IHByb2NlZWQgPSB3aW5kb3cuY29uZmlybShtZXNzYWdlKTtcblxuICAgICAgaWYgKHByb2NlZWQpIHtcbiAgICAgICAgc2V0VGltZW91dChibG9ja2VyLnByb2NlZWQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcbn1cbiAvLyNlbmRyZWdpb25cblxuZXhwb3J0IHsgQnJvd3NlclJvdXRlciwgRm9ybSwgSGFzaFJvdXRlciwgTGluaywgTmF2TGluaywgU2Nyb2xsUmVzdG9yYXRpb24sIHVzZVNjcm9sbFJlc3RvcmF0aW9uIGFzIFVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbiwgY3JlYXRlQnJvd3NlclJvdXRlciwgY3JlYXRlSGFzaFJvdXRlciwgY3JlYXRlU2VhcmNoUGFyYW1zLCBIaXN0b3J5Um91dGVyIGFzIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIsIHVzZVByb21wdCBhcyB1bnN0YWJsZV91c2VQcm9tcHQsIHVzZUJlZm9yZVVubG9hZCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUxpbmtDbGlja0hhbmRsZXIsIHVzZVNlYXJjaFBhcmFtcywgdXNlU3VibWl0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMiLCJSb3V0ZXIiLCJVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQiLCJ1c2VIcmVmIiwidXNlUmVzb2x2ZWRQYXRoIiwidXNlTG9jYXRpb24iLCJVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsInVzZU5hdmlnYXRlIiwiY3JlYXRlUGF0aCIsIlVOU0FGRV91c2VSb3V0ZUlkIiwiVU5TQUZFX1JvdXRlQ29udGV4dCIsInVzZU1hdGNoZXMiLCJ1c2VOYXZpZ2F0aW9uIiwidW5zdGFibGVfdXNlQmxvY2tlciIsIlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiQXdhaXQiLCJNZW1vcnlSb3V0ZXIiLCJOYXZpZ2F0ZSIsIk5hdmlnYXRpb25UeXBlIiwiT3V0bGV0IiwiUm91dGUiLCJSb3V0ZXJQcm92aWRlciIsIlJvdXRlcyIsIlVOU0FGRV9Mb2NhdGlvbkNvbnRleHQiLCJjcmVhdGVNZW1vcnlSb3V0ZXIiLCJjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4iLCJjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMiLCJkZWZlciIsImdlbmVyYXRlUGF0aCIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwianNvbiIsIm1hdGNoUGF0aCIsIm1hdGNoUm91dGVzIiwicGFyc2VQYXRoIiwicmVkaXJlY3QiLCJyZW5kZXJNYXRjaGVzIiwicmVzb2x2ZVBhdGgiLCJ1c2VBY3Rpb25EYXRhIiwidXNlQXN5bmNFcnJvciIsInVzZUFzeW5jVmFsdWUiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJ1c2VMb2FkZXJEYXRhIiwidXNlTWF0Y2giLCJ1c2VOYXZpZ2F0aW9uVHlwZSIsInVzZU91dGxldCIsInVzZU91dGxldENvbnRleHQiLCJ1c2VQYXJhbXMiLCJ1c2VSZXZhbGlkYXRvciIsInVzZVJvdXRlRXJyb3IiLCJ1c2VSb3V0ZUxvYWRlckRhdGEiLCJ1c2VSb3V0ZXMiLCJzdHJpcEJhc2VuYW1lIiwiY3JlYXRlUm91dGVyIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsIkVycm9yUmVzcG9uc2UiLCJVTlNBRkVfd2FybmluZyIsIlVOU0FGRV9pbnZhcmlhbnQiLCJqb2luUGF0aHMiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImtleXMiLCJpbmRleE9mIiwiZGVmYXVsdE1ldGhvZCIsImRlZmF1bHRFbmNUeXBlIiwiaXNIdG1sRWxlbWVudCIsIm9iamVjdCIsInRhZ05hbWUiLCJpc0J1dHRvbkVsZW1lbnQiLCJ0b0xvd2VyQ2FzZSIsImlzRm9ybUVsZW1lbnQiLCJpc0lucHV0RWxlbWVudCIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsInNob3VsZFByb2Nlc3NMaW5rQ2xpY2siLCJidXR0b24iLCJjcmVhdGVTZWFyY2hQYXJhbXMiLCJpbml0IiwiVVJMU2VhcmNoUGFyYW1zIiwiQXJyYXkiLCJpc0FycmF5IiwicmVkdWNlIiwibWVtbyIsInZhbHVlIiwiY29uY2F0IiwibWFwIiwidiIsImdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uIiwibG9jYXRpb25TZWFyY2giLCJkZWZhdWx0U2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zIiwiaGFzIiwiZ2V0QWxsIiwiZm9yRWFjaCIsImFwcGVuZCIsImdldEZvcm1TdWJtaXNzaW9uSW5mbyIsIm9wdGlvbnMiLCJiYXNlbmFtZSIsIm1ldGhvZCIsImFjdGlvbiIsImVuY1R5cGUiLCJmb3JtRGF0YSIsInN1Ym1pc3Npb25UcmlnZ2VyIiwiYXR0ciIsImdldEF0dHJpYnV0ZSIsIkZvcm1EYXRhIiwibmFtZSIsInR5cGUiLCJmb3JtIiwiRXJyb3IiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwiX2V4Y2x1ZGVkMyIsImNyZWF0ZUJyb3dzZXJSb3V0ZXIiLCJyb3V0ZXMiLCJvcHRzIiwiZnV0dXJlIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwiaGlzdG9yeSIsIndpbmRvdyIsImh5ZHJhdGlvbkRhdGEiLCJwYXJzZUh5ZHJhdGlvbkRhdGEiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJpbml0aWFsaXplIiwiY3JlYXRlSGFzaFJvdXRlciIsIl93aW5kb3ciLCJzdGF0ZSIsIl9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSIsImVycm9ycyIsImRlc2VyaWFsaXplRXJyb3JzIiwiZW50cmllcyIsInNlcmlhbGl6ZWQiLCJ2YWwiLCJfX3R5cGUiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImludGVybmFsIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJCcm93c2VyUm91dGVyIiwiX3JlZiIsImNoaWxkcmVuIiwiaGlzdG9yeVJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJ2NUNvbXBhdCIsInNldFN0YXRlIiwidXNlU3RhdGUiLCJsb2NhdGlvbiIsInVzZUxheW91dEVmZmVjdCIsImxpc3RlbiIsImNyZWF0ZUVsZW1lbnQiLCJuYXZpZ2F0aW9uVHlwZSIsIm5hdmlnYXRvciIsIkhhc2hSb3V0ZXIiLCJfcmVmMiIsIkhpc3RvcnlSb3V0ZXIiLCJfcmVmMyIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSIsImlzQnJvd3NlciIsImRvY3VtZW50IiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiTGluayIsImZvcndhcmRSZWYiLCJMaW5rV2l0aFJlZiIsIl9yZWY0IiwicmVmIiwib25DbGljayIsInJlbGF0aXZlIiwicmVsb2FkRG9jdW1lbnQiLCJyZXBsYWNlIiwidG8iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXN0IiwidXNlQ29udGV4dCIsImFic29sdXRlSHJlZiIsImlzRXh0ZXJuYWwiLCJ0ZXN0IiwiY3VycmVudFVybCIsIlVSTCIsImhyZWYiLCJ0YXJnZXRVcmwiLCJzdGFydHNXaXRoIiwicHJvdG9jb2wiLCJwYXRoIiwicGF0aG5hbWUiLCJvcmlnaW4iLCJzZWFyY2giLCJoYXNoIiwiZSIsImludGVybmFsT25DbGljayIsInVzZUxpbmtDbGlja0hhbmRsZXIiLCJoYW5kbGVDbGljayIsImRlZmF1bHRQcmV2ZW50ZWQiLCJOYXZMaW5rIiwiTmF2TGlua1dpdGhSZWYiLCJfcmVmNSIsImFyaWFDdXJyZW50UHJvcCIsImNhc2VTZW5zaXRpdmUiLCJjbGFzc05hbWUiLCJjbGFzc05hbWVQcm9wIiwiZW5kIiwic3R5bGUiLCJzdHlsZVByb3AiLCJyb3V0ZXJTdGF0ZSIsInRvUGF0aG5hbWUiLCJlbmNvZGVMb2NhdGlvbiIsImxvY2F0aW9uUGF0aG5hbWUiLCJuZXh0TG9jYXRpb25QYXRobmFtZSIsIm5hdmlnYXRpb24iLCJpc0FjdGl2ZSIsImNoYXJBdCIsImlzUGVuZGluZyIsImFyaWFDdXJyZW50IiwidW5kZWZpbmVkIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJGb3JtIiwicHJvcHMiLCJGb3JtSW1wbCIsIl9yZWY2IiwiZm9yd2FyZGVkUmVmIiwib25TdWJtaXQiLCJmZXRjaGVyS2V5Iiwicm91dGVJZCIsInN1Ym1pdCIsInVzZVN1Ym1pdEltcGwiLCJmb3JtTWV0aG9kIiwiZm9ybUFjdGlvbiIsInVzZUZvcm1BY3Rpb24iLCJzdWJtaXRIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJzdWJtaXR0ZXIiLCJuYXRpdmVFdmVudCIsInN1Ym1pdE1ldGhvZCIsImN1cnJlbnRUYXJnZXQiLCJTY3JvbGxSZXN0b3JhdGlvbiIsIl9yZWY3IiwiZ2V0S2V5Iiwic3RvcmFnZUtleSIsInVzZVNjcm9sbFJlc3RvcmF0aW9uIiwiRGF0YVJvdXRlckhvb2siLCJEYXRhUm91dGVyU3RhdGVIb29rIiwiZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvciIsImhvb2tOYW1lIiwidXNlRGF0YVJvdXRlckNvbnRleHQiLCJjdHgiLCJ1c2VEYXRhUm91dGVyU3RhdGUiLCJfdGVtcCIsInJlcGxhY2VQcm9wIiwibmF2aWdhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVNlYXJjaFBhcmFtcyIsImRlZmF1bHRJbml0IiwiZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiIsImhhc1NldFNlYXJjaFBhcmFtc1JlZiIsInVzZU1lbW8iLCJzZXRTZWFyY2hQYXJhbXMiLCJuZXh0SW5pdCIsIm5hdmlnYXRlT3B0aW9ucyIsIm5ld1NlYXJjaFBhcmFtcyIsInVzZVN1Ym1pdCIsImZldGNoZXJSb3V0ZUlkIiwicm91dGVyIiwiVXNlU3VibWl0SW1wbCIsImN1cnJlbnRSb3V0ZUlkIiwiZm9ybUVuY1R5cGUiLCJmZXRjaCIsImZyb21Sb3V0ZUlkIiwiX3RlbXAyIiwicm91dGVDb250ZXh0IiwibWF0Y2giLCJtYXRjaGVzIiwic2xpY2UiLCJyb3V0ZSIsImluZGV4IiwicGFyYW1zIiwiZGVsZXRlIiwidG9TdHJpbmciLCJjcmVhdGVGZXRjaGVyRm9ybSIsIkZldGNoZXJGb3JtIiwiZmV0Y2hlcklkIiwidXNlRmV0Y2hlciIsIl9yb3V0ZSRtYXRjaGVzIiwiVXNlRmV0Y2hlciIsImlkIiwiU3RyaW5nIiwibG9hZCIsImZldGNoZXIiLCJnZXRGZXRjaGVyIiwiZmV0Y2hlcldpdGhDb21wb25lbnRzIiwidXNlRWZmZWN0IiwiY29uc29sZSIsIndhcm4iLCJkZWxldGVGZXRjaGVyIiwidXNlRmV0Y2hlcnMiLCJVc2VGZXRjaGVycyIsImZldGNoZXJzIiwidmFsdWVzIiwiU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZIiwic2F2ZWRTY3JvbGxQb3NpdGlvbnMiLCJfdGVtcDMiLCJVc2VTY3JvbGxSZXN0b3JhdGlvbiIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsInNjcm9sbFJlc3RvcmF0aW9uIiwidXNlUGFnZUhpZGUiLCJzY3JvbGxZIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlc3Npb25Qb3NpdGlvbnMiLCJnZXRJdGVtIiwicGFyc2UiLCJkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInNjcm9sbFRvIiwiZWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwidXNlQmVmb3JlVW5sb2FkIiwiY2FsbGJhY2siLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VQcm9tcHQiLCJfcmVmOCIsIndoZW4iLCJibG9ja2VyIiwicmVzZXQiLCJwcm9jZWVkIiwiY29uZmlybSIsInNldFRpbWVvdXQiLCJVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyIiwidW5zdGFibGVfdXNlUHJvbXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/react-router-dom/dist/index.js\n");

/***/ })

};
;