"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/animejs";
exports.ids = ["vendor-chunks/animejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/animejs/lib/anime.es.js":
/*!**********************************************!*\
  !*** ./node_modules/animejs/lib/anime.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n * anime.js v3.2.2\n * (c) 2023 Julian Garnier\n * Released under the MIT license\n * animejs.com\n */ // Defaults\nvar defaultInstanceSettings = {\n    update: null,\n    begin: null,\n    loopBegin: null,\n    changeBegin: null,\n    change: null,\n    changeComplete: null,\n    loopComplete: null,\n    complete: null,\n    loop: 1,\n    direction: \"normal\",\n    autoplay: true,\n    timelineOffset: 0\n};\nvar defaultTweenSettings = {\n    duration: 1000,\n    delay: 0,\n    endDelay: 0,\n    easing: \"easeOutElastic(1, .5)\",\n    round: 0\n};\nvar validTransforms = [\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"scaleZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n    \"perspective\",\n    \"matrix\",\n    \"matrix3d\"\n];\n// Caching\nvar cache = {\n    CSS: {},\n    springs: {}\n};\n// Utils\nfunction minMax(val, min, max) {\n    return Math.min(Math.max(val, min), max);\n}\nfunction stringContains(str, text) {\n    return str.indexOf(text) > -1;\n}\nfunction applyArguments(func, args) {\n    return func.apply(null, args);\n}\nvar is = {\n    arr: function(a) {\n        return Array.isArray(a);\n    },\n    obj: function(a) {\n        return stringContains(Object.prototype.toString.call(a), \"Object\");\n    },\n    pth: function(a) {\n        return is.obj(a) && a.hasOwnProperty(\"totalLength\");\n    },\n    svg: function(a) {\n        return a instanceof SVGElement;\n    },\n    inp: function(a) {\n        return a instanceof HTMLInputElement;\n    },\n    dom: function(a) {\n        return a.nodeType || is.svg(a);\n    },\n    str: function(a) {\n        return typeof a === \"string\";\n    },\n    fnc: function(a) {\n        return typeof a === \"function\";\n    },\n    und: function(a) {\n        return typeof a === \"undefined\";\n    },\n    nil: function(a) {\n        return is.und(a) || a === null;\n    },\n    hex: function(a) {\n        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);\n    },\n    rgb: function(a) {\n        return /^rgb/.test(a);\n    },\n    hsl: function(a) {\n        return /^hsl/.test(a);\n    },\n    col: function(a) {\n        return is.hex(a) || is.rgb(a) || is.hsl(a);\n    },\n    key: function(a) {\n        return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== \"targets\" && a !== \"keyframes\";\n    }\n};\n// Easings\nfunction parseEasingParameters(string) {\n    var match = /\\(([^)]+)\\)/.exec(string);\n    return match ? match[1].split(\",\").map(function(p) {\n        return parseFloat(p);\n    }) : [];\n}\n// Spring solver inspired by Webkit Copyright Â© 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js\nfunction spring(string, duration) {\n    var params = parseEasingParameters(string);\n    var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);\n    var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);\n    var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);\n    var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);\n    var w0 = Math.sqrt(stiffness / mass);\n    var zeta = damping / (2 * Math.sqrt(stiffness * mass));\n    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;\n    var a = 1;\n    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;\n    function solver(t) {\n        var progress = duration ? duration * t / 1000 : t;\n        if (zeta < 1) {\n            progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));\n        } else {\n            progress = (a + b * progress) * Math.exp(-progress * w0);\n        }\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        return 1 - progress;\n    }\n    function getDuration() {\n        var cached = cache.springs[string];\n        if (cached) {\n            return cached;\n        }\n        var frame = 1 / 6;\n        var elapsed = 0;\n        var rest = 0;\n        while(true){\n            elapsed += frame;\n            if (solver(elapsed) === 1) {\n                rest++;\n                if (rest >= 16) {\n                    break;\n                }\n            } else {\n                rest = 0;\n            }\n        }\n        var duration = elapsed * frame * 1000;\n        cache.springs[string] = duration;\n        return duration;\n    }\n    return duration ? solver : getDuration;\n}\n// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\nfunction steps(steps) {\n    if (steps === void 0) steps = 10;\n    return function(t) {\n        return Math.ceil(minMax(t, 0.000001, 1) * steps) * (1 / steps);\n    };\n}\n// BezierEasing https://github.com/gre/bezier-easing\nvar bezier = function() {\n    var kSplineTableSize = 11;\n    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n    function A(aA1, aA2) {\n        return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n    function B(aA1, aA2) {\n        return 3.0 * aA2 - 6.0 * aA1;\n    }\n    function C(aA1) {\n        return 3.0 * aA1;\n    }\n    function calcBezier(aT, aA1, aA2) {\n        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    }\n    function getSlope(aT, aA1, aA2) {\n        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n    function binarySubdivide(aX, aA, aB, mX1, mX2) {\n        var currentX, currentT, i = 0;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        }while (Math.abs(currentX) > 0.0000001 && ++i < 10);\n        return currentT;\n    }\n    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n        for(var i = 0; i < 4; ++i){\n            var currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    }\n    function bezier(mX1, mY1, mX2, mY2) {\n        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n            return;\n        }\n        var sampleValues = new Float32Array(kSplineTableSize);\n        if (mX1 !== mY1 || mX2 !== mY2) {\n            for(var i = 0; i < kSplineTableSize; ++i){\n                sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n            }\n        }\n        function getTForX(aX) {\n            var intervalStart = 0;\n            var currentSample = 1;\n            var lastSample = kSplineTableSize - 1;\n            for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n                intervalStart += kSampleStepSize;\n            }\n            --currentSample;\n            var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n            var guessForT = intervalStart + dist * kSampleStepSize;\n            var initialSlope = getSlope(guessForT, mX1, mX2);\n            if (initialSlope >= 0.001) {\n                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n            } else if (initialSlope === 0.0) {\n                return guessForT;\n            } else {\n                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n            }\n        }\n        return function(x) {\n            if (mX1 === mY1 && mX2 === mY2) {\n                return x;\n            }\n            if (x === 0 || x === 1) {\n                return x;\n            }\n            return calcBezier(getTForX(x), mY1, mY2);\n        };\n    }\n    return bezier;\n}();\nvar penner = function() {\n    // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)\n    var eases = {\n        linear: function() {\n            return function(t) {\n                return t;\n            };\n        }\n    };\n    var functionEasings = {\n        Sine: function() {\n            return function(t) {\n                return 1 - Math.cos(t * Math.PI / 2);\n            };\n        },\n        Expo: function() {\n            return function(t) {\n                return t ? Math.pow(2, 10 * t - 10) : 0;\n            };\n        },\n        Circ: function() {\n            return function(t) {\n                return 1 - Math.sqrt(1 - t * t);\n            };\n        },\n        Back: function() {\n            return function(t) {\n                return t * t * (3 * t - 2);\n            };\n        },\n        Bounce: function() {\n            return function(t) {\n                var pow2, b = 4;\n                while(t < ((pow2 = Math.pow(2, --b)) - 1) / 11){}\n                return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);\n            };\n        },\n        Elastic: function(amplitude, period) {\n            if (amplitude === void 0) amplitude = 1;\n            if (period === void 0) period = .5;\n            var a = minMax(amplitude, 1, 10);\n            var p = minMax(period, .1, 2);\n            return function(t) {\n                return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);\n            };\n        }\n    };\n    var baseEasings = [\n        \"Quad\",\n        \"Cubic\",\n        \"Quart\",\n        \"Quint\"\n    ];\n    baseEasings.forEach(function(name, i) {\n        functionEasings[name] = function() {\n            return function(t) {\n                return Math.pow(t, i + 2);\n            };\n        };\n    });\n    Object.keys(functionEasings).forEach(function(name) {\n        var easeIn = functionEasings[name];\n        eases[\"easeIn\" + name] = easeIn;\n        eases[\"easeOut\" + name] = function(a, b) {\n            return function(t) {\n                return 1 - easeIn(a, b)(1 - t);\n            };\n        };\n        eases[\"easeInOut\" + name] = function(a, b) {\n            return function(t) {\n                return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;\n            };\n        };\n        eases[\"easeOutIn\" + name] = function(a, b) {\n            return function(t) {\n                return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : (easeIn(a, b)(t * 2 - 1) + 1) / 2;\n            };\n        };\n    });\n    return eases;\n}();\nfunction parseEasings(easing, duration) {\n    if (is.fnc(easing)) {\n        return easing;\n    }\n    var name = easing.split(\"(\")[0];\n    var ease = penner[name];\n    var args = parseEasingParameters(easing);\n    switch(name){\n        case \"spring\":\n            return spring(easing, duration);\n        case \"cubicBezier\":\n            return applyArguments(bezier, args);\n        case \"steps\":\n            return applyArguments(steps, args);\n        default:\n            return applyArguments(ease, args);\n    }\n}\n// Strings\nfunction selectString(str) {\n    try {\n        var nodes = document.querySelectorAll(str);\n        return nodes;\n    } catch (e) {\n        return;\n    }\n}\n// Arrays\nfunction filterArray(arr, callback) {\n    var len = arr.length;\n    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n    var result = [];\n    for(var i = 0; i < len; i++){\n        if (i in arr) {\n            var val = arr[i];\n            if (callback.call(thisArg, val, i, arr)) {\n                result.push(val);\n            }\n        }\n    }\n    return result;\n}\nfunction flattenArray(arr) {\n    return arr.reduce(function(a, b) {\n        return a.concat(is.arr(b) ? flattenArray(b) : b);\n    }, []);\n}\nfunction toArray(o) {\n    if (is.arr(o)) {\n        return o;\n    }\n    if (is.str(o)) {\n        o = selectString(o) || o;\n    }\n    if (o instanceof NodeList || o instanceof HTMLCollection) {\n        return [].slice.call(o);\n    }\n    return [\n        o\n    ];\n}\nfunction arrayContains(arr, val) {\n    return arr.some(function(a) {\n        return a === val;\n    });\n}\n// Objects\nfunction cloneObject(o) {\n    var clone = {};\n    for(var p in o){\n        clone[p] = o[p];\n    }\n    return clone;\n}\nfunction replaceObjectProps(o1, o2) {\n    var o = cloneObject(o1);\n    for(var p in o1){\n        o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];\n    }\n    return o;\n}\nfunction mergeObjects(o1, o2) {\n    var o = cloneObject(o1);\n    for(var p in o2){\n        o[p] = is.und(o1[p]) ? o2[p] : o1[p];\n    }\n    return o;\n}\n// Colors\nfunction rgbToRgba(rgbValue) {\n    var rgb = /rgb\\((\\d+,\\s*[\\d]+,\\s*[\\d]+)\\)/g.exec(rgbValue);\n    return rgb ? \"rgba(\" + rgb[1] + \",1)\" : rgbValue;\n}\nfunction hexToRgba(hexValue) {\n    var rgx = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    var hex = hexValue.replace(rgx, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n    });\n    var rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    var r = parseInt(rgb[1], 16);\n    var g = parseInt(rgb[2], 16);\n    var b = parseInt(rgb[3], 16);\n    return \"rgba(\" + r + \",\" + g + \",\" + b + \",1)\";\n}\nfunction hslToRgba(hslValue) {\n    var hsl = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(hslValue) || /hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*([\\d.]+)\\)/g.exec(hslValue);\n    var h = parseInt(hsl[1], 10) / 360;\n    var s = parseInt(hsl[2], 10) / 100;\n    var l = parseInt(hsl[3], 10) / 100;\n    var a = hsl[4] || 1;\n    function hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    var r, g, b;\n    if (s == 0) {\n        r = g = b = l;\n    } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return \"rgba(\" + r * 255 + \",\" + g * 255 + \",\" + b * 255 + \",\" + a + \")\";\n}\nfunction colorToRgb(val) {\n    if (is.rgb(val)) {\n        return rgbToRgba(val);\n    }\n    if (is.hex(val)) {\n        return hexToRgba(val);\n    }\n    if (is.hsl(val)) {\n        return hslToRgba(val);\n    }\n}\n// Units\nfunction getUnit(val) {\n    var split = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);\n    if (split) {\n        return split[1];\n    }\n}\nfunction getTransformUnit(propName) {\n    if (stringContains(propName, \"translate\") || propName === \"perspective\") {\n        return \"px\";\n    }\n    if (stringContains(propName, \"rotate\") || stringContains(propName, \"skew\")) {\n        return \"deg\";\n    }\n}\n// Values\nfunction getFunctionValue(val, animatable) {\n    if (!is.fnc(val)) {\n        return val;\n    }\n    return val(animatable.target, animatable.id, animatable.total);\n}\nfunction getAttribute(el, prop) {\n    return el.getAttribute(prop);\n}\nfunction convertPxToUnit(el, value, unit) {\n    var valueUnit = getUnit(value);\n    if (arrayContains([\n        unit,\n        \"deg\",\n        \"rad\",\n        \"turn\"\n    ], valueUnit)) {\n        return value;\n    }\n    var cached = cache.CSS[value + unit];\n    if (!is.und(cached)) {\n        return cached;\n    }\n    var baseline = 100;\n    var tempEl = document.createElement(el.tagName);\n    var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;\n    parentEl.appendChild(tempEl);\n    tempEl.style.position = \"absolute\";\n    tempEl.style.width = baseline + unit;\n    var factor = baseline / tempEl.offsetWidth;\n    parentEl.removeChild(tempEl);\n    var convertedUnit = factor * parseFloat(value);\n    cache.CSS[value + unit] = convertedUnit;\n    return convertedUnit;\n}\nfunction getCSSValue(el, prop, unit) {\n    if (prop in el.style) {\n        var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n        var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || \"0\";\n        return unit ? convertPxToUnit(el, value, unit) : value;\n    }\n}\nfunction getAnimationType(el, prop) {\n    if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || is.svg(el) && el[prop])) {\n        return \"attribute\";\n    }\n    if (is.dom(el) && arrayContains(validTransforms, prop)) {\n        return \"transform\";\n    }\n    if (is.dom(el) && prop !== \"transform\" && getCSSValue(el, prop)) {\n        return \"css\";\n    }\n    if (el[prop] != null) {\n        return \"object\";\n    }\n}\nfunction getElementTransforms(el) {\n    if (!is.dom(el)) {\n        return;\n    }\n    var str = el.style.transform || \"\";\n    var reg = /(\\w+)\\(([^)]*)\\)/g;\n    var transforms = new Map();\n    var m;\n    while(m = reg.exec(str)){\n        transforms.set(m[1], m[2]);\n    }\n    return transforms;\n}\nfunction getTransformValue(el, propName, animatable, unit) {\n    var defaultVal = stringContains(propName, \"scale\") ? 1 : 0 + getTransformUnit(propName);\n    var value = getElementTransforms(el).get(propName) || defaultVal;\n    if (animatable) {\n        animatable.transforms.list.set(propName, value);\n        animatable.transforms[\"last\"] = propName;\n    }\n    return unit ? convertPxToUnit(el, value, unit) : value;\n}\nfunction getOriginalTargetValue(target, propName, unit, animatable) {\n    switch(getAnimationType(target, propName)){\n        case \"transform\":\n            return getTransformValue(target, propName, animatable, unit);\n        case \"css\":\n            return getCSSValue(target, propName, unit);\n        case \"attribute\":\n            return getAttribute(target, propName);\n        default:\n            return target[propName] || 0;\n    }\n}\nfunction getRelativeValue(to, from) {\n    var operator = /^(\\*=|\\+=|-=)/.exec(to);\n    if (!operator) {\n        return to;\n    }\n    var u = getUnit(to) || 0;\n    var x = parseFloat(from);\n    var y = parseFloat(to.replace(operator[0], \"\"));\n    switch(operator[0][0]){\n        case \"+\":\n            return x + y + u;\n        case \"-\":\n            return x - y + u;\n        case \"*\":\n            return x * y + u;\n    }\n}\nfunction validateValue(val, unit) {\n    if (is.col(val)) {\n        return colorToRgb(val);\n    }\n    if (/\\s/g.test(val)) {\n        return val;\n    }\n    var originalUnit = getUnit(val);\n    var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;\n    if (unit) {\n        return unitLess + unit;\n    }\n    return unitLess;\n}\n// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes\n// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744\nfunction getDistance(p1, p2) {\n    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\nfunction getCircleLength(el) {\n    return Math.PI * 2 * getAttribute(el, \"r\");\n}\nfunction getRectLength(el) {\n    return getAttribute(el, \"width\") * 2 + getAttribute(el, \"height\") * 2;\n}\nfunction getLineLength(el) {\n    return getDistance({\n        x: getAttribute(el, \"x1\"),\n        y: getAttribute(el, \"y1\")\n    }, {\n        x: getAttribute(el, \"x2\"),\n        y: getAttribute(el, \"y2\")\n    });\n}\nfunction getPolylineLength(el) {\n    var points = el.points;\n    var totalLength = 0;\n    var previousPos;\n    for(var i = 0; i < points.numberOfItems; i++){\n        var currentPos = points.getItem(i);\n        if (i > 0) {\n            totalLength += getDistance(previousPos, currentPos);\n        }\n        previousPos = currentPos;\n    }\n    return totalLength;\n}\nfunction getPolygonLength(el) {\n    var points = el.points;\n    return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));\n}\n// Path animation\nfunction getTotalLength(el) {\n    if (el.getTotalLength) {\n        return el.getTotalLength();\n    }\n    switch(el.tagName.toLowerCase()){\n        case \"circle\":\n            return getCircleLength(el);\n        case \"rect\":\n            return getRectLength(el);\n        case \"line\":\n            return getLineLength(el);\n        case \"polyline\":\n            return getPolylineLength(el);\n        case \"polygon\":\n            return getPolygonLength(el);\n    }\n}\nfunction setDashoffset(el) {\n    var pathLength = getTotalLength(el);\n    el.setAttribute(\"stroke-dasharray\", pathLength);\n    return pathLength;\n}\n// Motion path\nfunction getParentSvgEl(el) {\n    var parentEl = el.parentNode;\n    while(is.svg(parentEl)){\n        if (!is.svg(parentEl.parentNode)) {\n            break;\n        }\n        parentEl = parentEl.parentNode;\n    }\n    return parentEl;\n}\nfunction getParentSvg(pathEl, svgData) {\n    var svg = svgData || {};\n    var parentSvgEl = svg.el || getParentSvgEl(pathEl);\n    var rect = parentSvgEl.getBoundingClientRect();\n    var viewBoxAttr = getAttribute(parentSvgEl, \"viewBox\");\n    var width = rect.width;\n    var height = rect.height;\n    var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(\" \") : [\n        0,\n        0,\n        width,\n        height\n    ]);\n    return {\n        el: parentSvgEl,\n        viewBox: viewBox,\n        x: viewBox[0] / 1,\n        y: viewBox[1] / 1,\n        w: width,\n        h: height,\n        vW: viewBox[2],\n        vH: viewBox[3]\n    };\n}\nfunction getPath(path, percent) {\n    var pathEl = is.str(path) ? selectString(path)[0] : path;\n    var p = percent || 100;\n    return function(property) {\n        return {\n            property: property,\n            el: pathEl,\n            svg: getParentSvg(pathEl),\n            totalLength: getTotalLength(pathEl) * (p / 100)\n        };\n    };\n}\nfunction getPathProgress(path, progress, isPathTargetInsideSVG) {\n    function point(offset) {\n        if (offset === void 0) offset = 0;\n        var l = progress + offset >= 1 ? progress + offset : 0;\n        return path.el.getPointAtLength(l);\n    }\n    var svg = getParentSvg(path.el, path.svg);\n    var p = point();\n    var p0 = point(-1);\n    var p1 = point(+1);\n    var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;\n    var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;\n    switch(path.property){\n        case \"x\":\n            return (p.x - svg.x) * scaleX;\n        case \"y\":\n            return (p.y - svg.y) * scaleY;\n        case \"angle\":\n            return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;\n    }\n}\n// Decompose value\nfunction decomposeValue(val, unit) {\n    // const rgx = /-?\\d*\\.?\\d+/g; // handles basic numbers\n    // const rgx = /[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n    var rgx = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n    var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + \"\";\n    return {\n        original: value,\n        numbers: value.match(rgx) ? value.match(rgx).map(Number) : [\n            0\n        ],\n        strings: is.str(val) || unit ? value.split(rgx) : []\n    };\n}\n// Animatables\nfunction parseTargets(targets) {\n    var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];\n    return filterArray(targetsArray, function(item, pos, self) {\n        return self.indexOf(item) === pos;\n    });\n}\nfunction getAnimatables(targets) {\n    var parsed = parseTargets(targets);\n    return parsed.map(function(t, i) {\n        return {\n            target: t,\n            id: i,\n            total: parsed.length,\n            transforms: {\n                list: getElementTransforms(t)\n            }\n        };\n    });\n}\n// Properties\nfunction normalizePropertyTweens(prop, tweenSettings) {\n    var settings = cloneObject(tweenSettings);\n    // Override duration if easing is a spring\n    if (/^spring/.test(settings.easing)) {\n        settings.duration = spring(settings.easing);\n    }\n    if (is.arr(prop)) {\n        var l = prop.length;\n        var isFromTo = l === 2 && !is.obj(prop[0]);\n        if (!isFromTo) {\n            // Duration divided by the number of tweens\n            if (!is.fnc(tweenSettings.duration)) {\n                settings.duration = tweenSettings.duration / l;\n            }\n        } else {\n            // Transform [from, to] values shorthand to a valid tween value\n            prop = {\n                value: prop\n            };\n        }\n    }\n    var propArray = is.arr(prop) ? prop : [\n        prop\n    ];\n    return propArray.map(function(v, i) {\n        var obj = is.obj(v) && !is.pth(v) ? v : {\n            value: v\n        };\n        // Default delay value should only be applied to the first tween\n        if (is.und(obj.delay)) {\n            obj.delay = !i ? tweenSettings.delay : 0;\n        }\n        // Default endDelay value should only be applied to the last tween\n        if (is.und(obj.endDelay)) {\n            obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;\n        }\n        return obj;\n    }).map(function(k) {\n        return mergeObjects(k, settings);\n    });\n}\nfunction flattenKeyframes(keyframes) {\n    var propertyNames = filterArray(flattenArray(keyframes.map(function(key) {\n        return Object.keys(key);\n    })), function(p) {\n        return is.key(p);\n    }).reduce(function(a, b) {\n        if (a.indexOf(b) < 0) {\n            a.push(b);\n        }\n        return a;\n    }, []);\n    var properties = {};\n    var loop = function(i) {\n        var propName = propertyNames[i];\n        properties[propName] = keyframes.map(function(key) {\n            var newKey = {};\n            for(var p in key){\n                if (is.key(p)) {\n                    if (p == propName) {\n                        newKey.value = key[p];\n                    }\n                } else {\n                    newKey[p] = key[p];\n                }\n            }\n            return newKey;\n        });\n    };\n    for(var i = 0; i < propertyNames.length; i++)loop(i);\n    return properties;\n}\nfunction getProperties(tweenSettings, params) {\n    var properties = [];\n    var keyframes = params.keyframes;\n    if (keyframes) {\n        params = mergeObjects(flattenKeyframes(keyframes), params);\n    }\n    for(var p in params){\n        if (is.key(p)) {\n            properties.push({\n                name: p,\n                tweens: normalizePropertyTweens(params[p], tweenSettings)\n            });\n        }\n    }\n    return properties;\n}\n// Tweens\nfunction normalizeTweenValues(tween, animatable) {\n    var t = {};\n    for(var p in tween){\n        var value = getFunctionValue(tween[p], animatable);\n        if (is.arr(value)) {\n            value = value.map(function(v) {\n                return getFunctionValue(v, animatable);\n            });\n            if (value.length === 1) {\n                value = value[0];\n            }\n        }\n        t[p] = value;\n    }\n    t.duration = parseFloat(t.duration);\n    t.delay = parseFloat(t.delay);\n    return t;\n}\nfunction normalizeTweens(prop, animatable) {\n    var previousTween;\n    return prop.tweens.map(function(t) {\n        var tween = normalizeTweenValues(t, animatable);\n        var tweenValue = tween.value;\n        var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;\n        var toUnit = getUnit(to);\n        var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);\n        var previousValue = previousTween ? previousTween.to.original : originalValue;\n        var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;\n        var fromUnit = getUnit(from) || getUnit(originalValue);\n        var unit = toUnit || fromUnit;\n        if (is.und(to)) {\n            to = previousValue;\n        }\n        tween.from = decomposeValue(from, unit);\n        tween.to = decomposeValue(getRelativeValue(to, from), unit);\n        tween.start = previousTween ? previousTween.end : 0;\n        tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;\n        tween.easing = parseEasings(tween.easing, tween.duration);\n        tween.isPath = is.pth(tweenValue);\n        tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);\n        tween.isColor = is.col(tween.from.original);\n        if (tween.isColor) {\n            tween.round = 1;\n        }\n        previousTween = tween;\n        return tween;\n    });\n}\n// Tween progress\nvar setProgressValue = {\n    css: function(t, p, v) {\n        return t.style[p] = v;\n    },\n    attribute: function(t, p, v) {\n        return t.setAttribute(p, v);\n    },\n    object: function(t, p, v) {\n        return t[p] = v;\n    },\n    transform: function(t, p, v, transforms, manual) {\n        transforms.list.set(p, v);\n        if (p === transforms.last || manual) {\n            var str = \"\";\n            transforms.list.forEach(function(value, prop) {\n                str += prop + \"(\" + value + \") \";\n            });\n            t.style.transform = str;\n        }\n    }\n};\n// Set Value helper\nfunction setTargetsValue(targets, properties) {\n    var animatables = getAnimatables(targets);\n    animatables.forEach(function(animatable) {\n        for(var property in properties){\n            var value = getFunctionValue(properties[property], animatable);\n            var target = animatable.target;\n            var valueUnit = getUnit(value);\n            var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);\n            var unit = valueUnit || getUnit(originalValue);\n            var to = getRelativeValue(validateValue(value, unit), originalValue);\n            var animType = getAnimationType(target, property);\n            setProgressValue[animType](target, property, to, animatable.transforms, true);\n        }\n    });\n}\n// Animations\nfunction createAnimation(animatable, prop) {\n    var animType = getAnimationType(animatable.target, prop.name);\n    if (animType) {\n        var tweens = normalizeTweens(prop, animatable);\n        var lastTween = tweens[tweens.length - 1];\n        return {\n            type: animType,\n            property: prop.name,\n            animatable: animatable,\n            tweens: tweens,\n            duration: lastTween.end,\n            delay: tweens[0].delay,\n            endDelay: lastTween.endDelay\n        };\n    }\n}\nfunction getAnimations(animatables, properties) {\n    return filterArray(flattenArray(animatables.map(function(animatable) {\n        return properties.map(function(prop) {\n            return createAnimation(animatable, prop);\n        });\n    })), function(a) {\n        return !is.und(a);\n    });\n}\n// Create Instance\nfunction getInstanceTimings(animations, tweenSettings) {\n    var animLength = animations.length;\n    var getTlOffset = function(anim) {\n        return anim.timelineOffset ? anim.timelineOffset : 0;\n    };\n    var timings = {};\n    timings.duration = animLength ? Math.max.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.duration;\n    })) : tweenSettings.duration;\n    timings.delay = animLength ? Math.min.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.delay;\n    })) : tweenSettings.delay;\n    timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.duration - anim.endDelay;\n    })) : tweenSettings.endDelay;\n    return timings;\n}\nvar instanceID = 0;\nfunction createNewInstance(params) {\n    var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);\n    var tweenSettings = replaceObjectProps(defaultTweenSettings, params);\n    var properties = getProperties(tweenSettings, params);\n    var animatables = getAnimatables(params.targets);\n    var animations = getAnimations(animatables, properties);\n    var timings = getInstanceTimings(animations, tweenSettings);\n    var id = instanceID;\n    instanceID++;\n    return mergeObjects(instanceSettings, {\n        id: id,\n        children: [],\n        animatables: animatables,\n        animations: animations,\n        duration: timings.duration,\n        delay: timings.delay,\n        endDelay: timings.endDelay\n    });\n}\n// Core\nvar activeInstances = [];\nvar engine = function() {\n    var raf;\n    function play() {\n        if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {\n            raf = requestAnimationFrame(step);\n        }\n    }\n    function step(t) {\n        // memo on algorithm issue:\n        // dangerous iteration over mutable `activeInstances`\n        // (that collection may be updated from within callbacks of `tick`-ed animation instances)\n        var activeInstancesLength = activeInstances.length;\n        var i = 0;\n        while(i < activeInstancesLength){\n            var activeInstance = activeInstances[i];\n            if (!activeInstance.paused) {\n                activeInstance.tick(t);\n                i++;\n            } else {\n                activeInstances.splice(i, 1);\n                activeInstancesLength--;\n            }\n        }\n        raf = i > 0 ? requestAnimationFrame(step) : undefined;\n    }\n    function handleVisibilityChange() {\n        if (!anime.suspendWhenDocumentHidden) {\n            return;\n        }\n        if (isDocumentHidden()) {\n            // suspend ticks\n            raf = cancelAnimationFrame(raf);\n        } else {\n            // first adjust animations to consider the time that ticks were suspended\n            activeInstances.forEach(function(instance) {\n                return instance._onDocumentVisibility();\n            });\n            engine();\n        }\n    }\n    if (typeof document !== \"undefined\") {\n        document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    }\n    return play;\n}();\nfunction isDocumentHidden() {\n    return !!document && document.hidden;\n}\n// Public Instance\nfunction anime(params) {\n    if (params === void 0) params = {};\n    var startTime = 0, lastTime = 0, now = 0;\n    var children, childrenLength = 0;\n    var resolve = null;\n    function makePromise(instance) {\n        var promise = window.Promise && new Promise(function(_resolve) {\n            return resolve = _resolve;\n        });\n        instance.finished = promise;\n        return promise;\n    }\n    var instance = createNewInstance(params);\n    var promise = makePromise(instance);\n    function toggleInstanceDirection() {\n        var direction = instance.direction;\n        if (direction !== \"alternate\") {\n            instance.direction = direction !== \"normal\" ? \"normal\" : \"reverse\";\n        }\n        instance.reversed = !instance.reversed;\n        children.forEach(function(child) {\n            return child.reversed = instance.reversed;\n        });\n    }\n    function adjustTime(time) {\n        return instance.reversed ? instance.duration - time : time;\n    }\n    function resetTime() {\n        startTime = 0;\n        lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);\n    }\n    function seekChild(time, child) {\n        if (child) {\n            child.seek(time - child.timelineOffset);\n        }\n    }\n    function syncInstanceChildren(time) {\n        if (!instance.reversePlayback) {\n            for(var i = 0; i < childrenLength; i++){\n                seekChild(time, children[i]);\n            }\n        } else {\n            for(var i$1 = childrenLength; i$1--;){\n                seekChild(time, children[i$1]);\n            }\n        }\n    }\n    function setAnimationsProgress(insTime) {\n        var i = 0;\n        var animations = instance.animations;\n        var animationsLength = animations.length;\n        while(i < animationsLength){\n            var anim = animations[i];\n            var animatable = anim.animatable;\n            var tweens = anim.tweens;\n            var tweenLength = tweens.length - 1;\n            var tween = tweens[tweenLength];\n            // Only check for keyframes if there is more than one tween\n            if (tweenLength) {\n                tween = filterArray(tweens, function(t) {\n                    return insTime < t.end;\n                })[0] || tween;\n            }\n            var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;\n            var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);\n            var strings = tween.to.strings;\n            var round = tween.round;\n            var numbers = [];\n            var toNumbersLength = tween.to.numbers.length;\n            var progress = void 0;\n            for(var n = 0; n < toNumbersLength; n++){\n                var value = void 0;\n                var toNumber = tween.to.numbers[n];\n                var fromNumber = tween.from.numbers[n] || 0;\n                if (!tween.isPath) {\n                    value = fromNumber + eased * (toNumber - fromNumber);\n                } else {\n                    value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);\n                }\n                if (round) {\n                    if (!(tween.isColor && n > 2)) {\n                        value = Math.round(value * round) / round;\n                    }\n                }\n                numbers.push(value);\n            }\n            // Manual Array.reduce for better performances\n            var stringsLength = strings.length;\n            if (!stringsLength) {\n                progress = numbers[0];\n            } else {\n                progress = strings[0];\n                for(var s = 0; s < stringsLength; s++){\n                    var a = strings[s];\n                    var b = strings[s + 1];\n                    var n$1 = numbers[s];\n                    if (!isNaN(n$1)) {\n                        if (!b) {\n                            progress += n$1 + \" \";\n                        } else {\n                            progress += n$1 + b;\n                        }\n                    }\n                }\n            }\n            setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);\n            anim.currentValue = progress;\n            i++;\n        }\n    }\n    function setCallback(cb) {\n        if (instance[cb] && !instance.passThrough) {\n            instance[cb](instance);\n        }\n    }\n    function countIteration() {\n        if (instance.remaining && instance.remaining !== true) {\n            instance.remaining--;\n        }\n    }\n    function setInstanceProgress(engineTime) {\n        var insDuration = instance.duration;\n        var insDelay = instance.delay;\n        var insEndDelay = insDuration - instance.endDelay;\n        var insTime = adjustTime(engineTime);\n        instance.progress = minMax(insTime / insDuration * 100, 0, 100);\n        instance.reversePlayback = insTime < instance.currentTime;\n        if (children) {\n            syncInstanceChildren(insTime);\n        }\n        if (!instance.began && instance.currentTime > 0) {\n            instance.began = true;\n            setCallback(\"begin\");\n        }\n        if (!instance.loopBegan && instance.currentTime > 0) {\n            instance.loopBegan = true;\n            setCallback(\"loopBegin\");\n        }\n        if (insTime <= insDelay && instance.currentTime !== 0) {\n            setAnimationsProgress(0);\n        }\n        if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {\n            setAnimationsProgress(insDuration);\n        }\n        if (insTime > insDelay && insTime < insEndDelay) {\n            if (!instance.changeBegan) {\n                instance.changeBegan = true;\n                instance.changeCompleted = false;\n                setCallback(\"changeBegin\");\n            }\n            setCallback(\"change\");\n            setAnimationsProgress(insTime);\n        } else {\n            if (instance.changeBegan) {\n                instance.changeCompleted = true;\n                instance.changeBegan = false;\n                setCallback(\"changeComplete\");\n            }\n        }\n        instance.currentTime = minMax(insTime, 0, insDuration);\n        if (instance.began) {\n            setCallback(\"update\");\n        }\n        if (engineTime >= insDuration) {\n            lastTime = 0;\n            countIteration();\n            if (!instance.remaining) {\n                instance.paused = true;\n                if (!instance.completed) {\n                    instance.completed = true;\n                    setCallback(\"loopComplete\");\n                    setCallback(\"complete\");\n                    if (!instance.passThrough && \"Promise\" in window) {\n                        resolve();\n                        promise = makePromise(instance);\n                    }\n                }\n            } else {\n                startTime = now;\n                setCallback(\"loopComplete\");\n                instance.loopBegan = false;\n                if (instance.direction === \"alternate\") {\n                    toggleInstanceDirection();\n                }\n            }\n        }\n    }\n    instance.reset = function() {\n        var direction = instance.direction;\n        instance.passThrough = false;\n        instance.currentTime = 0;\n        instance.progress = 0;\n        instance.paused = true;\n        instance.began = false;\n        instance.loopBegan = false;\n        instance.changeBegan = false;\n        instance.completed = false;\n        instance.changeCompleted = false;\n        instance.reversePlayback = false;\n        instance.reversed = direction === \"reverse\";\n        instance.remaining = instance.loop;\n        children = instance.children;\n        childrenLength = children.length;\n        for(var i = childrenLength; i--;){\n            instance.children[i].reset();\n        }\n        if (instance.reversed && instance.loop !== true || direction === \"alternate\" && instance.loop === 1) {\n            instance.remaining++;\n        }\n        setAnimationsProgress(instance.reversed ? instance.duration : 0);\n    };\n    // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)\n    instance._onDocumentVisibility = resetTime;\n    // Set Value helper\n    instance.set = function(targets, properties) {\n        setTargetsValue(targets, properties);\n        return instance;\n    };\n    instance.tick = function(t) {\n        now = t;\n        if (!startTime) {\n            startTime = now;\n        }\n        setInstanceProgress((now + (lastTime - startTime)) * anime.speed);\n    };\n    instance.seek = function(time) {\n        setInstanceProgress(adjustTime(time));\n    };\n    instance.pause = function() {\n        instance.paused = true;\n        resetTime();\n    };\n    instance.play = function() {\n        if (!instance.paused) {\n            return;\n        }\n        if (instance.completed) {\n            instance.reset();\n        }\n        instance.paused = false;\n        activeInstances.push(instance);\n        resetTime();\n        engine();\n    };\n    instance.reverse = function() {\n        toggleInstanceDirection();\n        instance.completed = instance.reversed ? false : true;\n        resetTime();\n    };\n    instance.restart = function() {\n        instance.reset();\n        instance.play();\n    };\n    instance.remove = function(targets) {\n        var targetsArray = parseTargets(targets);\n        removeTargetsFromInstance(targetsArray, instance);\n    };\n    instance.reset();\n    if (instance.autoplay) {\n        instance.play();\n    }\n    return instance;\n}\n// Remove targets from animation\nfunction removeTargetsFromAnimations(targetsArray, animations) {\n    for(var a = animations.length; a--;){\n        if (arrayContains(targetsArray, animations[a].animatable.target)) {\n            animations.splice(a, 1);\n        }\n    }\n}\nfunction removeTargetsFromInstance(targetsArray, instance) {\n    var animations = instance.animations;\n    var children = instance.children;\n    removeTargetsFromAnimations(targetsArray, animations);\n    for(var c = children.length; c--;){\n        var child = children[c];\n        var childAnimations = child.animations;\n        removeTargetsFromAnimations(targetsArray, childAnimations);\n        if (!childAnimations.length && !child.children.length) {\n            children.splice(c, 1);\n        }\n    }\n    if (!animations.length && !children.length) {\n        instance.pause();\n    }\n}\nfunction removeTargetsFromActiveInstances(targets) {\n    var targetsArray = parseTargets(targets);\n    for(var i = activeInstances.length; i--;){\n        var instance = activeInstances[i];\n        removeTargetsFromInstance(targetsArray, instance);\n    }\n}\n// Stagger helpers\nfunction stagger(val, params) {\n    if (params === void 0) params = {};\n    var direction = params.direction || \"normal\";\n    var easing = params.easing ? parseEasings(params.easing) : null;\n    var grid = params.grid;\n    var axis = params.axis;\n    var fromIndex = params.from || 0;\n    var fromFirst = fromIndex === \"first\";\n    var fromCenter = fromIndex === \"center\";\n    var fromLast = fromIndex === \"last\";\n    var isRange = is.arr(val);\n    var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);\n    var val2 = isRange ? parseFloat(val[1]) : 0;\n    var unit = getUnit(isRange ? val[1] : val) || 0;\n    var start = params.start || 0 + (isRange ? val1 : 0);\n    var values = [];\n    var maxValue = 0;\n    return function(el, i, t) {\n        if (fromFirst) {\n            fromIndex = 0;\n        }\n        if (fromCenter) {\n            fromIndex = (t - 1) / 2;\n        }\n        if (fromLast) {\n            fromIndex = t - 1;\n        }\n        if (!values.length) {\n            for(var index = 0; index < t; index++){\n                if (!grid) {\n                    values.push(Math.abs(fromIndex - index));\n                } else {\n                    var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n                    var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n                    var toX = index % grid[0];\n                    var toY = Math.floor(index / grid[0]);\n                    var distanceX = fromX - toX;\n                    var distanceY = fromY - toY;\n                    var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n                    if (axis === \"x\") {\n                        value = -distanceX;\n                    }\n                    if (axis === \"y\") {\n                        value = -distanceY;\n                    }\n                    values.push(value);\n                }\n                maxValue = Math.max.apply(Math, values);\n            }\n            if (easing) {\n                values = values.map(function(val) {\n                    return easing(val / maxValue) * maxValue;\n                });\n            }\n            if (direction === \"reverse\") {\n                values = values.map(function(val) {\n                    return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);\n                });\n            }\n        }\n        var spacing = isRange ? (val2 - val1) / maxValue : val1;\n        return start + spacing * (Math.round(values[i] * 100) / 100) + unit;\n    };\n}\n// Timeline\nfunction timeline(params) {\n    if (params === void 0) params = {};\n    var tl = anime(params);\n    tl.duration = 0;\n    tl.add = function(instanceParams, timelineOffset) {\n        var tlIndex = activeInstances.indexOf(tl);\n        var children = tl.children;\n        if (tlIndex > -1) {\n            activeInstances.splice(tlIndex, 1);\n        }\n        function passThrough(ins) {\n            ins.passThrough = true;\n        }\n        for(var i = 0; i < children.length; i++){\n            passThrough(children[i]);\n        }\n        var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));\n        insParams.targets = insParams.targets || params.targets;\n        var tlDuration = tl.duration;\n        insParams.autoplay = false;\n        insParams.direction = tl.direction;\n        insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);\n        passThrough(tl);\n        tl.seek(insParams.timelineOffset);\n        var ins = anime(insParams);\n        passThrough(ins);\n        children.push(ins);\n        var timings = getInstanceTimings(children, params);\n        tl.delay = timings.delay;\n        tl.endDelay = timings.endDelay;\n        tl.duration = timings.duration;\n        tl.seek(0);\n        tl.reset();\n        if (tl.autoplay) {\n            tl.play();\n        }\n        return tl;\n    };\n    return tl;\n}\nanime.version = \"3.2.1\";\nanime.speed = 1;\n// TODO:#review: naming, documentation\nanime.suspendWhenDocumentHidden = true;\nanime.running = activeInstances;\nanime.remove = removeTargetsFromActiveInstances;\nanime.get = getOriginalTargetValue;\nanime.set = setTargetsValue;\nanime.convertPx = convertPxToUnit;\nanime.path = getPath;\nanime.setDashoffset = setDashoffset;\nanime.stagger = stagger;\nanime.timeline = timeline;\nanime.easing = parseEasings;\nanime.penner = penner;\nanime.random = function(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (anime);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYW5pbWVqcy9saWIvYW5pbWUuZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztDQUtDLEdBRUQsV0FBVztBQUVYLElBQUlBLDBCQUEwQjtJQUM1QkMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxRQUFRO0lBQ1JDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxVQUFVO0lBQ1ZDLGdCQUFnQjtBQUNsQjtBQUVBLElBQUlDLHVCQUF1QjtJQUN6QkMsVUFBVTtJQUNWQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxPQUFPO0FBQ1Q7QUFFQSxJQUFJQyxrQkFBa0I7SUFBQztJQUFjO0lBQWM7SUFBYztJQUFVO0lBQVc7SUFBVztJQUFXO0lBQVM7SUFBVTtJQUFVO0lBQVU7SUFBUTtJQUFTO0lBQVM7SUFBZTtJQUFVO0NBQVc7QUFFak4sVUFBVTtBQUVWLElBQUlDLFFBQVE7SUFDVkMsS0FBSyxDQUFDO0lBQ05DLFNBQVMsQ0FBQztBQUNaO0FBRUEsUUFBUTtBQUVSLFNBQVNDLE9BQU9DLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQzNCLE9BQU9DLEtBQUtGLEdBQUcsQ0FBQ0UsS0FBS0QsR0FBRyxDQUFDRixLQUFLQyxNQUFNQztBQUN0QztBQUVBLFNBQVNFLGVBQWVDLEdBQUcsRUFBRUMsSUFBSTtJQUMvQixPQUFPRCxJQUFJRSxPQUFPLENBQUNELFFBQVEsQ0FBQztBQUM5QjtBQUVBLFNBQVNFLGVBQWVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxPQUFPRCxLQUFLRSxLQUFLLENBQUMsTUFBTUQ7QUFDMUI7QUFFQSxJQUFJRSxLQUFLO0lBQ1BDLEtBQUssU0FBVUMsQ0FBQztRQUFJLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0Y7SUFBSTtJQUM3Q0csS0FBSyxTQUFVSCxDQUFDO1FBQUksT0FBT1YsZUFBZWMs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bUJBQW1CUyxVQUFVcFM7UUFDM0M4WSxHQUFHdmMsS0FBSyxHQUFHeVYsUUFBUXpWLEtBQUs7UUFDeEJ1YyxHQUFHdGMsUUFBUSxHQUFHd1YsUUFBUXhWLFFBQVE7UUFDOUJzYyxHQUFHeGMsUUFBUSxHQUFHMFYsUUFBUTFWLFFBQVE7UUFDOUJ3YyxHQUFHaEUsSUFBSSxDQUFDO1FBQ1JnRSxHQUFHaEMsS0FBSztRQUNSLElBQUlnQyxHQUFHM2MsUUFBUSxFQUFFO1lBQUUyYyxHQUFHdEcsSUFBSTtRQUFJO1FBQzlCLE9BQU9zRztJQUNUO0lBQ0EsT0FBT0E7QUFDVDtBQUVBcEcsTUFBTTJHLE9BQU8sR0FBRztBQUNoQjNHLE1BQU1rQyxLQUFLLEdBQUc7QUFDZCxzQ0FBc0M7QUFDdENsQyxNQUFNQyx5QkFBeUIsR0FBRztBQUNsQ0QsTUFBTTRHLE9BQU8sR0FBR2pIO0FBQ2hCSyxNQUFNd0UsTUFBTSxHQUFHSztBQUNmN0UsTUFBTTdILEdBQUcsR0FBR0U7QUFDWjJILE1BQU1oSSxHQUFHLEdBQUcwRztBQUNac0IsTUFBTTZHLFNBQVMsR0FBRzNRO0FBQ2xCOEosTUFBTWhGLElBQUksR0FBR0Q7QUFDYmlGLE1BQU1qRyxhQUFhLEdBQUdBO0FBQ3RCaUcsTUFBTThFLE9BQU8sR0FBR0E7QUFDaEI5RSxNQUFNbUcsUUFBUSxHQUFHQTtBQUNqQm5HLE1BQU1qVyxNQUFNLEdBQUd1STtBQUNmME4sTUFBTS9PLE1BQU0sR0FBR0E7QUFDZitPLE1BQU04RyxNQUFNLEdBQUcsU0FBVXZjLEdBQUcsRUFBRUMsR0FBRztJQUFJLE9BQU9DLEtBQUtvYixLQUFLLENBQUNwYixLQUFLcWMsTUFBTSxLQUFNdGMsQ0FBQUEsTUFBTUQsTUFBTSxNQUFNQTtBQUFLO0FBRS9GLGlFQUFleVYsS0FBS0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2YzNTYvLi9ub2RlX21vZHVsZXMvYW5pbWVqcy9saWIvYW5pbWUuZXMuanM/OTM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogYW5pbWUuanMgdjMuMi4yXG4gKiAoYykgMjAyMyBKdWxpYW4gR2FybmllclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBhbmltZWpzLmNvbVxuICovXG5cbi8vIERlZmF1bHRzXG5cbnZhciBkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncyA9IHtcbiAgdXBkYXRlOiBudWxsLFxuICBiZWdpbjogbnVsbCxcbiAgbG9vcEJlZ2luOiBudWxsLFxuICBjaGFuZ2VCZWdpbjogbnVsbCxcbiAgY2hhbmdlOiBudWxsLFxuICBjaGFuZ2VDb21wbGV0ZTogbnVsbCxcbiAgbG9vcENvbXBsZXRlOiBudWxsLFxuICBjb21wbGV0ZTogbnVsbCxcbiAgbG9vcDogMSxcbiAgZGlyZWN0aW9uOiAnbm9ybWFsJyxcbiAgYXV0b3BsYXk6IHRydWUsXG4gIHRpbWVsaW5lT2Zmc2V0OiAwXG59O1xuXG52YXIgZGVmYXVsdFR3ZWVuU2V0dGluZ3MgPSB7XG4gIGR1cmF0aW9uOiAxMDAwLFxuICBkZWxheTogMCxcbiAgZW5kRGVsYXk6IDAsXG4gIGVhc2luZzogJ2Vhc2VPdXRFbGFzdGljKDEsIC41KScsXG4gIHJvdW5kOiAwXG59O1xuXG52YXIgdmFsaWRUcmFuc2Zvcm1zID0gWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAndHJhbnNsYXRlWicsICdyb3RhdGUnLCAncm90YXRlWCcsICdyb3RhdGVZJywgJ3JvdGF0ZVonLCAnc2NhbGUnLCAnc2NhbGVYJywgJ3NjYWxlWScsICdzY2FsZVonLCAnc2tldycsICdza2V3WCcsICdza2V3WScsICdwZXJzcGVjdGl2ZScsICdtYXRyaXgnLCAnbWF0cml4M2QnXTtcblxuLy8gQ2FjaGluZ1xuXG52YXIgY2FjaGUgPSB7XG4gIENTUzoge30sXG4gIHNwcmluZ3M6IHt9XG59O1xuXG4vLyBVdGlsc1xuXG5mdW5jdGlvbiBtaW5NYXgodmFsLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdDb250YWlucyhzdHIsIHRleHQpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKHRleHQpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QXJndW1lbnRzKGZ1bmMsIGFyZ3MpIHtcbiAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG59XG5cbnZhciBpcyA9IHtcbiAgYXJyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gQXJyYXkuaXNBcnJheShhKTsgfSxcbiAgb2JqOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gc3RyaW5nQ29udGFpbnMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpLCAnT2JqZWN0Jyk7IH0sXG4gIHB0aDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGlzLm9iaihhKSAmJiBhLmhhc093blByb3BlcnR5KCd0b3RhbExlbmd0aCcpOyB9LFxuICBzdmc6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgU1ZHRWxlbWVudDsgfSxcbiAgaW5wOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQ7IH0sXG4gIGRvbTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEubm9kZVR5cGUgfHwgaXMuc3ZnKGEpOyB9LFxuICBzdHI6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ3N0cmluZyc7IH0sXG4gIGZuYzogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAnZnVuY3Rpb24nOyB9LFxuICB1bmQ6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCc7IH0sXG4gIG5pbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGlzLnVuZChhKSB8fCBhID09PSBudWxsOyB9LFxuICBoZXg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChhKTsgfSxcbiAgcmdiOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gL15yZ2IvLnRlc3QoYSk7IH0sXG4gIGhzbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC9eaHNsLy50ZXN0KGEpOyB9LFxuICBjb2w6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAoaXMuaGV4KGEpIHx8IGlzLnJnYihhKSB8fCBpcy5oc2woYSkpOyB9LFxuICBrZXk6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAhZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYSkgJiYgIWRlZmF1bHRUd2VlblNldHRpbmdzLmhhc093blByb3BlcnR5KGEpICYmIGEgIT09ICd0YXJnZXRzJyAmJiBhICE9PSAna2V5ZnJhbWVzJzsgfSxcbn07XG5cbi8vIEVhc2luZ3NcblxuZnVuY3Rpb24gcGFyc2VFYXNpbmdQYXJhbWV0ZXJzKHN0cmluZykge1xuICB2YXIgbWF0Y2ggPSAvXFwoKFteKV0rKVxcKS8uZXhlYyhzdHJpbmcpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcGFyc2VGbG9hdChwKTsgfSkgOiBbXTtcbn1cblxuLy8gU3ByaW5nIHNvbHZlciBpbnNwaXJlZCBieSBXZWJraXQgQ29weXJpZ2h0IMKpIDIwMTYgQXBwbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBodHRwczovL3dlYmtpdC5vcmcvZGVtb3Mvc3ByaW5nL3NwcmluZy5qc1xuXG5mdW5jdGlvbiBzcHJpbmcoc3RyaW5nLCBkdXJhdGlvbikge1xuXG4gIHZhciBwYXJhbXMgPSBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoc3RyaW5nKTtcbiAgdmFyIG1hc3MgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1swXSkgPyAxIDogcGFyYW1zWzBdLCAuMSwgMTAwKTtcbiAgdmFyIHN0aWZmbmVzcyA9IG1pbk1heChpcy51bmQocGFyYW1zWzFdKSA/IDEwMCA6IHBhcmFtc1sxXSwgLjEsIDEwMCk7XG4gIHZhciBkYW1waW5nID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMl0pID8gMTAgOiBwYXJhbXNbMl0sIC4xLCAxMDApO1xuICB2YXIgdmVsb2NpdHkgPSAgbWluTWF4KGlzLnVuZChwYXJhbXNbM10pID8gMCA6IHBhcmFtc1szXSwgLjEsIDEwMCk7XG4gIHZhciB3MCA9IE1hdGguc3FydChzdGlmZm5lc3MgLyBtYXNzKTtcbiAgdmFyIHpldGEgPSBkYW1waW5nIC8gKDIgKiBNYXRoLnNxcnQoc3RpZmZuZXNzICogbWFzcykpO1xuICB2YXIgd2QgPSB6ZXRhIDwgMSA/IHcwICogTWF0aC5zcXJ0KDEgLSB6ZXRhICogemV0YSkgOiAwO1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gemV0YSA8IDEgPyAoemV0YSAqIHcwICsgLXZlbG9jaXR5KSAvIHdkIDogLXZlbG9jaXR5ICsgdzA7XG5cbiAgZnVuY3Rpb24gc29sdmVyKHQpIHtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkdXJhdGlvbiA/IChkdXJhdGlvbiAqIHQpIC8gMTAwMCA6IHQ7XG4gICAgaWYgKHpldGEgPCAxKSB7XG4gICAgICBwcm9ncmVzcyA9IE1hdGguZXhwKC1wcm9ncmVzcyAqIHpldGEgKiB3MCkgKiAoYSAqIE1hdGguY29zKHdkICogcHJvZ3Jlc3MpICsgYiAqIE1hdGguc2luKHdkICogcHJvZ3Jlc3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ3Jlc3MgPSAoYSArIGIgKiBwcm9ncmVzcykgKiBNYXRoLmV4cCgtcHJvZ3Jlc3MgKiB3MCk7XG4gICAgfVxuICAgIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHsgcmV0dXJuIHQ7IH1cbiAgICByZXR1cm4gMSAtIHByb2dyZXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RHVyYXRpb24oKSB7XG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlLnNwcmluZ3Nbc3RyaW5nXTtcbiAgICBpZiAoY2FjaGVkKSB7IHJldHVybiBjYWNoZWQ7IH1cbiAgICB2YXIgZnJhbWUgPSAxLzY7XG4gICAgdmFyIGVsYXBzZWQgPSAwO1xuICAgIHZhciByZXN0ID0gMDtcbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICBlbGFwc2VkICs9IGZyYW1lO1xuICAgICAgaWYgKHNvbHZlcihlbGFwc2VkKSA9PT0gMSkge1xuICAgICAgICByZXN0Kys7XG4gICAgICAgIGlmIChyZXN0ID49IDE2KSB7IGJyZWFrOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGR1cmF0aW9uID0gZWxhcHNlZCAqIGZyYW1lICogMTAwMDtcbiAgICBjYWNoZS5zcHJpbmdzW3N0cmluZ10gPSBkdXJhdGlvbjtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cblxuICByZXR1cm4gZHVyYXRpb24gPyBzb2x2ZXIgOiBnZXREdXJhdGlvbjtcblxufVxuXG4vLyBCYXNpYyBzdGVwcyBlYXNpbmcgaW1wbGVtZW50YXRpb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZnIvZG9jcy9XZWIvQ1NTL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG5cbmZ1bmN0aW9uIHN0ZXBzKHN0ZXBzKSB7XG4gIGlmICggc3RlcHMgPT09IHZvaWQgMCApIHN0ZXBzID0gMTA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiBNYXRoLmNlaWwoKG1pbk1heCh0LCAwLjAwMDAwMSwgMSkpICogc3RlcHMpICogKDEgLyBzdGVwcyk7IH07XG59XG5cbi8vIEJlemllckVhc2luZyBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmdcblxudmFyIGJlemllciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbiAgdmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcblxuICBmdW5jdGlvbiBBKGFBMSwgYUEyKSB7IHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTEgfVxuICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTEgfVxuICBmdW5jdGlvbiBDKGFBMSkgICAgICB7IHJldHVybiAzLjAgKiBhQTEgfVxuXG4gIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7IHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVCB9XG4gIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikgeyByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKSB9XG5cbiAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gICAgdmFyIGN1cnJlbnRYLCBjdXJyZW50VCwgaSA9IDA7XG4gICAgZG8ge1xuICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBpZiAoY3VycmVudFggPiAwLjApIHsgYUIgPSBjdXJyZW50VDsgfSBlbHNlIHsgYUEgPSBjdXJyZW50VDsgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IDAuMDAwMDAwMSAmJiArK2kgPCAxMCk7XG4gICAgcmV0dXJuIGN1cnJlbnRUO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QsIG1YMSwgbVgyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHsgcmV0dXJuIGFHdWVzc1Q7IH1cbiAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cbiAgICByZXR1cm4gYUd1ZXNzVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcblxuICAgIGlmICghKDAgPD0gbVgxICYmIG1YMSA8PSAxICYmIDAgPD0gbVgyICYmIG1YMiA8PSAxKSkgeyByZXR1cm47IH1cbiAgICB2YXIgc2FtcGxlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKTtcblxuICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcblxuICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwO1xuICAgICAgdmFyIGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgICB9XG5cbiAgICAgIC0tY3VycmVudFNhbXBsZTtcblxuICAgICAgdmFyIGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgICAgdmFyIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgdmFyIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuXG4gICAgICBpZiAoaW5pdGlhbFNsb3BlID49IDAuMDAxKSB7XG4gICAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgeyByZXR1cm4geDsgfVxuICAgICAgaWYgKHggPT09IDAgfHwgeCA9PT0gMSkgeyByZXR1cm4geDsgfVxuICAgICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBiZXppZXI7XG5cbn0pKCk7XG5cbnZhciBwZW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gIC8vIEJhc2VkIG9uIGpRdWVyeSBVSSdzIGltcGxlbWVuYXRpb24gb2YgZWFzaW5nIGVxdWF0aW9ucyBmcm9tIFJvYmVydCBQZW5uZXIgKGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcpXG5cbiAgdmFyIGVhc2VzID0geyBsaW5lYXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9OyB9IH07XG5cbiAgdmFyIGZ1bmN0aW9uRWFzaW5ncyA9IHtcbiAgICBTaW5lOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMik7IH07IH0sXG4gICAgRXhwbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPyBNYXRoLnBvdygyLCAxMCAqIHQgLSAxMCkgOiAwOyB9OyB9LFxuICAgIENpcmM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7IH07IH0sXG4gICAgQmFjazogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0ICogKDMgKiB0IC0gMik7IH07IH0sXG4gICAgQm91bmNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIHBvdzIsIGIgPSA0O1xuICAgICAgd2hpbGUgKHQgPCAoKCBwb3cyID0gTWF0aC5wb3coMiwgLS1iKSkgLSAxKSAvIDExKSB7fVxuICAgICAgcmV0dXJuIDEgLyBNYXRoLnBvdyg0LCAzIC0gYikgLSA3LjU2MjUgKiBNYXRoLnBvdygoIHBvdzIgKiAzIC0gMiApIC8gMjIgLSB0LCAyKVxuICAgIH07IH0sXG4gICAgRWxhc3RpYzogZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgICBpZiAoIGFtcGxpdHVkZSA9PT0gdm9pZCAwICkgYW1wbGl0dWRlID0gMTtcbiAgICAgIGlmICggcGVyaW9kID09PSB2b2lkIDAgKSBwZXJpb2QgPSAuNTtcblxuICAgICAgdmFyIGEgPSBtaW5NYXgoYW1wbGl0dWRlLCAxLCAxMCk7XG4gICAgICB2YXIgcCA9IG1pbk1heChwZXJpb2QsIC4xLCAyKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyB0IDogXG4gICAgICAgICAgLWEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICogTWF0aC5zaW4oKCgodCAtIDEpIC0gKHAgLyAoTWF0aC5QSSAqIDIpICogTWF0aC5hc2luKDEgLyBhKSkpICogKE1hdGguUEkgKiAyKSkgLyBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGJhc2VFYXNpbmdzID0gWydRdWFkJywgJ0N1YmljJywgJ1F1YXJ0JywgJ1F1aW50J107XG5cbiAgYmFzZUVhc2luZ3MuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgaSkge1xuICAgIGZ1bmN0aW9uRWFzaW5nc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiBNYXRoLnBvdyh0LCBpICsgMik7IH07IH07XG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKGZ1bmN0aW9uRWFzaW5ncykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBlYXNlSW4gPSBmdW5jdGlvbkVhc2luZ3NbbmFtZV07XG4gICAgZWFzZXNbJ2Vhc2VJbicgKyBuYW1lXSA9IGVhc2VJbjtcbiAgICBlYXNlc1snZWFzZU91dCcgKyBuYW1lXSA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtIGVhc2VJbihhLCBiKSgxIC0gdCk7IH07IH07XG4gICAgZWFzZXNbJ2Vhc2VJbk91dCcgKyBuYW1lXSA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA8IDAuNSA/IGVhc2VJbihhLCBiKSh0ICogMikgLyAyIDogXG4gICAgICAxIC0gZWFzZUluKGEsIGIpKHQgKiAtMiArIDIpIC8gMjsgfTsgfTtcbiAgICBlYXNlc1snZWFzZU91dEluJyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgMC41ID8gKDEgLSBlYXNlSW4oYSwgYikoMSAtIHQgKiAyKSkgLyAyIDogXG4gICAgICAoZWFzZUluKGEsIGIpKHQgKiAyIC0gMSkgKyAxKSAvIDI7IH07IH07XG4gIH0pO1xuXG4gIHJldHVybiBlYXNlcztcblxufSkoKTtcblxuZnVuY3Rpb24gcGFyc2VFYXNpbmdzKGVhc2luZywgZHVyYXRpb24pIHtcbiAgaWYgKGlzLmZuYyhlYXNpbmcpKSB7IHJldHVybiBlYXNpbmc7IH1cbiAgdmFyIG5hbWUgPSBlYXNpbmcuc3BsaXQoJygnKVswXTtcbiAgdmFyIGVhc2UgPSBwZW5uZXJbbmFtZV07XG4gIHZhciBhcmdzID0gcGFyc2VFYXNpbmdQYXJhbWV0ZXJzKGVhc2luZyk7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ3NwcmluZycgOiByZXR1cm4gc3ByaW5nKGVhc2luZywgZHVyYXRpb24pO1xuICAgIGNhc2UgJ2N1YmljQmV6aWVyJyA6IHJldHVybiBhcHBseUFyZ3VtZW50cyhiZXppZXIsIGFyZ3MpO1xuICAgIGNhc2UgJ3N0ZXBzJyA6IHJldHVybiBhcHBseUFyZ3VtZW50cyhzdGVwcywgYXJncyk7XG4gICAgZGVmYXVsdCA6IHJldHVybiBhcHBseUFyZ3VtZW50cyhlYXNlLCBhcmdzKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdzXG5cbmZ1bmN0aW9uIHNlbGVjdFN0cmluZyhzdHIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHN0cik7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLy8gQXJyYXlzXG5cbmZ1bmN0aW9uIGZpbHRlckFycmF5KGFyciwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaSBpbiBhcnIpIHtcbiAgICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWwsIGksIGFycikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkFycmF5KGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoaXMuYXJyKGIpID8gZmxhdHRlbkFycmF5KGIpIDogYik7IH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShvKSB7XG4gIGlmIChpcy5hcnIobykpIHsgcmV0dXJuIG87IH1cbiAgaWYgKGlzLnN0cihvKSkgeyBvID0gc2VsZWN0U3RyaW5nKG8pIHx8IG87IH1cbiAgaWYgKG8gaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBvIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24pIHsgcmV0dXJuIFtdLnNsaWNlLmNhbGwobyk7IH1cbiAgcmV0dXJuIFtvXTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgPT09IHZhbDsgfSk7XG59XG5cbi8vIE9iamVjdHNcblxuZnVuY3Rpb24gY2xvbmVPYmplY3Qobykge1xuICB2YXIgY2xvbmUgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBvKSB7IGNsb25lW3BdID0gb1twXTsgfVxuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VPYmplY3RQcm9wcyhvMSwgbzIpIHtcbiAgdmFyIG8gPSBjbG9uZU9iamVjdChvMSk7XG4gIGZvciAodmFyIHAgaW4gbzEpIHsgb1twXSA9IG8yLmhhc093blByb3BlcnR5KHApID8gbzJbcF0gOiBvMVtwXTsgfVxuICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG8xLCBvMikge1xuICB2YXIgbyA9IGNsb25lT2JqZWN0KG8xKTtcbiAgZm9yICh2YXIgcCBpbiBvMikgeyBvW3BdID0gaXMudW5kKG8xW3BdKSA/IG8yW3BdIDogbzFbcF07IH1cbiAgcmV0dXJuIG87XG59XG5cbi8vIENvbG9yc1xuXG5mdW5jdGlvbiByZ2JUb1JnYmEocmdiVmFsdWUpIHtcbiAgdmFyIHJnYiA9IC9yZ2JcXCgoXFxkKyxcXHMqW1xcZF0rLFxccypbXFxkXSspXFwpL2cuZXhlYyhyZ2JWYWx1ZSk7XG4gIHJldHVybiByZ2IgPyAoXCJyZ2JhKFwiICsgKHJnYlsxXSkgKyBcIiwxKVwiKSA6IHJnYlZhbHVlO1xufVxuXG5mdW5jdGlvbiBoZXhUb1JnYmEoaGV4VmFsdWUpIHtcbiAgdmFyIHJneCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gIHZhciBoZXggPSBoZXhWYWx1ZS5yZXBsYWNlKHJneCwgZnVuY3Rpb24gKG0sIHIsIGcsIGIpIHsgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjsgfSApO1xuICB2YXIgcmdiID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XG4gIHZhciByID0gcGFyc2VJbnQocmdiWzFdLCAxNik7XG4gIHZhciBnID0gcGFyc2VJbnQocmdiWzJdLCAxNik7XG4gIHZhciBiID0gcGFyc2VJbnQocmdiWzNdLCAxNik7XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLDEpXCIpO1xufVxuXG5mdW5jdGlvbiBoc2xUb1JnYmEoaHNsVmFsdWUpIHtcbiAgdmFyIGhzbCA9IC9oc2xcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSVcXCkvZy5leGVjKGhzbFZhbHVlKSB8fCAvaHNsYVxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspXFwpL2cuZXhlYyhoc2xWYWx1ZSk7XG4gIHZhciBoID0gcGFyc2VJbnQoaHNsWzFdLCAxMCkgLyAzNjA7XG4gIHZhciBzID0gcGFyc2VJbnQoaHNsWzJdLCAxMCkgLyAxMDA7XG4gIHZhciBsID0gcGFyc2VJbnQoaHNsWzNdLCAxMCkgLyAxMDA7XG4gIHZhciBhID0gaHNsWzRdIHx8IDE7XG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkgeyB0ICs9IDE7IH1cbiAgICBpZiAodCA+IDEpIHsgdCAtPSAxOyB9XG4gICAgaWYgKHQgPCAxLzYpIHsgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7IH1cbiAgICBpZiAodCA8IDEvMikgeyByZXR1cm4gcTsgfVxuICAgIGlmICh0IDwgMi8zKSB7IHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7IH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICB2YXIgciwgZywgYjtcbiAgaWYgKHMgPT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xuICB9XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgKHIgKiAyNTUpICsgXCIsXCIgKyAoZyAqIDI1NSkgKyBcIixcIiArIChiICogMjU1KSArIFwiLFwiICsgYSArIFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gY29sb3JUb1JnYih2YWwpIHtcbiAgaWYgKGlzLnJnYih2YWwpKSB7IHJldHVybiByZ2JUb1JnYmEodmFsKTsgfVxuICBpZiAoaXMuaGV4KHZhbCkpIHsgcmV0dXJuIGhleFRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oc2wodmFsKSkgeyByZXR1cm4gaHNsVG9SZ2JhKHZhbCk7IH1cbn1cblxuLy8gVW5pdHNcblxuZnVuY3Rpb24gZ2V0VW5pdCh2YWwpIHtcbiAgdmFyIHNwbGl0ID0gL1srLV0/XFxkKlxcLj9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/KCV8cHh8cHR8ZW18cmVtfGlufGNtfG1tfGV4fGNofHBjfHZ3fHZofHZtaW58dm1heHxkZWd8cmFkfHR1cm4pPyQvLmV4ZWModmFsKTtcbiAgaWYgKHNwbGl0KSB7IHJldHVybiBzcGxpdFsxXTsgfVxufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1Vbml0KHByb3BOYW1lKSB7XG4gIGlmIChzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3RyYW5zbGF0ZScpIHx8IHByb3BOYW1lID09PSAncGVyc3BlY3RpdmUnKSB7IHJldHVybiAncHgnOyB9XG4gIGlmIChzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3JvdGF0ZScpIHx8IHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAnc2tldycpKSB7IHJldHVybiAnZGVnJzsgfVxufVxuXG4vLyBWYWx1ZXNcblxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25WYWx1ZSh2YWwsIGFuaW1hdGFibGUpIHtcbiAgaWYgKCFpcy5mbmModmFsKSkgeyByZXR1cm4gdmFsOyB9XG4gIHJldHVybiB2YWwoYW5pbWF0YWJsZS50YXJnZXQsIGFuaW1hdGFibGUuaWQsIGFuaW1hdGFibGUudG90YWwpO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWwsIHByb3ApIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShwcm9wKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkge1xuICB2YXIgdmFsdWVVbml0ID0gZ2V0VW5pdCh2YWx1ZSk7XG4gIGlmIChhcnJheUNvbnRhaW5zKFt1bml0LCAnZGVnJywgJ3JhZCcsICd0dXJuJ10sIHZhbHVlVW5pdCkpIHsgcmV0dXJuIHZhbHVlOyB9XG4gIHZhciBjYWNoZWQgPSBjYWNoZS5DU1NbdmFsdWUgKyB1bml0XTtcbiAgaWYgKCFpcy51bmQoY2FjaGVkKSkgeyByZXR1cm4gY2FjaGVkOyB9XG4gIHZhciBiYXNlbGluZSA9IDEwMDtcbiAgdmFyIHRlbXBFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwudGFnTmFtZSk7XG4gIHZhciBwYXJlbnRFbCA9IChlbC5wYXJlbnROb2RlICYmIChlbC5wYXJlbnROb2RlICE9PSBkb2N1bWVudCkpID8gZWwucGFyZW50Tm9kZSA6IGRvY3VtZW50LmJvZHk7XG4gIHBhcmVudEVsLmFwcGVuZENoaWxkKHRlbXBFbCk7XG4gIHRlbXBFbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHRlbXBFbC5zdHlsZS53aWR0aCA9IGJhc2VsaW5lICsgdW5pdDtcbiAgdmFyIGZhY3RvciA9IGJhc2VsaW5lIC8gdGVtcEVsLm9mZnNldFdpZHRoO1xuICBwYXJlbnRFbC5yZW1vdmVDaGlsZCh0ZW1wRWwpO1xuICB2YXIgY29udmVydGVkVW5pdCA9IGZhY3RvciAqIHBhcnNlRmxvYXQodmFsdWUpO1xuICBjYWNoZS5DU1NbdmFsdWUgKyB1bml0XSA9IGNvbnZlcnRlZFVuaXQ7XG4gIHJldHVybiBjb252ZXJ0ZWRVbml0O1xufVxuXG5mdW5jdGlvbiBnZXRDU1NWYWx1ZShlbCwgcHJvcCwgdW5pdCkge1xuICBpZiAocHJvcCBpbiBlbC5zdHlsZSkge1xuICAgIHZhciB1cHBlcmNhc2VQcm9wTmFtZSA9IHByb3AucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdmFsdWUgPSBlbC5zdHlsZVtwcm9wXSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHVwcGVyY2FzZVByb3BOYW1lKSB8fCAnMCc7XG4gICAgcmV0dXJuIHVuaXQgPyBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSA6IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGlvblR5cGUoZWwsIHByb3ApIHtcbiAgaWYgKGlzLmRvbShlbCkgJiYgIWlzLmlucChlbCkgJiYgKCFpcy5uaWwoZ2V0QXR0cmlidXRlKGVsLCBwcm9wKSkgfHwgKGlzLnN2ZyhlbCkgJiYgZWxbcHJvcF0pKSkgeyByZXR1cm4gJ2F0dHJpYnV0ZSc7IH1cbiAgaWYgKGlzLmRvbShlbCkgJiYgYXJyYXlDb250YWlucyh2YWxpZFRyYW5zZm9ybXMsIHByb3ApKSB7IHJldHVybiAndHJhbnNmb3JtJzsgfVxuICBpZiAoaXMuZG9tKGVsKSAmJiAocHJvcCAhPT0gJ3RyYW5zZm9ybScgJiYgZ2V0Q1NTVmFsdWUoZWwsIHByb3ApKSkgeyByZXR1cm4gJ2Nzcyc7IH1cbiAgaWYgKGVsW3Byb3BdICE9IG51bGwpIHsgcmV0dXJuICdvYmplY3QnOyB9XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRUcmFuc2Zvcm1zKGVsKSB7XG4gIGlmICghaXMuZG9tKGVsKSkgeyByZXR1cm47IH1cbiAgdmFyIHN0ciA9IGVsLnN0eWxlLnRyYW5zZm9ybSB8fCAnJztcbiAgdmFyIHJlZyAgPSAvKFxcdyspXFwoKFteKV0qKVxcKS9nO1xuICB2YXIgdHJhbnNmb3JtcyA9IG5ldyBNYXAoKTtcbiAgdmFyIG07IHdoaWxlIChtID0gcmVnLmV4ZWMoc3RyKSkgeyB0cmFuc2Zvcm1zLnNldChtWzFdLCBtWzJdKTsgfVxuICByZXR1cm4gdHJhbnNmb3Jtcztcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVmFsdWUoZWwsIHByb3BOYW1lLCBhbmltYXRhYmxlLCB1bml0KSB7XG4gIHZhciBkZWZhdWx0VmFsID0gc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdzY2FsZScpID8gMSA6IDAgKyBnZXRUcmFuc2Zvcm1Vbml0KHByb3BOYW1lKTtcbiAgdmFyIHZhbHVlID0gZ2V0RWxlbWVudFRyYW5zZm9ybXMoZWwpLmdldChwcm9wTmFtZSkgfHwgZGVmYXVsdFZhbDtcbiAgaWYgKGFuaW1hdGFibGUpIHtcbiAgICBhbmltYXRhYmxlLnRyYW5zZm9ybXMubGlzdC5zZXQocHJvcE5hbWUsIHZhbHVlKTtcbiAgICBhbmltYXRhYmxlLnRyYW5zZm9ybXNbJ2xhc3QnXSA9IHByb3BOYW1lO1xuICB9XG4gIHJldHVybiB1bml0ID8gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB1bml0LCBhbmltYXRhYmxlKSB7XG4gIHN3aXRjaCAoZ2V0QW5pbWF0aW9uVHlwZSh0YXJnZXQsIHByb3BOYW1lKSkge1xuICAgIGNhc2UgJ3RyYW5zZm9ybSc6IHJldHVybiBnZXRUcmFuc2Zvcm1WYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCBhbmltYXRhYmxlLCB1bml0KTtcbiAgICBjYXNlICdjc3MnOiByZXR1cm4gZ2V0Q1NTVmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgdW5pdCk7XG4gICAgY2FzZSAnYXR0cmlidXRlJzogcmV0dXJuIGdldEF0dHJpYnV0ZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gdGFyZ2V0W3Byb3BOYW1lXSB8fCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlVmFsdWUodG8sIGZyb20pIHtcbiAgdmFyIG9wZXJhdG9yID0gL14oXFwqPXxcXCs9fC09KS8uZXhlYyh0byk7XG4gIGlmICghb3BlcmF0b3IpIHsgcmV0dXJuIHRvOyB9XG4gIHZhciB1ID0gZ2V0VW5pdCh0bykgfHwgMDtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KGZyb20pO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQodG8ucmVwbGFjZShvcGVyYXRvclswXSwgJycpKTtcbiAgc3dpdGNoIChvcGVyYXRvclswXVswXSkge1xuICAgIGNhc2UgJysnOiByZXR1cm4geCArIHkgKyB1O1xuICAgIGNhc2UgJy0nOiByZXR1cm4geCAtIHkgKyB1O1xuICAgIGNhc2UgJyonOiByZXR1cm4geCAqIHkgKyB1O1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVmFsdWUodmFsLCB1bml0KSB7XG4gIGlmIChpcy5jb2wodmFsKSkgeyByZXR1cm4gY29sb3JUb1JnYih2YWwpOyB9XG4gIGlmICgvXFxzL2cudGVzdCh2YWwpKSB7IHJldHVybiB2YWw7IH1cbiAgdmFyIG9yaWdpbmFsVW5pdCA9IGdldFVuaXQodmFsKTtcbiAgdmFyIHVuaXRMZXNzID0gb3JpZ2luYWxVbml0ID8gdmFsLnN1YnN0cigwLCB2YWwubGVuZ3RoIC0gb3JpZ2luYWxVbml0Lmxlbmd0aCkgOiB2YWw7XG4gIGlmICh1bml0KSB7IHJldHVybiB1bml0TGVzcyArIHVuaXQ7IH1cbiAgcmV0dXJuIHVuaXRMZXNzO1xufVxuXG4vLyBnZXRUb3RhbExlbmd0aCgpIGVxdWl2YWxlbnQgZm9yIGNpcmNsZSwgcmVjdCwgcG9seWxpbmUsIHBvbHlnb24gYW5kIGxpbmUgc2hhcGVzXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vU2ViTGFtYmxhLzNlMDU1MGM0OTZjMjM2NzA5NzQ0XG5cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAyLnggLSBwMS54LCAyKSArIE1hdGgucG93KHAyLnkgLSBwMS55LCAyKSk7XG59XG5cbmZ1bmN0aW9uIGdldENpcmNsZUxlbmd0aChlbCkge1xuICByZXR1cm4gTWF0aC5QSSAqIDIgKiBnZXRBdHRyaWJ1dGUoZWwsICdyJyk7XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIChnZXRBdHRyaWJ1dGUoZWwsICd3aWR0aCcpICogMikgKyAoZ2V0QXR0cmlidXRlKGVsLCAnaGVpZ2h0JykgKiAyKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZUxlbmd0aChlbCkge1xuICByZXR1cm4gZ2V0RGlzdGFuY2UoXG4gICAge3g6IGdldEF0dHJpYnV0ZShlbCwgJ3gxJyksIHk6IGdldEF0dHJpYnV0ZShlbCwgJ3kxJyl9LCBcbiAgICB7eDogZ2V0QXR0cmlidXRlKGVsLCAneDInKSwgeTogZ2V0QXR0cmlidXRlKGVsLCAneTInKX1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9seWxpbmVMZW5ndGgoZWwpIHtcbiAgdmFyIHBvaW50cyA9IGVsLnBvaW50cztcbiAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcbiAgdmFyIHByZXZpb3VzUG9zO1xuICBmb3IgKHZhciBpID0gMCA7IGkgPCBwb2ludHMubnVtYmVyT2ZJdGVtczsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSBwb2ludHMuZ2V0SXRlbShpKTtcbiAgICBpZiAoaSA+IDApIHsgdG90YWxMZW5ndGggKz0gZ2V0RGlzdGFuY2UocHJldmlvdXNQb3MsIGN1cnJlbnRQb3MpOyB9XG4gICAgcHJldmlvdXNQb3MgPSBjdXJyZW50UG9zO1xuICB9XG4gIHJldHVybiB0b3RhbExlbmd0aDtcbn1cblxuZnVuY3Rpb24gZ2V0UG9seWdvbkxlbmd0aChlbCkge1xuICB2YXIgcG9pbnRzID0gZWwucG9pbnRzO1xuICByZXR1cm4gZ2V0UG9seWxpbmVMZW5ndGgoZWwpICsgZ2V0RGlzdGFuY2UocG9pbnRzLmdldEl0ZW0ocG9pbnRzLm51bWJlck9mSXRlbXMgLSAxKSwgcG9pbnRzLmdldEl0ZW0oMCkpO1xufVxuXG4vLyBQYXRoIGFuaW1hdGlvblxuXG5mdW5jdGlvbiBnZXRUb3RhbExlbmd0aChlbCkge1xuICBpZiAoZWwuZ2V0VG90YWxMZW5ndGgpIHsgcmV0dXJuIGVsLmdldFRvdGFsTGVuZ3RoKCk7IH1cbiAgc3dpdGNoKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2NpcmNsZSc6IHJldHVybiBnZXRDaXJjbGVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3JlY3QnOiByZXR1cm4gZ2V0UmVjdExlbmd0aChlbCk7XG4gICAgY2FzZSAnbGluZSc6IHJldHVybiBnZXRMaW5lTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdwb2x5bGluZSc6IHJldHVybiBnZXRQb2x5bGluZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncG9seWdvbic6IHJldHVybiBnZXRQb2x5Z29uTGVuZ3RoKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXREYXNob2Zmc2V0KGVsKSB7XG4gIHZhciBwYXRoTGVuZ3RoID0gZ2V0VG90YWxMZW5ndGgoZWwpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBwYXRoTGVuZ3RoKTtcbiAgcmV0dXJuIHBhdGhMZW5ndGg7XG59XG5cbi8vIE1vdGlvbiBwYXRoXG5cbmZ1bmN0aW9uIGdldFBhcmVudFN2Z0VsKGVsKSB7XG4gIHZhciBwYXJlbnRFbCA9IGVsLnBhcmVudE5vZGU7XG4gIHdoaWxlIChpcy5zdmcocGFyZW50RWwpKSB7XG4gICAgaWYgKCFpcy5zdmcocGFyZW50RWwucGFyZW50Tm9kZSkpIHsgYnJlYWs7IH1cbiAgICBwYXJlbnRFbCA9IHBhcmVudEVsLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHBhcmVudEVsO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdmcocGF0aEVsLCBzdmdEYXRhKSB7XG4gIHZhciBzdmcgPSBzdmdEYXRhIHx8IHt9O1xuICB2YXIgcGFyZW50U3ZnRWwgPSBzdmcuZWwgfHwgZ2V0UGFyZW50U3ZnRWwocGF0aEVsKTtcbiAgdmFyIHJlY3QgPSBwYXJlbnRTdmdFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHZpZXdCb3hBdHRyID0gZ2V0QXR0cmlidXRlKHBhcmVudFN2Z0VsLCAndmlld0JveCcpO1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciB2aWV3Qm94ID0gc3ZnLnZpZXdCb3ggfHwgKHZpZXdCb3hBdHRyID8gdmlld0JveEF0dHIuc3BsaXQoJyAnKSA6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XG4gIHJldHVybiB7XG4gICAgZWw6IHBhcmVudFN2Z0VsLFxuICAgIHZpZXdCb3g6IHZpZXdCb3gsXG4gICAgeDogdmlld0JveFswXSAvIDEsXG4gICAgeTogdmlld0JveFsxXSAvIDEsXG4gICAgdzogd2lkdGgsXG4gICAgaDogaGVpZ2h0LFxuICAgIHZXOiB2aWV3Qm94WzJdLFxuICAgIHZIOiB2aWV3Qm94WzNdXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGF0aChwYXRoLCBwZXJjZW50KSB7XG4gIHZhciBwYXRoRWwgPSBpcy5zdHIocGF0aCkgPyBzZWxlY3RTdHJpbmcocGF0aClbMF0gOiBwYXRoO1xuICB2YXIgcCA9IHBlcmNlbnQgfHwgMTAwO1xuICByZXR1cm4gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgZWw6IHBhdGhFbCxcbiAgICAgIHN2ZzogZ2V0UGFyZW50U3ZnKHBhdGhFbCksXG4gICAgICB0b3RhbExlbmd0aDogZ2V0VG90YWxMZW5ndGgocGF0aEVsKSAqIChwIC8gMTAwKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoUHJvZ3Jlc3MocGF0aCwgcHJvZ3Jlc3MsIGlzUGF0aFRhcmdldEluc2lkZVNWRykge1xuICBmdW5jdGlvbiBwb2ludChvZmZzZXQpIHtcbiAgICBpZiAoIG9mZnNldCA9PT0gdm9pZCAwICkgb2Zmc2V0ID0gMDtcblxuICAgIHZhciBsID0gcHJvZ3Jlc3MgKyBvZmZzZXQgPj0gMSA/IHByb2dyZXNzICsgb2Zmc2V0IDogMDtcbiAgICByZXR1cm4gcGF0aC5lbC5nZXRQb2ludEF0TGVuZ3RoKGwpO1xuICB9XG4gIHZhciBzdmcgPSBnZXRQYXJlbnRTdmcocGF0aC5lbCwgcGF0aC5zdmcpO1xuICB2YXIgcCA9IHBvaW50KCk7XG4gIHZhciBwMCA9IHBvaW50KC0xKTtcbiAgdmFyIHAxID0gcG9pbnQoKzEpO1xuICB2YXIgc2NhbGVYID0gaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHID8gMSA6IHN2Zy53IC8gc3ZnLnZXO1xuICB2YXIgc2NhbGVZID0gaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHID8gMSA6IHN2Zy5oIC8gc3ZnLnZIO1xuICBzd2l0Y2ggKHBhdGgucHJvcGVydHkpIHtcbiAgICBjYXNlICd4JzogcmV0dXJuIChwLnggLSBzdmcueCkgKiBzY2FsZVg7XG4gICAgY2FzZSAneSc6IHJldHVybiAocC55IC0gc3ZnLnkpICogc2NhbGVZO1xuICAgIGNhc2UgJ2FuZ2xlJzogcmV0dXJuIE1hdGguYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KSAqIDE4MCAvIE1hdGguUEk7XG4gIH1cbn1cblxuLy8gRGVjb21wb3NlIHZhbHVlXG5cbmZ1bmN0aW9uIGRlY29tcG9zZVZhbHVlKHZhbCwgdW5pdCkge1xuICAvLyBjb25zdCByZ3ggPSAvLT9cXGQqXFwuP1xcZCsvZzsgLy8gaGFuZGxlcyBiYXNpYyBudW1iZXJzXG4gIC8vIGNvbnN0IHJneCA9IC9bKy1dP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8vZzsgLy8gaGFuZGxlcyBleHBvbmVudHMgbm90YXRpb25cbiAgdmFyIHJneCA9IC9bKy1dP1xcZCpcXC4/XFxkKyg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPy9nOyAvLyBoYW5kbGVzIGV4cG9uZW50cyBub3RhdGlvblxuICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVZhbHVlKChpcy5wdGgodmFsKSA/IHZhbC50b3RhbExlbmd0aCA6IHZhbCksIHVuaXQpICsgJyc7XG4gIHJldHVybiB7XG4gICAgb3JpZ2luYWw6IHZhbHVlLFxuICAgIG51bWJlcnM6IHZhbHVlLm1hdGNoKHJneCkgPyB2YWx1ZS5tYXRjaChyZ3gpLm1hcChOdW1iZXIpIDogWzBdLFxuICAgIHN0cmluZ3M6IChpcy5zdHIodmFsKSB8fCB1bml0KSA/IHZhbHVlLnNwbGl0KHJneCkgOiBbXVxuICB9XG59XG5cbi8vIEFuaW1hdGFibGVzXG5cbmZ1bmN0aW9uIHBhcnNlVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXRzQXJyYXkgPSB0YXJnZXRzID8gKGZsYXR0ZW5BcnJheShpcy5hcnIodGFyZ2V0cykgPyB0YXJnZXRzLm1hcCh0b0FycmF5KSA6IHRvQXJyYXkodGFyZ2V0cykpKSA6IFtdO1xuICByZXR1cm4gZmlsdGVyQXJyYXkodGFyZ2V0c0FycmF5LCBmdW5jdGlvbiAoaXRlbSwgcG9zLCBzZWxmKSB7IHJldHVybiBzZWxmLmluZGV4T2YoaXRlbSkgPT09IHBvczsgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVzKHRhcmdldHMpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgcmV0dXJuIHBhcnNlZC5tYXAoZnVuY3Rpb24gKHQsIGkpIHtcbiAgICByZXR1cm4ge3RhcmdldDogdCwgaWQ6IGksIHRvdGFsOiBwYXJzZWQubGVuZ3RoLCB0cmFuc2Zvcm1zOiB7IGxpc3Q6IGdldEVsZW1lbnRUcmFuc2Zvcm1zKHQpIH0gfTtcbiAgfSk7XG59XG5cbi8vIFByb3BlcnRpZXNcblxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHlUd2VlbnMocHJvcCwgdHdlZW5TZXR0aW5ncykge1xuICB2YXIgc2V0dGluZ3MgPSBjbG9uZU9iamVjdCh0d2VlblNldHRpbmdzKTtcbiAgLy8gT3ZlcnJpZGUgZHVyYXRpb24gaWYgZWFzaW5nIGlzIGEgc3ByaW5nXG4gIGlmICgvXnNwcmluZy8udGVzdChzZXR0aW5ncy5lYXNpbmcpKSB7IHNldHRpbmdzLmR1cmF0aW9uID0gc3ByaW5nKHNldHRpbmdzLmVhc2luZyk7IH1cbiAgaWYgKGlzLmFycihwcm9wKSkge1xuICAgIHZhciBsID0gcHJvcC5sZW5ndGg7XG4gICAgdmFyIGlzRnJvbVRvID0gKGwgPT09IDIgJiYgIWlzLm9iaihwcm9wWzBdKSk7XG4gICAgaWYgKCFpc0Zyb21Ubykge1xuICAgICAgLy8gRHVyYXRpb24gZGl2aWRlZCBieSB0aGUgbnVtYmVyIG9mIHR3ZWVuc1xuICAgICAgaWYgKCFpcy5mbmModHdlZW5TZXR0aW5ncy5kdXJhdGlvbikpIHsgc2V0dGluZ3MuZHVyYXRpb24gPSB0d2VlblNldHRpbmdzLmR1cmF0aW9uIC8gbDsgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmFuc2Zvcm0gW2Zyb20sIHRvXSB2YWx1ZXMgc2hvcnRoYW5kIHRvIGEgdmFsaWQgdHdlZW4gdmFsdWVcbiAgICAgIHByb3AgPSB7dmFsdWU6IHByb3B9O1xuICAgIH1cbiAgfVxuICB2YXIgcHJvcEFycmF5ID0gaXMuYXJyKHByb3ApID8gcHJvcCA6IFtwcm9wXTtcbiAgcmV0dXJuIHByb3BBcnJheS5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICB2YXIgb2JqID0gKGlzLm9iaih2KSAmJiAhaXMucHRoKHYpKSA/IHYgOiB7dmFsdWU6IHZ9O1xuICAgIC8vIERlZmF1bHQgZGVsYXkgdmFsdWUgc2hvdWxkIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgZmlyc3QgdHdlZW5cbiAgICBpZiAoaXMudW5kKG9iai5kZWxheSkpIHsgb2JqLmRlbGF5ID0gIWkgPyB0d2VlblNldHRpbmdzLmRlbGF5IDogMDsgfVxuICAgIC8vIERlZmF1bHQgZW5kRGVsYXkgdmFsdWUgc2hvdWxkIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgbGFzdCB0d2VlblxuICAgIGlmIChpcy51bmQob2JqLmVuZERlbGF5KSkgeyBvYmouZW5kRGVsYXkgPSBpID09PSBwcm9wQXJyYXkubGVuZ3RoIC0gMSA/IHR3ZWVuU2V0dGluZ3MuZW5kRGVsYXkgOiAwOyB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSkubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBtZXJnZU9iamVjdHMoaywgc2V0dGluZ3MpOyB9KTtcbn1cblxuXG5mdW5jdGlvbiBmbGF0dGVuS2V5ZnJhbWVzKGtleWZyYW1lcykge1xuICB2YXIgcHJvcGVydHlOYW1lcyA9IGZpbHRlckFycmF5KGZsYXR0ZW5BcnJheShrZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIE9iamVjdC5rZXlzKGtleSk7IH0pKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIGlzLmtleShwKTsgfSlcbiAgLnJlZHVjZShmdW5jdGlvbiAoYSxiKSB7IGlmIChhLmluZGV4T2YoYikgPCAwKSB7IGEucHVzaChiKTsgfSByZXR1cm4gYTsgfSwgW10pO1xuICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eU5hbWVzW2ldO1xuICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0ga2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbmV3S2V5ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGtleSkge1xuICAgICAgICBpZiAoaXMua2V5KHApKSB7XG4gICAgICAgICAgaWYgKHAgPT0gcHJvcE5hbWUpIHsgbmV3S2V5LnZhbHVlID0ga2V5W3BdOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3S2V5W3BdID0ga2V5W3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3S2V5O1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykgbG9vcCggaSApO1xuICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllcyh0d2VlblNldHRpbmdzLCBwYXJhbXMpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSBbXTtcbiAgdmFyIGtleWZyYW1lcyA9IHBhcmFtcy5rZXlmcmFtZXM7XG4gIGlmIChrZXlmcmFtZXMpIHsgcGFyYW1zID0gbWVyZ2VPYmplY3RzKGZsYXR0ZW5LZXlmcmFtZXMoa2V5ZnJhbWVzKSwgcGFyYW1zKTsgfVxuICBmb3IgKHZhciBwIGluIHBhcmFtcykge1xuICAgIGlmIChpcy5rZXkocCkpIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IHAsXG4gICAgICAgIHR3ZWVuczogbm9ybWFsaXplUHJvcGVydHlUd2VlbnMocGFyYW1zW3BdLCB0d2VlblNldHRpbmdzKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG4vLyBUd2VlbnNcblxuZnVuY3Rpb24gbm9ybWFsaXplVHdlZW5WYWx1ZXModHdlZW4sIGFuaW1hdGFibGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiB0d2Vlbikge1xuICAgIHZhciB2YWx1ZSA9IGdldEZ1bmN0aW9uVmFsdWUodHdlZW5bcF0sIGFuaW1hdGFibGUpO1xuICAgIGlmIChpcy5hcnIodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZ2V0RnVuY3Rpb25WYWx1ZSh2LCBhbmltYXRhYmxlKTsgfSk7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7IHZhbHVlID0gdmFsdWVbMF07IH1cbiAgICB9XG4gICAgdFtwXSA9IHZhbHVlO1xuICB9XG4gIHQuZHVyYXRpb24gPSBwYXJzZUZsb2F0KHQuZHVyYXRpb24pO1xuICB0LmRlbGF5ID0gcGFyc2VGbG9hdCh0LmRlbGF5KTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3ZWVucyhwcm9wLCBhbmltYXRhYmxlKSB7XG4gIHZhciBwcmV2aW91c1R3ZWVuO1xuICByZXR1cm4gcHJvcC50d2VlbnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHR3ZWVuID0gbm9ybWFsaXplVHdlZW5WYWx1ZXModCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIHR3ZWVuVmFsdWUgPSB0d2Vlbi52YWx1ZTtcbiAgICB2YXIgdG8gPSBpcy5hcnIodHdlZW5WYWx1ZSkgPyB0d2VlblZhbHVlWzFdIDogdHdlZW5WYWx1ZTtcbiAgICB2YXIgdG9Vbml0ID0gZ2V0VW5pdCh0byk7XG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKGFuaW1hdGFibGUudGFyZ2V0LCBwcm9wLm5hbWUsIHRvVW5pdCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1R3ZWVuID8gcHJldmlvdXNUd2Vlbi50by5vcmlnaW5hbCA6IG9yaWdpbmFsVmFsdWU7XG4gICAgdmFyIGZyb20gPSBpcy5hcnIodHdlZW5WYWx1ZSkgPyB0d2VlblZhbHVlWzBdIDogcHJldmlvdXNWYWx1ZTtcbiAgICB2YXIgZnJvbVVuaXQgPSBnZXRVbml0KGZyb20pIHx8IGdldFVuaXQob3JpZ2luYWxWYWx1ZSk7XG4gICAgdmFyIHVuaXQgPSB0b1VuaXQgfHwgZnJvbVVuaXQ7XG4gICAgaWYgKGlzLnVuZCh0bykpIHsgdG8gPSBwcmV2aW91c1ZhbHVlOyB9XG4gICAgdHdlZW4uZnJvbSA9IGRlY29tcG9zZVZhbHVlKGZyb20sIHVuaXQpO1xuICAgIHR3ZWVuLnRvID0gZGVjb21wb3NlVmFsdWUoZ2V0UmVsYXRpdmVWYWx1ZSh0bywgZnJvbSksIHVuaXQpO1xuICAgIHR3ZWVuLnN0YXJ0ID0gcHJldmlvdXNUd2VlbiA/IHByZXZpb3VzVHdlZW4uZW5kIDogMDtcbiAgICB0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydCArIHR3ZWVuLmRlbGF5ICsgdHdlZW4uZHVyYXRpb24gKyB0d2Vlbi5lbmREZWxheTtcbiAgICB0d2Vlbi5lYXNpbmcgPSBwYXJzZUVhc2luZ3ModHdlZW4uZWFzaW5nLCB0d2Vlbi5kdXJhdGlvbik7XG4gICAgdHdlZW4uaXNQYXRoID0gaXMucHRoKHR3ZWVuVmFsdWUpO1xuICAgIHR3ZWVuLmlzUGF0aFRhcmdldEluc2lkZVNWRyA9IHR3ZWVuLmlzUGF0aCAmJiBpcy5zdmcoYW5pbWF0YWJsZS50YXJnZXQpO1xuICAgIHR3ZWVuLmlzQ29sb3IgPSBpcy5jb2wodHdlZW4uZnJvbS5vcmlnaW5hbCk7XG4gICAgaWYgKHR3ZWVuLmlzQ29sb3IpIHsgdHdlZW4ucm91bmQgPSAxOyB9XG4gICAgcHJldmlvdXNUd2VlbiA9IHR3ZWVuO1xuICAgIHJldHVybiB0d2VlbjtcbiAgfSk7XG59XG5cbi8vIFR3ZWVuIHByb2dyZXNzXG5cbnZhciBzZXRQcm9ncmVzc1ZhbHVlID0ge1xuICBjc3M6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0LnN0eWxlW3BdID0gdjsgfSxcbiAgYXR0cmlidXRlOiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdC5zZXRBdHRyaWJ1dGUocCwgdik7IH0sXG4gIG9iamVjdDogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHRbcF0gPSB2OyB9LFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uICh0LCBwLCB2LCB0cmFuc2Zvcm1zLCBtYW51YWwpIHtcbiAgICB0cmFuc2Zvcm1zLmxpc3Quc2V0KHAsIHYpO1xuICAgIGlmIChwID09PSB0cmFuc2Zvcm1zLmxhc3QgfHwgbWFudWFsKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICB0cmFuc2Zvcm1zLmxpc3QuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIHByb3ApIHsgc3RyICs9IHByb3AgKyBcIihcIiArIHZhbHVlICsgXCIpIFwiOyB9KTtcbiAgICAgIHQuc3R5bGUudHJhbnNmb3JtID0gc3RyO1xuICAgIH1cbiAgfVxufTtcblxuLy8gU2V0IFZhbHVlIGhlbHBlclxuXG5mdW5jdGlvbiBzZXRUYXJnZXRzVmFsdWUodGFyZ2V0cywgcHJvcGVydGllcykge1xuICB2YXIgYW5pbWF0YWJsZXMgPSBnZXRBbmltYXRhYmxlcyh0YXJnZXRzKTtcbiAgYW5pbWF0YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYW5pbWF0YWJsZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldEZ1bmN0aW9uVmFsdWUocHJvcGVydGllc1twcm9wZXJ0eV0sIGFuaW1hdGFibGUpO1xuICAgICAgdmFyIHRhcmdldCA9IGFuaW1hdGFibGUudGFyZ2V0O1xuICAgICAgdmFyIHZhbHVlVW5pdCA9IGdldFVuaXQodmFsdWUpO1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlVW5pdCwgYW5pbWF0YWJsZSk7XG4gICAgICB2YXIgdW5pdCA9IHZhbHVlVW5pdCB8fCBnZXRVbml0KG9yaWdpbmFsVmFsdWUpO1xuICAgICAgdmFyIHRvID0gZ2V0UmVsYXRpdmVWYWx1ZSh2YWxpZGF0ZVZhbHVlKHZhbHVlLCB1bml0KSwgb3JpZ2luYWxWYWx1ZSk7XG4gICAgICB2YXIgYW5pbVR5cGUgPSBnZXRBbmltYXRpb25UeXBlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgc2V0UHJvZ3Jlc3NWYWx1ZVthbmltVHlwZV0odGFyZ2V0LCBwcm9wZXJ0eSwgdG8sIGFuaW1hdGFibGUudHJhbnNmb3JtcywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gQW5pbWF0aW9uc1xuXG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb24oYW5pbWF0YWJsZSwgcHJvcCkge1xuICB2YXIgYW5pbVR5cGUgPSBnZXRBbmltYXRpb25UeXBlKGFuaW1hdGFibGUudGFyZ2V0LCBwcm9wLm5hbWUpO1xuICBpZiAoYW5pbVR5cGUpIHtcbiAgICB2YXIgdHdlZW5zID0gbm9ybWFsaXplVHdlZW5zKHByb3AsIGFuaW1hdGFibGUpO1xuICAgIHZhciBsYXN0VHdlZW4gPSB0d2VlbnNbdHdlZW5zLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBhbmltVHlwZSxcbiAgICAgIHByb3BlcnR5OiBwcm9wLm5hbWUsXG4gICAgICBhbmltYXRhYmxlOiBhbmltYXRhYmxlLFxuICAgICAgdHdlZW5zOiB0d2VlbnMsXG4gICAgICBkdXJhdGlvbjogbGFzdFR3ZWVuLmVuZCxcbiAgICAgIGRlbGF5OiB0d2VlbnNbMF0uZGVsYXksXG4gICAgICBlbmREZWxheTogbGFzdFR3ZWVuLmVuZERlbGF5XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbnMoYW5pbWF0YWJsZXMsIHByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIGZpbHRlckFycmF5KGZsYXR0ZW5BcnJheShhbmltYXRhYmxlcy5tYXAoZnVuY3Rpb24gKGFuaW1hdGFibGUpIHtcbiAgICByZXR1cm4gcHJvcGVydGllcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBjcmVhdGVBbmltYXRpb24oYW5pbWF0YWJsZSwgcHJvcCk7XG4gICAgfSk7XG4gIH0pKSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuICFpcy51bmQoYSk7IH0pO1xufVxuXG4vLyBDcmVhdGUgSW5zdGFuY2VcblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VUaW1pbmdzKGFuaW1hdGlvbnMsIHR3ZWVuU2V0dGluZ3MpIHtcbiAgdmFyIGFuaW1MZW5ndGggPSBhbmltYXRpb25zLmxlbmd0aDtcbiAgdmFyIGdldFRsT2Zmc2V0ID0gZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGFuaW0udGltZWxpbmVPZmZzZXQgPyBhbmltLnRpbWVsaW5lT2Zmc2V0IDogMDsgfTtcbiAgdmFyIHRpbWluZ3MgPSB7fTtcbiAgdGltaW5ncy5kdXJhdGlvbiA9IGFuaW1MZW5ndGggPyBNYXRoLm1heC5hcHBseShNYXRoLCBhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gZ2V0VGxPZmZzZXQoYW5pbSkgKyBhbmltLmR1cmF0aW9uOyB9KSkgOiB0d2VlblNldHRpbmdzLmR1cmF0aW9uO1xuICB0aW1pbmdzLmRlbGF5ID0gYW5pbUxlbmd0aCA/IE1hdGgubWluLmFwcGx5KE1hdGgsIGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBnZXRUbE9mZnNldChhbmltKSArIGFuaW0uZGVsYXk7IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZGVsYXk7XG4gIHRpbWluZ3MuZW5kRGVsYXkgPSBhbmltTGVuZ3RoID8gdGltaW5ncy5kdXJhdGlvbiAtIE1hdGgubWF4LmFwcGx5KE1hdGgsIGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBnZXRUbE9mZnNldChhbmltKSArIGFuaW0uZHVyYXRpb24gLSBhbmltLmVuZERlbGF5OyB9KSkgOiB0d2VlblNldHRpbmdzLmVuZERlbGF5O1xuICByZXR1cm4gdGltaW5ncztcbn1cblxudmFyIGluc3RhbmNlSUQgPSAwO1xuXG5mdW5jdGlvbiBjcmVhdGVOZXdJbnN0YW5jZShwYXJhbXMpIHtcbiAgdmFyIGluc3RhbmNlU2V0dGluZ3MgPSByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciB0d2VlblNldHRpbmdzID0gcmVwbGFjZU9iamVjdFByb3BzKGRlZmF1bHRUd2VlblNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgcHJvcGVydGllcyA9IGdldFByb3BlcnRpZXModHdlZW5TZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIGFuaW1hdGFibGVzID0gZ2V0QW5pbWF0YWJsZXMocGFyYW1zLnRhcmdldHMpO1xuICB2YXIgYW5pbWF0aW9ucyA9IGdldEFuaW1hdGlvbnMoYW5pbWF0YWJsZXMsIHByb3BlcnRpZXMpO1xuICB2YXIgdGltaW5ncyA9IGdldEluc3RhbmNlVGltaW5ncyhhbmltYXRpb25zLCB0d2VlblNldHRpbmdzKTtcbiAgdmFyIGlkID0gaW5zdGFuY2VJRDtcbiAgaW5zdGFuY2VJRCsrO1xuICByZXR1cm4gbWVyZ2VPYmplY3RzKGluc3RhbmNlU2V0dGluZ3MsIHtcbiAgICBpZDogaWQsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGFuaW1hdGFibGVzOiBhbmltYXRhYmxlcyxcbiAgICBhbmltYXRpb25zOiBhbmltYXRpb25zLFxuICAgIGR1cmF0aW9uOiB0aW1pbmdzLmR1cmF0aW9uLFxuICAgIGRlbGF5OiB0aW1pbmdzLmRlbGF5LFxuICAgIGVuZERlbGF5OiB0aW1pbmdzLmVuZERlbGF5XG4gIH0pO1xufVxuXG4vLyBDb3JlXG5cbnZhciBhY3RpdmVJbnN0YW5jZXMgPSBbXTtcblxudmFyIGVuZ2luZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByYWY7XG5cbiAgZnVuY3Rpb24gcGxheSgpIHtcbiAgICBpZiAoIXJhZiAmJiAoIWlzRG9jdW1lbnRIaWRkZW4oKSB8fCAhYW5pbWUuc3VzcGVuZFdoZW5Eb2N1bWVudEhpZGRlbikgJiYgYWN0aXZlSW5zdGFuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RlcCh0KSB7XG4gICAgLy8gbWVtbyBvbiBhbGdvcml0aG0gaXNzdWU6XG4gICAgLy8gZGFuZ2Vyb3VzIGl0ZXJhdGlvbiBvdmVyIG11dGFibGUgYGFjdGl2ZUluc3RhbmNlc2BcbiAgICAvLyAodGhhdCBjb2xsZWN0aW9uIG1heSBiZSB1cGRhdGVkIGZyb20gd2l0aGluIGNhbGxiYWNrcyBvZiBgdGlja2AtZWQgYW5pbWF0aW9uIGluc3RhbmNlcylcbiAgICB2YXIgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhY3RpdmVJbnN0YW5jZXNMZW5ndGgpIHtcbiAgICAgIHZhciBhY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICAgIGlmICghYWN0aXZlSW5zdGFuY2UucGF1c2VkKSB7XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLnRpY2sodCk7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlc0xlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByYWYgPSBpID4gMCA/IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKCFhbmltZS5zdXNwZW5kV2hlbkRvY3VtZW50SGlkZGVuKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGlzRG9jdW1lbnRIaWRkZW4oKSkge1xuICAgICAgLy8gc3VzcGVuZCB0aWNrc1xuICAgICAgcmFmID0gY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICB9IGVsc2UgeyAvLyBpcyBiYWNrIHRvIGFjdGl2ZSB0YWJcbiAgICAgIC8vIGZpcnN0IGFkanVzdCBhbmltYXRpb25zIHRvIGNvbnNpZGVyIHRoZSB0aW1lIHRoYXQgdGlja3Mgd2VyZSBzdXNwZW5kZWRcbiAgICAgIGFjdGl2ZUluc3RhbmNlcy5mb3JFYWNoKFxuICAgICAgICBmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuIGluc3RhbmNlIC5fb25Eb2N1bWVudFZpc2liaWxpdHkoKTsgfVxuICAgICAgKTtcbiAgICAgIGVuZ2luZSgpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfVxuXG4gIHJldHVybiBwbGF5O1xufSkoKTtcblxuZnVuY3Rpb24gaXNEb2N1bWVudEhpZGRlbigpIHtcbiAgcmV0dXJuICEhZG9jdW1lbnQgJiYgZG9jdW1lbnQuaGlkZGVuO1xufVxuXG4vLyBQdWJsaWMgSW5zdGFuY2VcblxuZnVuY3Rpb24gYW5pbWUocGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuXG4gIHZhciBzdGFydFRpbWUgPSAwLCBsYXN0VGltZSA9IDAsIG5vdyA9IDA7XG4gIHZhciBjaGlsZHJlbiwgY2hpbGRyZW5MZW5ndGggPSAwO1xuICB2YXIgcmVzb2x2ZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbWFrZVByb21pc2UoaW5zdGFuY2UpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHdpbmRvdy5Qcm9taXNlICYmIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfcmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZSA9IF9yZXNvbHZlOyB9KTtcbiAgICBpbnN0YW5jZS5maW5pc2hlZCA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVOZXdJbnN0YW5jZShwYXJhbXMpO1xuICB2YXIgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcblxuICBmdW5jdGlvbiB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5zdGFuY2UuZGlyZWN0aW9uO1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdhbHRlcm5hdGUnKSB7XG4gICAgICBpbnN0YW5jZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24gIT09ICdub3JtYWwnID8gJ25vcm1hbCcgOiAncmV2ZXJzZSc7XG4gICAgfVxuICAgIGluc3RhbmNlLnJldmVyc2VkID0gIWluc3RhbmNlLnJldmVyc2VkO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5yZXZlcnNlZCA9IGluc3RhbmNlLnJldmVyc2VkOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdFRpbWUodGltZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS5yZXZlcnNlZCA/IGluc3RhbmNlLmR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRpbWUoKSB7XG4gICAgc3RhcnRUaW1lID0gMDtcbiAgICBsYXN0VGltZSA9IGFkanVzdFRpbWUoaW5zdGFuY2UuY3VycmVudFRpbWUpICogKDEgLyBhbmltZS5zcGVlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWVrQ2hpbGQodGltZSwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHsgY2hpbGQuc2Vlayh0aW1lIC0gY2hpbGQudGltZWxpbmVPZmZzZXQpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzeW5jSW5zdGFuY2VDaGlsZHJlbih0aW1lKSB7XG4gICAgaWYgKCFpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykgeyBzZWVrQ2hpbGQodGltZSwgY2hpbGRyZW5baV0pOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IGNoaWxkcmVuTGVuZ3RoOyBpJDEtLTspIHsgc2Vla0NoaWxkKHRpbWUsIGNoaWxkcmVuW2kkMV0pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSBpbnN0YW5jZS5hbmltYXRpb25zO1xuICAgIHZhciBhbmltYXRpb25zTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBhbmltYXRpb25zTGVuZ3RoKSB7XG4gICAgICB2YXIgYW5pbSA9IGFuaW1hdGlvbnNbaV07XG4gICAgICB2YXIgYW5pbWF0YWJsZSA9IGFuaW0uYW5pbWF0YWJsZTtcbiAgICAgIHZhciB0d2VlbnMgPSBhbmltLnR3ZWVucztcbiAgICAgIHZhciB0d2Vlbkxlbmd0aCA9IHR3ZWVucy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHR3ZWVuID0gdHdlZW5zW3R3ZWVuTGVuZ3RoXTtcbiAgICAgIC8vIE9ubHkgY2hlY2sgZm9yIGtleWZyYW1lcyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHR3ZWVuXG4gICAgICBpZiAodHdlZW5MZW5ndGgpIHsgdHdlZW4gPSBmaWx0ZXJBcnJheSh0d2VlbnMsIGZ1bmN0aW9uICh0KSB7IHJldHVybiAoaW5zVGltZSA8IHQuZW5kKTsgfSlbMF0gfHwgdHdlZW47IH1cbiAgICAgIHZhciBlbGFwc2VkID0gbWluTWF4KGluc1RpbWUgLSB0d2Vlbi5zdGFydCAtIHR3ZWVuLmRlbGF5LCAwLCB0d2Vlbi5kdXJhdGlvbikgLyB0d2Vlbi5kdXJhdGlvbjtcbiAgICAgIHZhciBlYXNlZCA9IGlzTmFOKGVsYXBzZWQpID8gMSA6IHR3ZWVuLmVhc2luZyhlbGFwc2VkKTtcbiAgICAgIHZhciBzdHJpbmdzID0gdHdlZW4udG8uc3RyaW5ncztcbiAgICAgIHZhciByb3VuZCA9IHR3ZWVuLnJvdW5kO1xuICAgICAgdmFyIG51bWJlcnMgPSBbXTtcbiAgICAgIHZhciB0b051bWJlcnNMZW5ndGggPSB0d2Vlbi50by5udW1iZXJzLmxlbmd0aDtcbiAgICAgIHZhciBwcm9ncmVzcyA9ICh2b2lkIDApO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0b051bWJlcnNMZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAodm9pZCAwKTtcbiAgICAgICAgdmFyIHRvTnVtYmVyID0gdHdlZW4udG8ubnVtYmVyc1tuXTtcbiAgICAgICAgdmFyIGZyb21OdW1iZXIgPSB0d2Vlbi5mcm9tLm51bWJlcnNbbl0gfHwgMDtcbiAgICAgICAgaWYgKCF0d2Vlbi5pc1BhdGgpIHtcbiAgICAgICAgICB2YWx1ZSA9IGZyb21OdW1iZXIgKyAoZWFzZWQgKiAodG9OdW1iZXIgLSBmcm9tTnVtYmVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBnZXRQYXRoUHJvZ3Jlc3ModHdlZW4udmFsdWUsIGVhc2VkICogdG9OdW1iZXIsIHR3ZWVuLmlzUGF0aFRhcmdldEluc2lkZVNWRyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdW5kKSB7XG4gICAgICAgICAgaWYgKCEodHdlZW4uaXNDb2xvciAmJiBuID4gMikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIHJvdW5kKSAvIHJvdW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gTWFudWFsIEFycmF5LnJlZHVjZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlc1xuICAgICAgdmFyIHN0cmluZ3NMZW5ndGggPSBzdHJpbmdzLmxlbmd0aDtcbiAgICAgIGlmICghc3RyaW5nc0xlbmd0aCkge1xuICAgICAgICBwcm9ncmVzcyA9IG51bWJlcnNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmVzcyA9IHN0cmluZ3NbMF07XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc3RyaW5nc0xlbmd0aDsgcysrKSB7XG4gICAgICAgICAgdmFyIGEgPSBzdHJpbmdzW3NdO1xuICAgICAgICAgIHZhciBiID0gc3RyaW5nc1tzICsgMV07XG4gICAgICAgICAgdmFyIG4kMSA9IG51bWJlcnNbc107XG4gICAgICAgICAgaWYgKCFpc05hTihuJDEpKSB7XG4gICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MgKz0gbiQxICsgJyAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MgKz0gbiQxICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFByb2dyZXNzVmFsdWVbYW5pbS50eXBlXShhbmltYXRhYmxlLnRhcmdldCwgYW5pbS5wcm9wZXJ0eSwgcHJvZ3Jlc3MsIGFuaW1hdGFibGUudHJhbnNmb3Jtcyk7XG4gICAgICBhbmltLmN1cnJlbnRWYWx1ZSA9IHByb2dyZXNzO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENhbGxiYWNrKGNiKSB7XG4gICAgaWYgKGluc3RhbmNlW2NiXSAmJiAhaW5zdGFuY2UucGFzc1Rocm91Z2gpIHsgaW5zdGFuY2VbY2JdKGluc3RhbmNlKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gY291bnRJdGVyYXRpb24oKSB7XG4gICAgaWYgKGluc3RhbmNlLnJlbWFpbmluZyAmJiBpbnN0YW5jZS5yZW1haW5pbmcgIT09IHRydWUpIHtcbiAgICAgIGluc3RhbmNlLnJlbWFpbmluZy0tO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluc3RhbmNlUHJvZ3Jlc3MoZW5naW5lVGltZSkge1xuICAgIHZhciBpbnNEdXJhdGlvbiA9IGluc3RhbmNlLmR1cmF0aW9uO1xuICAgIHZhciBpbnNEZWxheSA9IGluc3RhbmNlLmRlbGF5O1xuICAgIHZhciBpbnNFbmREZWxheSA9IGluc0R1cmF0aW9uIC0gaW5zdGFuY2UuZW5kRGVsYXk7XG4gICAgdmFyIGluc1RpbWUgPSBhZGp1c3RUaW1lKGVuZ2luZVRpbWUpO1xuICAgIGluc3RhbmNlLnByb2dyZXNzID0gbWluTWF4KChpbnNUaW1lIC8gaW5zRHVyYXRpb24pICogMTAwLCAwLCAxMDApO1xuICAgIGluc3RhbmNlLnJldmVyc2VQbGF5YmFjayA9IGluc1RpbWUgPCBpbnN0YW5jZS5jdXJyZW50VGltZTtcbiAgICBpZiAoY2hpbGRyZW4pIHsgc3luY0luc3RhbmNlQ2hpbGRyZW4oaW5zVGltZSk7IH1cbiAgICBpZiAoIWluc3RhbmNlLmJlZ2FuICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgaW5zdGFuY2UuYmVnYW4gPSB0cnVlO1xuICAgICAgc2V0Q2FsbGJhY2soJ2JlZ2luJyk7XG4gICAgfVxuICAgIGlmICghaW5zdGFuY2UubG9vcEJlZ2FuICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gdHJ1ZTtcbiAgICAgIHNldENhbGxiYWNrKCdsb29wQmVnaW4nKTtcbiAgICB9XG4gICAgaWYgKGluc1RpbWUgPD0gaW5zRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IDApIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcygwKTtcbiAgICB9XG4gICAgaWYgKChpbnNUaW1lID49IGluc0VuZERlbGF5ICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lICE9PSBpbnNEdXJhdGlvbikgfHwgIWluc0R1cmF0aW9uKSB7XG4gICAgICBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zRHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA+IGluc0RlbGF5ICYmIGluc1RpbWUgPCBpbnNFbmREZWxheSkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5jaGFuZ2VCZWdhbikge1xuICAgICAgICBpbnN0YW5jZS5jaGFuZ2VCZWdhbiA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICBzZXRDYWxsYmFjaygnY2hhbmdlQmVnaW4nKTtcbiAgICAgIH1cbiAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2UnKTtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VDb21wbGV0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5jdXJyZW50VGltZSA9IG1pbk1heChpbnNUaW1lLCAwLCBpbnNEdXJhdGlvbik7XG4gICAgaWYgKGluc3RhbmNlLmJlZ2FuKSB7IHNldENhbGxiYWNrKCd1cGRhdGUnKTsgfVxuICAgIGlmIChlbmdpbmVUaW1lID49IGluc0R1cmF0aW9uKSB7XG4gICAgICBsYXN0VGltZSA9IDA7XG4gICAgICBjb3VudEl0ZXJhdGlvbigpO1xuICAgICAgaWYgKCFpbnN0YW5jZS5yZW1haW5pbmcpIHtcbiAgICAgICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5jb21wbGV0ZWQpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNldENhbGxiYWNrKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgICBzZXRDYWxsYmFjaygnY29tcGxldGUnKTtcbiAgICAgICAgICBpZiAoIWluc3RhbmNlLnBhc3NUaHJvdWdoICYmICdQcm9taXNlJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHByb21pc2UgPSBtYWtlUHJvbWlzZShpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFRpbWUgPSBub3c7XG4gICAgICAgIHNldENhbGxiYWNrKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnN0YW5jZS5kaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnKSB7XG4gICAgICAgICAgdG9nZ2xlSW5zdGFuY2VEaXJlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGluc3RhbmNlLmRpcmVjdGlvbjtcbiAgICBpbnN0YW5jZS5wYXNzVGhyb3VnaCA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gMDtcbiAgICBpbnN0YW5jZS5wcm9ncmVzcyA9IDA7XG4gICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS5iZWdhbiA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmxvb3BCZWdhbiA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSBkaXJlY3Rpb24gPT09ICdyZXZlcnNlJztcbiAgICBpbnN0YW5jZS5yZW1haW5pbmcgPSBpbnN0YW5jZS5sb29wO1xuICAgIGNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW47XG4gICAgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuTGVuZ3RoOyBpLS07KSB7IGluc3RhbmNlLmNoaWxkcmVuW2ldLnJlc2V0KCk7IH1cbiAgICBpZiAoaW5zdGFuY2UucmV2ZXJzZWQgJiYgaW5zdGFuY2UubG9vcCAhPT0gdHJ1ZSB8fCAoZGlyZWN0aW9uID09PSAnYWx0ZXJuYXRlJyAmJiBpbnN0YW5jZS5sb29wID09PSAxKSkgeyBpbnN0YW5jZS5yZW1haW5pbmcrKzsgfVxuICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnN0YW5jZS5yZXZlcnNlZCA/IGluc3RhbmNlLmR1cmF0aW9uIDogMCk7XG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgbWV0aG9kIChmb3IgZW5naW5lKSB0byBhZGp1c3QgYW5pbWF0aW9uIHRpbWluZ3MgYmVmb3JlIHJlc3RvcmluZyBlbmdpbmUgdGlja3MgKHJBRilcbiAgaW5zdGFuY2UuX29uRG9jdW1lbnRWaXNpYmlsaXR5ID0gcmVzZXRUaW1lO1xuXG4gIC8vIFNldCBWYWx1ZSBoZWxwZXJcblxuICBpbnN0YW5jZS5zZXQgPSBmdW5jdGlvbih0YXJnZXRzLCBwcm9wZXJ0aWVzKSB7XG4gICAgc2V0VGFyZ2V0c1ZhbHVlKHRhcmdldHMsIHByb3BlcnRpZXMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICBpbnN0YW5jZS50aWNrID0gZnVuY3Rpb24odCkge1xuICAgIG5vdyA9IHQ7XG4gICAgaWYgKCFzdGFydFRpbWUpIHsgc3RhcnRUaW1lID0gbm93OyB9XG4gICAgc2V0SW5zdGFuY2VQcm9ncmVzcygobm93ICsgKGxhc3RUaW1lIC0gc3RhcnRUaW1lKSkgKiBhbmltZS5zcGVlZCk7XG4gIH07XG5cbiAgaW5zdGFuY2Uuc2VlayA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICBzZXRJbnN0YW5jZVByb2dyZXNzKGFkanVzdFRpbWUodGltZSkpO1xuICB9O1xuXG4gIGluc3RhbmNlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICByZXNldFRpbWUoKTtcbiAgfTtcblxuICBpbnN0YW5jZS5wbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFpbnN0YW5jZS5wYXVzZWQpIHsgcmV0dXJuOyB9XG4gICAgaWYgKGluc3RhbmNlLmNvbXBsZXRlZCkgeyBpbnN0YW5jZS5yZXNldCgpOyB9XG4gICAgaW5zdGFuY2UucGF1c2VkID0gZmFsc2U7XG4gICAgYWN0aXZlSW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgIHJlc2V0VGltZSgpO1xuICAgIGVuZ2luZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgIGluc3RhbmNlLmNvbXBsZXRlZCA9IGluc3RhbmNlLnJldmVyc2VkID8gZmFsc2UgOiB0cnVlO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5yZXNldCgpO1xuICAgIGluc3RhbmNlLnBsYXkoKTtcbiAgfTtcblxuICBpbnN0YW5jZS5yZW1vdmUgPSBmdW5jdGlvbih0YXJnZXRzKSB7XG4gICAgdmFyIHRhcmdldHNBcnJheSA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICByZW1vdmVUYXJnZXRzRnJvbUluc3RhbmNlKHRhcmdldHNBcnJheSwgaW5zdGFuY2UpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlc2V0KCk7XG5cbiAgaWYgKGluc3RhbmNlLmF1dG9wbGF5KSB7IGluc3RhbmNlLnBsYXkoKTsgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcblxufVxuXG4vLyBSZW1vdmUgdGFyZ2V0cyBmcm9tIGFuaW1hdGlvblxuXG5mdW5jdGlvbiByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zKSB7XG4gIGZvciAodmFyIGEgPSBhbmltYXRpb25zLmxlbmd0aDsgYS0tOykge1xuICAgIGlmIChhcnJheUNvbnRhaW5zKHRhcmdldHNBcnJheSwgYW5pbWF0aW9uc1thXS5hbmltYXRhYmxlLnRhcmdldCkpIHtcbiAgICAgIGFuaW1hdGlvbnMuc3BsaWNlKGEsIDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUYXJnZXRzRnJvbUluc3RhbmNlKHRhcmdldHNBcnJheSwgaW5zdGFuY2UpIHtcbiAgdmFyIGFuaW1hdGlvbnMgPSBpbnN0YW5jZS5hbmltYXRpb25zO1xuICB2YXIgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgYW5pbWF0aW9ucyk7XG4gIGZvciAodmFyIGMgPSBjaGlsZHJlbi5sZW5ndGg7IGMtLTspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltjXTtcbiAgICB2YXIgY2hpbGRBbmltYXRpb25zID0gY2hpbGQuYW5pbWF0aW9ucztcbiAgICByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBjaGlsZEFuaW1hdGlvbnMpO1xuICAgIGlmICghY2hpbGRBbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7IGNoaWxkcmVuLnNwbGljZShjLCAxKTsgfVxuICB9XG4gIGlmICghYW5pbWF0aW9ucy5sZW5ndGggJiYgIWNoaWxkcmVuLmxlbmd0aCkgeyBpbnN0YW5jZS5wYXVzZSgpOyB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHNGcm9tQWN0aXZlSW5zdGFuY2VzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldHNBcnJheSA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgZm9yICh2YXIgaSA9IGFjdGl2ZUluc3RhbmNlcy5sZW5ndGg7IGktLTspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZXNbaV07XG4gICAgcmVtb3ZlVGFyZ2V0c0Zyb21JbnN0YW5jZSh0YXJnZXRzQXJyYXksIGluc3RhbmNlKTtcbiAgfVxufVxuXG4vLyBTdGFnZ2VyIGhlbHBlcnNcblxuZnVuY3Rpb24gc3RhZ2dlcih2YWwsIHBhcmFtcykge1xuICBpZiAoIHBhcmFtcyA9PT0gdm9pZCAwICkgcGFyYW1zID0ge307XG5cbiAgdmFyIGRpcmVjdGlvbiA9IHBhcmFtcy5kaXJlY3Rpb24gfHwgJ25vcm1hbCc7XG4gIHZhciBlYXNpbmcgPSBwYXJhbXMuZWFzaW5nID8gcGFyc2VFYXNpbmdzKHBhcmFtcy5lYXNpbmcpIDogbnVsbDtcbiAgdmFyIGdyaWQgPSBwYXJhbXMuZ3JpZDtcbiAgdmFyIGF4aXMgPSBwYXJhbXMuYXhpcztcbiAgdmFyIGZyb21JbmRleCA9IHBhcmFtcy5mcm9tIHx8IDA7XG4gIHZhciBmcm9tRmlyc3QgPSBmcm9tSW5kZXggPT09ICdmaXJzdCc7XG4gIHZhciBmcm9tQ2VudGVyID0gZnJvbUluZGV4ID09PSAnY2VudGVyJztcbiAgdmFyIGZyb21MYXN0ID0gZnJvbUluZGV4ID09PSAnbGFzdCc7XG4gIHZhciBpc1JhbmdlID0gaXMuYXJyKHZhbCk7XG4gIHZhciB2YWwxID0gaXNSYW5nZSA/IHBhcnNlRmxvYXQodmFsWzBdKSA6IHBhcnNlRmxvYXQodmFsKTtcbiAgdmFyIHZhbDIgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMV0pIDogMDtcbiAgdmFyIHVuaXQgPSBnZXRVbml0KGlzUmFuZ2UgPyB2YWxbMV0gOiB2YWwpIHx8IDA7XG4gIHZhciBzdGFydCA9IHBhcmFtcy5zdGFydCB8fCAwICsgKGlzUmFuZ2UgPyB2YWwxIDogMCk7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIG1heFZhbHVlID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbCwgaSwgdCkge1xuICAgIGlmIChmcm9tRmlyc3QpIHsgZnJvbUluZGV4ID0gMDsgfVxuICAgIGlmIChmcm9tQ2VudGVyKSB7IGZyb21JbmRleCA9ICh0IC0gMSkgLyAyOyB9XG4gICAgaWYgKGZyb21MYXN0KSB7IGZyb21JbmRleCA9IHQgLSAxOyB9XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoIWdyaWQpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChNYXRoLmFicyhmcm9tSW5kZXggLSBpbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmcm9tWCA9ICFmcm9tQ2VudGVyID8gZnJvbUluZGV4JWdyaWRbMF0gOiAoZ3JpZFswXS0xKS8yO1xuICAgICAgICAgIHZhciBmcm9tWSA9ICFmcm9tQ2VudGVyID8gTWF0aC5mbG9vcihmcm9tSW5kZXgvZ3JpZFswXSkgOiAoZ3JpZFsxXS0xKS8yO1xuICAgICAgICAgIHZhciB0b1ggPSBpbmRleCVncmlkWzBdO1xuICAgICAgICAgIHZhciB0b1kgPSBNYXRoLmZsb29yKGluZGV4L2dyaWRbMF0pO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBmcm9tWCAtIHRvWDtcbiAgICAgICAgICB2YXIgZGlzdGFuY2VZID0gZnJvbVkgLSB0b1k7XG4gICAgICAgICAgdmFyIHZhbHVlID0gTWF0aC5zcXJ0KGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWSk7XG4gICAgICAgICAgaWYgKGF4aXMgPT09ICd4JykgeyB2YWx1ZSA9IC1kaXN0YW5jZVg7IH1cbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3knKSB7IHZhbHVlID0gLWRpc3RhbmNlWTsgfVxuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoZWFzaW5nKSB7IHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gZWFzaW5nKHZhbCAvIG1heFZhbHVlKSAqIG1heFZhbHVlOyB9KTsgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnKSB7IHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gYXhpcyA/ICh2YWwgPCAwKSA/IHZhbCAqIC0xIDogLXZhbCA6IE1hdGguYWJzKG1heFZhbHVlIC0gdmFsKTsgfSk7IH1cbiAgICB9XG4gICAgdmFyIHNwYWNpbmcgPSBpc1JhbmdlID8gKHZhbDIgLSB2YWwxKSAvIG1heFZhbHVlIDogdmFsMTtcbiAgICByZXR1cm4gc3RhcnQgKyAoc3BhY2luZyAqIChNYXRoLnJvdW5kKHZhbHVlc1tpXSAqIDEwMCkgLyAxMDApKSArIHVuaXQ7XG4gIH1cbn1cblxuLy8gVGltZWxpbmVcblxuZnVuY3Rpb24gdGltZWxpbmUocGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgdGwgPSBhbmltZShwYXJhbXMpO1xuICB0bC5kdXJhdGlvbiA9IDA7XG4gIHRsLmFkZCA9IGZ1bmN0aW9uKGluc3RhbmNlUGFyYW1zLCB0aW1lbGluZU9mZnNldCkge1xuICAgIHZhciB0bEluZGV4ID0gYWN0aXZlSW5zdGFuY2VzLmluZGV4T2YodGwpO1xuICAgIHZhciBjaGlsZHJlbiA9IHRsLmNoaWxkcmVuO1xuICAgIGlmICh0bEluZGV4ID4gLTEpIHsgYWN0aXZlSW5zdGFuY2VzLnNwbGljZSh0bEluZGV4LCAxKTsgfVxuICAgIGZ1bmN0aW9uIHBhc3NUaHJvdWdoKGlucykgeyBpbnMucGFzc1Rocm91Z2ggPSB0cnVlOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykgeyBwYXNzVGhyb3VnaChjaGlsZHJlbltpXSk7IH1cbiAgICB2YXIgaW5zUGFyYW1zID0gbWVyZ2VPYmplY3RzKGluc3RhbmNlUGFyYW1zLCByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdFR3ZWVuU2V0dGluZ3MsIHBhcmFtcykpO1xuICAgIGluc1BhcmFtcy50YXJnZXRzID0gaW5zUGFyYW1zLnRhcmdldHMgfHwgcGFyYW1zLnRhcmdldHM7XG4gICAgdmFyIHRsRHVyYXRpb24gPSB0bC5kdXJhdGlvbjtcbiAgICBpbnNQYXJhbXMuYXV0b3BsYXkgPSBmYWxzZTtcbiAgICBpbnNQYXJhbXMuZGlyZWN0aW9uID0gdGwuZGlyZWN0aW9uO1xuICAgIGluc1BhcmFtcy50aW1lbGluZU9mZnNldCA9IGlzLnVuZCh0aW1lbGluZU9mZnNldCkgPyB0bER1cmF0aW9uIDogZ2V0UmVsYXRpdmVWYWx1ZSh0aW1lbGluZU9mZnNldCwgdGxEdXJhdGlvbik7XG4gICAgcGFzc1Rocm91Z2godGwpO1xuICAgIHRsLnNlZWsoaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0KTtcbiAgICB2YXIgaW5zID0gYW5pbWUoaW5zUGFyYW1zKTtcbiAgICBwYXNzVGhyb3VnaChpbnMpO1xuICAgIGNoaWxkcmVuLnB1c2goaW5zKTtcbiAgICB2YXIgdGltaW5ncyA9IGdldEluc3RhbmNlVGltaW5ncyhjaGlsZHJlbiwgcGFyYW1zKTtcbiAgICB0bC5kZWxheSA9IHRpbWluZ3MuZGVsYXk7XG4gICAgdGwuZW5kRGVsYXkgPSB0aW1pbmdzLmVuZERlbGF5O1xuICAgIHRsLmR1cmF0aW9uID0gdGltaW5ncy5kdXJhdGlvbjtcbiAgICB0bC5zZWVrKDApO1xuICAgIHRsLnJlc2V0KCk7XG4gICAgaWYgKHRsLmF1dG9wbGF5KSB7IHRsLnBsYXkoKTsgfVxuICAgIHJldHVybiB0bDtcbiAgfTtcbiAgcmV0dXJuIHRsO1xufVxuXG5hbmltZS52ZXJzaW9uID0gJzMuMi4xJztcbmFuaW1lLnNwZWVkID0gMTtcbi8vIFRPRE86I3JldmlldzogbmFtaW5nLCBkb2N1bWVudGF0aW9uXG5hbmltZS5zdXNwZW5kV2hlbkRvY3VtZW50SGlkZGVuID0gdHJ1ZTtcbmFuaW1lLnJ1bm5pbmcgPSBhY3RpdmVJbnN0YW5jZXM7XG5hbmltZS5yZW1vdmUgPSByZW1vdmVUYXJnZXRzRnJvbUFjdGl2ZUluc3RhbmNlcztcbmFuaW1lLmdldCA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWU7XG5hbmltZS5zZXQgPSBzZXRUYXJnZXRzVmFsdWU7XG5hbmltZS5jb252ZXJ0UHggPSBjb252ZXJ0UHhUb1VuaXQ7XG5hbmltZS5wYXRoID0gZ2V0UGF0aDtcbmFuaW1lLnNldERhc2hvZmZzZXQgPSBzZXREYXNob2Zmc2V0O1xuYW5pbWUuc3RhZ2dlciA9IHN0YWdnZXI7XG5hbmltZS50aW1lbGluZSA9IHRpbWVsaW5lO1xuYW5pbWUuZWFzaW5nID0gcGFyc2VFYXNpbmdzO1xuYW5pbWUucGVubmVyID0gcGVubmVyO1xuYW5pbWUucmFuZG9tID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluOyB9O1xuXG5leHBvcnQgZGVmYXVsdCBhbmltZTtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncyIsInVwZGF0ZSIsImJlZ2luIiwibG9vcEJlZ2luIiwiY2hhbmdlQmVnaW4iLCJjaGFuZ2UiLCJjaGFuZ2VDb21wbGV0ZSIsImxvb3BDb21wbGV0ZSIsImNvbXBsZXRlIiwibG9vcCIsImRpcmVjdGlvbiIsImF1dG9wbGF5IiwidGltZWxpbmVPZmZzZXQiLCJkZWZhdWx0VHdlZW5TZXR0aW5ncyIsImR1cmF0aW9uIiwiZGVsYXkiLCJlbmREZWxheSIsImVhc2luZyIsInJvdW5kIiwidmFsaWRUcmFuc2Zvcm1zIiwiY2FjaGUiLCJDU1MiLCJzcHJpbmdzIiwibWluTWF4IiwidmFsIiwibWluIiwibWF4IiwiTWF0aCIsInN0cmluZ0NvbnRhaW5zIiwic3RyIiwidGV4dCIsImluZGV4T2YiLCJhcHBseUFyZ3VtZW50cyIsImZ1bmMiLCJhcmdzIiwiYXBwbHkiLCJpcyIsImFyciIsImEiLCJBcnJheSIsImlzQXJyYXkiLCJvYmoiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJwdGgiLCJoYXNPd25Qcm9wZXJ0eSIsInN2ZyIsIlNWR0VsZW1lbnQiLCJpbnAiLCJIVE1MSW5wdXRFbGVtZW50IiwiZG9tIiwibm9kZVR5cGUiLCJmbmMiLCJ1bmQiLCJuaWwiLCJoZXgiLCJ0ZXN0IiwicmdiIiwiaHNsIiwiY29sIiwia2V5IiwicGFyc2VFYXNpbmdQYXJhbWV0ZXJzIiwic3RyaW5nIiwibWF0Y2giLCJleGVjIiwic3BsaXQiLCJtYXAiLCJwIiwicGFyc2VGbG9hdCIsInNwcmluZyIsInBhcmFtcyIsIm1hc3MiLCJzdGlmZm5lc3MiLCJkYW1waW5nIiwidmVsb2NpdHkiLCJ3MCIsInNxcnQiLCJ6ZXRhIiwid2QiLCJiIiwic29sdmVyIiwidCIsInByb2dyZXNzIiwiZXhwIiwiY29zIiwic2luIiwiZ2V0RHVyYXRpb24iLCJjYWNoZWQiLCJmcmFtZSIsImVsYXBzZWQiLCJyZXN0Iiwic3RlcHMiLCJjZWlsIiwiYmV6aWVyIiwia1NwbGluZVRhYmxlU2l6ZSIsImtTYW1wbGVTdGVwU2l6ZSIsIkEiLCJhQTEiLCJhQTIiLCJCIiwiQyIsImNhbGNCZXppZXIiLCJhVCIsImdldFNsb3BlIiwiYmluYXJ5U3ViZGl2aWRlIiwiYVgiLCJhQSIsImFCIiwibVgxIiwibVgyIiwiY3VycmVudFgiLCJjdXJyZW50VCIsImkiLCJhYnMiLCJuZXd0b25SYXBoc29uSXRlcmF0ZSIsImFHdWVzc1QiLCJjdXJyZW50U2xvcGUiLCJtWTEiLCJtWTIiLCJzYW1wbGVWYWx1ZXMiLCJGbG9hdDMyQXJyYXkiLCJnZXRURm9yWCIsImludGVydmFsU3RhcnQiLCJjdXJyZW50U2FtcGxlIiwibGFzdFNhbXBsZSIsImRpc3QiLCJndWVzc0ZvclQiLCJpbml0aWFsU2xvcGUiLCJ4IiwicGVubmVyIiwiZWFzZXMiLCJsaW5lYXIiLCJmdW5jdGlvbkVhc2luZ3MiLCJTaW5lIiwiUEkiLCJFeHBvIiwicG93IiwiQ2lyYyIsIkJhY2siLCJCb3VuY2UiLCJwb3cyIiwiRWxhc3RpYyIsImFtcGxpdHVkZSIsInBlcmlvZCIsImFzaW4iLCJiYXNlRWFzaW5ncyIsImZvckVhY2giLCJuYW1lIiwia2V5cyIsImVhc2VJbiIsInBhcnNlRWFzaW5ncyIsImVhc2UiLCJzZWxlY3RTdHJpbmciLCJub2RlcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImUiLCJmaWx0ZXJBcnJheSIsImNhbGxiYWNrIiwibGVuIiwibGVuZ3RoIiwidGhpc0FyZyIsImFyZ3VtZW50cyIsInJlc3VsdCIsInB1c2giLCJmbGF0dGVuQXJyYXkiLCJyZWR1Y2UiLCJjb25jYXQiLCJ0b0FycmF5IiwibyIsIk5vZGVMaXN0IiwiSFRNTENvbGxlY3Rpb24iLCJzbGljZSIsImFycmF5Q29udGFpbnMiLCJzb21lIiwiY2xvbmVPYmplY3QiLCJjbG9uZSIsInJlcGxhY2VPYmplY3RQcm9wcyIsIm8xIiwibzIiLCJtZXJnZU9iamVjdHMiLCJyZ2JUb1JnYmEiLCJyZ2JWYWx1ZSIsImhleFRvUmdiYSIsImhleFZhbHVlIiwicmd4IiwicmVwbGFjZSIsIm0iLCJyIiwiZyIsInBhcnNlSW50IiwiaHNsVG9SZ2JhIiwiaHNsVmFsdWUiLCJoIiwicyIsImwiLCJodWUycmdiIiwicSIsImNvbG9yVG9SZ2IiLCJnZXRVbml0IiwiZ2V0VHJhbnNmb3JtVW5pdCIsInByb3BOYW1lIiwiZ2V0RnVuY3Rpb25WYWx1ZSIsImFuaW1hdGFibGUiLCJ0YXJnZXQiLCJpZCIsInRvdGFsIiwiZ2V0QXR0cmlidXRlIiwiZWwiLCJwcm9wIiwiY29udmVydFB4VG9Vbml0IiwidmFsdWUiLCJ1bml0IiwidmFsdWVVbml0IiwiYmFzZWxpbmUiLCJ0ZW1wRWwiLCJjcmVhdGVFbGVtZW50IiwidGFnTmFtZSIsInBhcmVudEVsIiwicGFyZW50Tm9kZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN0eWxlIiwicG9zaXRpb24iLCJ3aWR0aCIsImZhY3RvciIsIm9mZnNldFdpZHRoIiwicmVtb3ZlQ2hpbGQiLCJjb252ZXJ0ZWRVbml0IiwiZ2V0Q1NTVmFsdWUiLCJ1cHBlcmNhc2VQcm9wTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRBbmltYXRpb25UeXBlIiwiZ2V0RWxlbWVudFRyYW5zZm9ybXMiLCJ0cmFuc2Zvcm0iLCJyZWciLCJ0cmFuc2Zvcm1zIiwiTWFwIiwic2V0IiwiZ2V0VHJhbnNmb3JtVmFsdWUiLCJkZWZhdWx0VmFsIiwiZ2V0IiwibGlzdCIsImdldE9yaWdpbmFsVGFyZ2V0VmFsdWUiLCJnZXRSZWxhdGl2ZVZhbHVlIiwidG8iLCJmcm9tIiwib3BlcmF0b3IiLCJ1IiwieSIsInZhbGlkYXRlVmFsdWUiLCJvcmlnaW5hbFVuaXQiLCJ1bml0TGVzcyIsInN1YnN0ciIsImdldERpc3RhbmNlIiwicDEiLCJwMiIsImdldENpcmNsZUxlbmd0aCIsImdldFJlY3RMZW5ndGgiLCJnZXRMaW5lTGVuZ3RoIiwiZ2V0UG9seWxpbmVMZW5ndGgiLCJwb2ludHMiLCJ0b3RhbExlbmd0aCIsInByZXZpb3VzUG9zIiwibnVtYmVyT2ZJdGVtcyIsImN1cnJlbnRQb3MiLCJnZXRJdGVtIiwiZ2V0UG9seWdvbkxlbmd0aCIsImdldFRvdGFsTGVuZ3RoIiwic2V0RGFzaG9mZnNldCIsInBhdGhMZW5ndGgiLCJzZXRBdHRyaWJ1dGUiLCJnZXRQYXJlbnRTdmdFbCIsImdldFBhcmVudFN2ZyIsInBhdGhFbCIsInN2Z0RhdGEiLCJwYXJlbnRTdmdFbCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ2aWV3Qm94QXR0ciIsImhlaWdodCIsInZpZXdCb3giLCJ3IiwidlciLCJ2SCIsImdldFBhdGgiLCJwYXRoIiwicGVyY2VudCIsInByb3BlcnR5IiwiZ2V0UGF0aFByb2dyZXNzIiwiaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHIiwicG9pbnQiLCJvZmZzZXQiLCJnZXRQb2ludEF0TGVuZ3RoIiwicDAiLCJzY2FsZVgiLCJzY2FsZVkiLCJhdGFuMiIsImRlY29tcG9zZVZhbHVlIiwib3JpZ2luYWwiLCJudW1iZXJzIiwiTnVtYmVyIiwic3RyaW5ncyIsInBhcnNlVGFyZ2V0cyIsInRhcmdldHMiLCJ0YXJnZXRzQXJyYXkiLCJpdGVtIiwicG9zIiwic2VsZiIsImdldEFuaW1hdGFibGVzIiwicGFyc2VkIiwibm9ybWFsaXplUHJvcGVydHlUd2VlbnMiLCJ0d2VlblNldHRpbmdzIiwic2V0dGluZ3MiLCJpc0Zyb21UbyIsInByb3BBcnJheSIsInYiLCJrIiwiZmxhdHRlbktleWZyYW1lcyIsImtleWZyYW1lcyIsInByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0aWVzIiwibmV3S2V5IiwiZ2V0UHJvcGVydGllcyIsInR3ZWVucyIsIm5vcm1hbGl6ZVR3ZWVuVmFsdWVzIiwidHdlZW4iLCJub3JtYWxpemVUd2VlbnMiLCJwcmV2aW91c1R3ZWVuIiwidHdlZW5WYWx1ZSIsInRvVW5pdCIsIm9yaWdpbmFsVmFsdWUiLCJwcmV2aW91c1ZhbHVlIiwiZnJvbVVuaXQiLCJzdGFydCIsImVuZCIsImlzUGF0aCIsImlzQ29sb3IiLCJzZXRQcm9ncmVzc1ZhbHVlIiwiY3NzIiwiYXR0cmlidXRlIiwib2JqZWN0IiwibWFudWFsIiwibGFzdCIsInNldFRhcmdldHNWYWx1ZSIsImFuaW1hdGFibGVzIiwiYW5pbVR5cGUiLCJjcmVhdGVBbmltYXRpb24iLCJsYXN0VHdlZW4iLCJ0eXBlIiwiZ2V0QW5pbWF0aW9ucyIsImdldEluc3RhbmNlVGltaW5ncyIsImFuaW1hdGlvbnMiLCJhbmltTGVuZ3RoIiwiZ2V0VGxPZmZzZXQiLCJhbmltIiwidGltaW5ncyIsImluc3RhbmNlSUQiLCJjcmVhdGVOZXdJbnN0YW5jZSIsImluc3RhbmNlU2V0dGluZ3MiLCJjaGlsZHJlbiIsImFjdGl2ZUluc3RhbmNlcyIsImVuZ2luZSIsInJhZiIsInBsYXkiLCJpc0RvY3VtZW50SGlkZGVuIiwiYW5pbWUiLCJzdXNwZW5kV2hlbkRvY3VtZW50SGlkZGVuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic3RlcCIsImFjdGl2ZUluc3RhbmNlc0xlbmd0aCIsImFjdGl2ZUluc3RhbmNlIiwicGF1c2VkIiwidGljayIsInNwbGljZSIsInVuZGVmaW5lZCIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImluc3RhbmNlIiwiX29uRG9jdW1lbnRWaXNpYmlsaXR5IiwiYWRkRXZlbnRMaXN0ZW5lciIsImhpZGRlbiIsInN0YXJ0VGltZSIsImxhc3RUaW1lIiwibm93IiwiY2hpbGRyZW5MZW5ndGgiLCJyZXNvbHZlIiwibWFrZVByb21pc2UiLCJwcm9taXNlIiwid2luZG93IiwiUHJvbWlzZSIsIl9yZXNvbHZlIiwiZmluaXNoZWQiLCJ0b2dnbGVJbnN0YW5jZURpcmVjdGlvbiIsInJldmVyc2VkIiwiY2hpbGQiLCJhZGp1c3RUaW1lIiwidGltZSIsInJlc2V0VGltZSIsImN1cnJlbnRUaW1lIiwic3BlZWQiLCJzZWVrQ2hpbGQiLCJzZWVrIiwic3luY0luc3RhbmNlQ2hpbGRyZW4iLCJyZXZlcnNlUGxheWJhY2siLCJpJDEiLCJzZXRBbmltYXRpb25zUHJvZ3Jlc3MiLCJpbnNUaW1lIiwiYW5pbWF0aW9uc0xlbmd0aCIsInR3ZWVuTGVuZ3RoIiwiZWFzZWQiLCJpc05hTiIsInRvTnVtYmVyc0xlbmd0aCIsIm4iLCJ0b051bWJlciIsImZyb21OdW1iZXIiLCJzdHJpbmdzTGVuZ3RoIiwibiQxIiwiY3VycmVudFZhbHVlIiwic2V0Q2FsbGJhY2siLCJjYiIsInBhc3NUaHJvdWdoIiwiY291bnRJdGVyYXRpb24iLCJyZW1haW5pbmciLCJzZXRJbnN0YW5jZVByb2dyZXNzIiwiZW5naW5lVGltZSIsImluc0R1cmF0aW9uIiwiaW5zRGVsYXkiLCJpbnNFbmREZWxheSIsImJlZ2FuIiwibG9vcEJlZ2FuIiwiY2hhbmdlQmVnYW4iLCJjaGFuZ2VDb21wbGV0ZWQiLCJjb21wbGV0ZWQiLCJyZXNldCIsInBhdXNlIiwicmV2ZXJzZSIsInJlc3RhcnQiLCJyZW1vdmUiLCJyZW1vdmVUYXJnZXRzRnJvbUluc3RhbmNlIiwicmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zIiwiYyIsImNoaWxkQW5pbWF0aW9ucyIsInJlbW92ZVRhcmdldHNGcm9tQWN0aXZlSW5zdGFuY2VzIiwic3RhZ2dlciIsImdyaWQiLCJheGlzIiwiZnJvbUluZGV4IiwiZnJvbUZpcnN0IiwiZnJvbUNlbnRlciIsImZyb21MYXN0IiwiaXNSYW5nZSIsInZhbDEiLCJ2YWwyIiwidmFsdWVzIiwibWF4VmFsdWUiLCJpbmRleCIsImZyb21YIiwiZnJvbVkiLCJmbG9vciIsInRvWCIsInRvWSIsImRpc3RhbmNlWCIsImRpc3RhbmNlWSIsInNwYWNpbmciLCJ0aW1lbGluZSIsInRsIiwiYWRkIiwiaW5zdGFuY2VQYXJhbXMiLCJ0bEluZGV4IiwiaW5zIiwiaW5zUGFyYW1zIiwidGxEdXJhdGlvbiIsInZlcnNpb24iLCJydW5uaW5nIiwiY29udmVydFB4IiwicmFuZG9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/animejs/lib/anime.es.js\n");

/***/ })

};
;