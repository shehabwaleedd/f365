"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/../../../node_modules/animejs/lib/anime.es.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/animejs/lib/anime.es.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/*\n * anime.js v3.2.1\n * (c) 2020 Julian Garnier\n * Released under the MIT license\n * animejs.com\n */ // Defaults\nvar defaultInstanceSettings = {\n    update: null,\n    begin: null,\n    loopBegin: null,\n    changeBegin: null,\n    change: null,\n    changeComplete: null,\n    loopComplete: null,\n    complete: null,\n    loop: 1,\n    direction: \"normal\",\n    autoplay: true,\n    timelineOffset: 0\n};\nvar defaultTweenSettings = {\n    duration: 1000,\n    delay: 0,\n    endDelay: 0,\n    easing: \"easeOutElastic(1, .5)\",\n    round: 0\n};\nvar validTransforms = [\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"scaleZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n    \"perspective\",\n    \"matrix\",\n    \"matrix3d\"\n];\n// Caching\nvar cache = {\n    CSS: {},\n    springs: {}\n};\n// Utils\nfunction minMax(val, min, max) {\n    return Math.min(Math.max(val, min), max);\n}\nfunction stringContains(str, text) {\n    return str.indexOf(text) > -1;\n}\nfunction applyArguments(func, args) {\n    return func.apply(null, args);\n}\nvar is = {\n    arr: function(a) {\n        return Array.isArray(a);\n    },\n    obj: function(a) {\n        return stringContains(Object.prototype.toString.call(a), \"Object\");\n    },\n    pth: function(a) {\n        return is.obj(a) && a.hasOwnProperty(\"totalLength\");\n    },\n    svg: function(a) {\n        return a instanceof SVGElement;\n    },\n    inp: function(a) {\n        return a instanceof HTMLInputElement;\n    },\n    dom: function(a) {\n        return a.nodeType || is.svg(a);\n    },\n    str: function(a) {\n        return typeof a === \"string\";\n    },\n    fnc: function(a) {\n        return typeof a === \"function\";\n    },\n    und: function(a) {\n        return typeof a === \"undefined\";\n    },\n    nil: function(a) {\n        return is.und(a) || a === null;\n    },\n    hex: function(a) {\n        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);\n    },\n    rgb: function(a) {\n        return /^rgb/.test(a);\n    },\n    hsl: function(a) {\n        return /^hsl/.test(a);\n    },\n    col: function(a) {\n        return is.hex(a) || is.rgb(a) || is.hsl(a);\n    },\n    key: function(a) {\n        return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== \"targets\" && a !== \"keyframes\";\n    }\n};\n// Easings\nfunction parseEasingParameters(string) {\n    var match = /\\(([^)]+)\\)/.exec(string);\n    return match ? match[1].split(\",\").map(function(p) {\n        return parseFloat(p);\n    }) : [];\n}\n// Spring solver inspired by Webkit Copyright Â© 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js\nfunction spring(string, duration) {\n    var params = parseEasingParameters(string);\n    var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);\n    var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);\n    var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);\n    var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);\n    var w0 = Math.sqrt(stiffness / mass);\n    var zeta = damping / (2 * Math.sqrt(stiffness * mass));\n    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;\n    var a = 1;\n    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;\n    function solver(t) {\n        var progress = duration ? duration * t / 1000 : t;\n        if (zeta < 1) {\n            progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));\n        } else {\n            progress = (a + b * progress) * Math.exp(-progress * w0);\n        }\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        return 1 - progress;\n    }\n    function getDuration() {\n        var cached = cache.springs[string];\n        if (cached) {\n            return cached;\n        }\n        var frame = 1 / 6;\n        var elapsed = 0;\n        var rest = 0;\n        while(true){\n            elapsed += frame;\n            if (solver(elapsed) === 1) {\n                rest++;\n                if (rest >= 16) {\n                    break;\n                }\n            } else {\n                rest = 0;\n            }\n        }\n        var duration = elapsed * frame * 1000;\n        cache.springs[string] = duration;\n        return duration;\n    }\n    return duration ? solver : getDuration;\n}\n// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\nfunction steps(steps) {\n    if (steps === void 0) steps = 10;\n    return function(t) {\n        return Math.ceil(minMax(t, 0.000001, 1) * steps) * (1 / steps);\n    };\n}\n// BezierEasing https://github.com/gre/bezier-easing\nvar bezier = function() {\n    var kSplineTableSize = 11;\n    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n    function A(aA1, aA2) {\n        return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n    function B(aA1, aA2) {\n        return 3.0 * aA2 - 6.0 * aA1;\n    }\n    function C(aA1) {\n        return 3.0 * aA1;\n    }\n    function calcBezier(aT, aA1, aA2) {\n        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    }\n    function getSlope(aT, aA1, aA2) {\n        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n    function binarySubdivide(aX, aA, aB, mX1, mX2) {\n        var currentX, currentT, i = 0;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        }while (Math.abs(currentX) > 0.0000001 && ++i < 10);\n        return currentT;\n    }\n    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n        for(var i = 0; i < 4; ++i){\n            var currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    }\n    function bezier(mX1, mY1, mX2, mY2) {\n        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n            return;\n        }\n        var sampleValues = new Float32Array(kSplineTableSize);\n        if (mX1 !== mY1 || mX2 !== mY2) {\n            for(var i = 0; i < kSplineTableSize; ++i){\n                sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n            }\n        }\n        function getTForX(aX) {\n            var intervalStart = 0;\n            var currentSample = 1;\n            var lastSample = kSplineTableSize - 1;\n            for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n                intervalStart += kSampleStepSize;\n            }\n            --currentSample;\n            var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n            var guessForT = intervalStart + dist * kSampleStepSize;\n            var initialSlope = getSlope(guessForT, mX1, mX2);\n            if (initialSlope >= 0.001) {\n                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n            } else if (initialSlope === 0.0) {\n                return guessForT;\n            } else {\n                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n            }\n        }\n        return function(x) {\n            if (mX1 === mY1 && mX2 === mY2) {\n                return x;\n            }\n            if (x === 0 || x === 1) {\n                return x;\n            }\n            return calcBezier(getTForX(x), mY1, mY2);\n        };\n    }\n    return bezier;\n}();\nvar penner = function() {\n    // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)\n    var eases = {\n        linear: function() {\n            return function(t) {\n                return t;\n            };\n        }\n    };\n    var functionEasings = {\n        Sine: function() {\n            return function(t) {\n                return 1 - Math.cos(t * Math.PI / 2);\n            };\n        },\n        Circ: function() {\n            return function(t) {\n                return 1 - Math.sqrt(1 - t * t);\n            };\n        },\n        Back: function() {\n            return function(t) {\n                return t * t * (3 * t - 2);\n            };\n        },\n        Bounce: function() {\n            return function(t) {\n                var pow2, b = 4;\n                while(t < ((pow2 = Math.pow(2, --b)) - 1) / 11){}\n                return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);\n            };\n        },\n        Elastic: function(amplitude, period) {\n            if (amplitude === void 0) amplitude = 1;\n            if (period === void 0) period = .5;\n            var a = minMax(amplitude, 1, 10);\n            var p = minMax(period, .1, 2);\n            return function(t) {\n                return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);\n            };\n        }\n    };\n    var baseEasings = [\n        \"Quad\",\n        \"Cubic\",\n        \"Quart\",\n        \"Quint\",\n        \"Expo\"\n    ];\n    baseEasings.forEach(function(name, i) {\n        functionEasings[name] = function() {\n            return function(t) {\n                return Math.pow(t, i + 2);\n            };\n        };\n    });\n    Object.keys(functionEasings).forEach(function(name) {\n        var easeIn = functionEasings[name];\n        eases[\"easeIn\" + name] = easeIn;\n        eases[\"easeOut\" + name] = function(a, b) {\n            return function(t) {\n                return 1 - easeIn(a, b)(1 - t);\n            };\n        };\n        eases[\"easeInOut\" + name] = function(a, b) {\n            return function(t) {\n                return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;\n            };\n        };\n        eases[\"easeOutIn\" + name] = function(a, b) {\n            return function(t) {\n                return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : (easeIn(a, b)(t * 2 - 1) + 1) / 2;\n            };\n        };\n    });\n    return eases;\n}();\nfunction parseEasings(easing, duration) {\n    if (is.fnc(easing)) {\n        return easing;\n    }\n    var name = easing.split(\"(\")[0];\n    var ease = penner[name];\n    var args = parseEasingParameters(easing);\n    switch(name){\n        case \"spring\":\n            return spring(easing, duration);\n        case \"cubicBezier\":\n            return applyArguments(bezier, args);\n        case \"steps\":\n            return applyArguments(steps, args);\n        default:\n            return applyArguments(ease, args);\n    }\n}\n// Strings\nfunction selectString(str) {\n    try {\n        var nodes = document.querySelectorAll(str);\n        return nodes;\n    } catch (e) {\n        return;\n    }\n}\n// Arrays\nfunction filterArray(arr, callback) {\n    var len = arr.length;\n    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n    var result = [];\n    for(var i = 0; i < len; i++){\n        if (i in arr) {\n            var val = arr[i];\n            if (callback.call(thisArg, val, i, arr)) {\n                result.push(val);\n            }\n        }\n    }\n    return result;\n}\nfunction flattenArray(arr) {\n    return arr.reduce(function(a, b) {\n        return a.concat(is.arr(b) ? flattenArray(b) : b);\n    }, []);\n}\nfunction toArray(o) {\n    if (is.arr(o)) {\n        return o;\n    }\n    if (is.str(o)) {\n        o = selectString(o) || o;\n    }\n    if (o instanceof NodeList || o instanceof HTMLCollection) {\n        return [].slice.call(o);\n    }\n    return [\n        o\n    ];\n}\nfunction arrayContains(arr, val) {\n    return arr.some(function(a) {\n        return a === val;\n    });\n}\n// Objects\nfunction cloneObject(o) {\n    var clone = {};\n    for(var p in o){\n        clone[p] = o[p];\n    }\n    return clone;\n}\nfunction replaceObjectProps(o1, o2) {\n    var o = cloneObject(o1);\n    for(var p in o1){\n        o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];\n    }\n    return o;\n}\nfunction mergeObjects(o1, o2) {\n    var o = cloneObject(o1);\n    for(var p in o2){\n        o[p] = is.und(o1[p]) ? o2[p] : o1[p];\n    }\n    return o;\n}\n// Colors\nfunction rgbToRgba(rgbValue) {\n    var rgb = /rgb\\((\\d+,\\s*[\\d]+,\\s*[\\d]+)\\)/g.exec(rgbValue);\n    return rgb ? \"rgba(\" + rgb[1] + \",1)\" : rgbValue;\n}\nfunction hexToRgba(hexValue) {\n    var rgx = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    var hex = hexValue.replace(rgx, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n    });\n    var rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    var r = parseInt(rgb[1], 16);\n    var g = parseInt(rgb[2], 16);\n    var b = parseInt(rgb[3], 16);\n    return \"rgba(\" + r + \",\" + g + \",\" + b + \",1)\";\n}\nfunction hslToRgba(hslValue) {\n    var hsl = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(hslValue) || /hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*([\\d.]+)\\)/g.exec(hslValue);\n    var h = parseInt(hsl[1], 10) / 360;\n    var s = parseInt(hsl[2], 10) / 100;\n    var l = parseInt(hsl[3], 10) / 100;\n    var a = hsl[4] || 1;\n    function hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    var r, g, b;\n    if (s == 0) {\n        r = g = b = l;\n    } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return \"rgba(\" + r * 255 + \",\" + g * 255 + \",\" + b * 255 + \",\" + a + \")\";\n}\nfunction colorToRgb(val) {\n    if (is.rgb(val)) {\n        return rgbToRgba(val);\n    }\n    if (is.hex(val)) {\n        return hexToRgba(val);\n    }\n    if (is.hsl(val)) {\n        return hslToRgba(val);\n    }\n}\n// Units\nfunction getUnit(val) {\n    var split = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);\n    if (split) {\n        return split[1];\n    }\n}\nfunction getTransformUnit(propName) {\n    if (stringContains(propName, \"translate\") || propName === \"perspective\") {\n        return \"px\";\n    }\n    if (stringContains(propName, \"rotate\") || stringContains(propName, \"skew\")) {\n        return \"deg\";\n    }\n}\n// Values\nfunction getFunctionValue(val, animatable) {\n    if (!is.fnc(val)) {\n        return val;\n    }\n    return val(animatable.target, animatable.id, animatable.total);\n}\nfunction getAttribute(el, prop) {\n    return el.getAttribute(prop);\n}\nfunction convertPxToUnit(el, value, unit) {\n    var valueUnit = getUnit(value);\n    if (arrayContains([\n        unit,\n        \"deg\",\n        \"rad\",\n        \"turn\"\n    ], valueUnit)) {\n        return value;\n    }\n    var cached = cache.CSS[value + unit];\n    if (!is.und(cached)) {\n        return cached;\n    }\n    var baseline = 100;\n    var tempEl = document.createElement(el.tagName);\n    var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;\n    parentEl.appendChild(tempEl);\n    tempEl.style.position = \"absolute\";\n    tempEl.style.width = baseline + unit;\n    var factor = baseline / tempEl.offsetWidth;\n    parentEl.removeChild(tempEl);\n    var convertedUnit = factor * parseFloat(value);\n    cache.CSS[value + unit] = convertedUnit;\n    return convertedUnit;\n}\nfunction getCSSValue(el, prop, unit) {\n    if (prop in el.style) {\n        var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n        var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || \"0\";\n        return unit ? convertPxToUnit(el, value, unit) : value;\n    }\n}\nfunction getAnimationType(el, prop) {\n    if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || is.svg(el) && el[prop])) {\n        return \"attribute\";\n    }\n    if (is.dom(el) && arrayContains(validTransforms, prop)) {\n        return \"transform\";\n    }\n    if (is.dom(el) && prop !== \"transform\" && getCSSValue(el, prop)) {\n        return \"css\";\n    }\n    if (el[prop] != null) {\n        return \"object\";\n    }\n}\nfunction getElementTransforms(el) {\n    if (!is.dom(el)) {\n        return;\n    }\n    var str = el.style.transform || \"\";\n    var reg = /(\\w+)\\(([^)]*)\\)/g;\n    var transforms = new Map();\n    var m;\n    while(m = reg.exec(str)){\n        transforms.set(m[1], m[2]);\n    }\n    return transforms;\n}\nfunction getTransformValue(el, propName, animatable, unit) {\n    var defaultVal = stringContains(propName, \"scale\") ? 1 : 0 + getTransformUnit(propName);\n    var value = getElementTransforms(el).get(propName) || defaultVal;\n    if (animatable) {\n        animatable.transforms.list.set(propName, value);\n        animatable.transforms[\"last\"] = propName;\n    }\n    return unit ? convertPxToUnit(el, value, unit) : value;\n}\nfunction getOriginalTargetValue(target, propName, unit, animatable) {\n    switch(getAnimationType(target, propName)){\n        case \"transform\":\n            return getTransformValue(target, propName, animatable, unit);\n        case \"css\":\n            return getCSSValue(target, propName, unit);\n        case \"attribute\":\n            return getAttribute(target, propName);\n        default:\n            return target[propName] || 0;\n    }\n}\nfunction getRelativeValue(to, from) {\n    var operator = /^(\\*=|\\+=|-=)/.exec(to);\n    if (!operator) {\n        return to;\n    }\n    var u = getUnit(to) || 0;\n    var x = parseFloat(from);\n    var y = parseFloat(to.replace(operator[0], \"\"));\n    switch(operator[0][0]){\n        case \"+\":\n            return x + y + u;\n        case \"-\":\n            return x - y + u;\n        case \"*\":\n            return x * y + u;\n    }\n}\nfunction validateValue(val, unit) {\n    if (is.col(val)) {\n        return colorToRgb(val);\n    }\n    if (/\\s/g.test(val)) {\n        return val;\n    }\n    var originalUnit = getUnit(val);\n    var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;\n    if (unit) {\n        return unitLess + unit;\n    }\n    return unitLess;\n}\n// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes\n// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744\nfunction getDistance(p1, p2) {\n    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\nfunction getCircleLength(el) {\n    return Math.PI * 2 * getAttribute(el, \"r\");\n}\nfunction getRectLength(el) {\n    return getAttribute(el, \"width\") * 2 + getAttribute(el, \"height\") * 2;\n}\nfunction getLineLength(el) {\n    return getDistance({\n        x: getAttribute(el, \"x1\"),\n        y: getAttribute(el, \"y1\")\n    }, {\n        x: getAttribute(el, \"x2\"),\n        y: getAttribute(el, \"y2\")\n    });\n}\nfunction getPolylineLength(el) {\n    var points = el.points;\n    var totalLength = 0;\n    var previousPos;\n    for(var i = 0; i < points.numberOfItems; i++){\n        var currentPos = points.getItem(i);\n        if (i > 0) {\n            totalLength += getDistance(previousPos, currentPos);\n        }\n        previousPos = currentPos;\n    }\n    return totalLength;\n}\nfunction getPolygonLength(el) {\n    var points = el.points;\n    return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));\n}\n// Path animation\nfunction getTotalLength(el) {\n    if (el.getTotalLength) {\n        return el.getTotalLength();\n    }\n    switch(el.tagName.toLowerCase()){\n        case \"circle\":\n            return getCircleLength(el);\n        case \"rect\":\n            return getRectLength(el);\n        case \"line\":\n            return getLineLength(el);\n        case \"polyline\":\n            return getPolylineLength(el);\n        case \"polygon\":\n            return getPolygonLength(el);\n    }\n}\nfunction setDashoffset(el) {\n    var pathLength = getTotalLength(el);\n    el.setAttribute(\"stroke-dasharray\", pathLength);\n    return pathLength;\n}\n// Motion path\nfunction getParentSvgEl(el) {\n    var parentEl = el.parentNode;\n    while(is.svg(parentEl)){\n        if (!is.svg(parentEl.parentNode)) {\n            break;\n        }\n        parentEl = parentEl.parentNode;\n    }\n    return parentEl;\n}\nfunction getParentSvg(pathEl, svgData) {\n    var svg = svgData || {};\n    var parentSvgEl = svg.el || getParentSvgEl(pathEl);\n    var rect = parentSvgEl.getBoundingClientRect();\n    var viewBoxAttr = getAttribute(parentSvgEl, \"viewBox\");\n    var width = rect.width;\n    var height = rect.height;\n    var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(\" \") : [\n        0,\n        0,\n        width,\n        height\n    ]);\n    return {\n        el: parentSvgEl,\n        viewBox: viewBox,\n        x: viewBox[0] / 1,\n        y: viewBox[1] / 1,\n        w: width,\n        h: height,\n        vW: viewBox[2],\n        vH: viewBox[3]\n    };\n}\nfunction getPath(path, percent) {\n    var pathEl = is.str(path) ? selectString(path)[0] : path;\n    var p = percent || 100;\n    return function(property) {\n        return {\n            property: property,\n            el: pathEl,\n            svg: getParentSvg(pathEl),\n            totalLength: getTotalLength(pathEl) * (p / 100)\n        };\n    };\n}\nfunction getPathProgress(path, progress, isPathTargetInsideSVG) {\n    function point(offset) {\n        if (offset === void 0) offset = 0;\n        var l = progress + offset >= 1 ? progress + offset : 0;\n        return path.el.getPointAtLength(l);\n    }\n    var svg = getParentSvg(path.el, path.svg);\n    var p = point();\n    var p0 = point(-1);\n    var p1 = point(+1);\n    var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;\n    var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;\n    switch(path.property){\n        case \"x\":\n            return (p.x - svg.x) * scaleX;\n        case \"y\":\n            return (p.y - svg.y) * scaleY;\n        case \"angle\":\n            return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;\n    }\n}\n// Decompose value\nfunction decomposeValue(val, unit) {\n    // const rgx = /-?\\d*\\.?\\d+/g; // handles basic numbers\n    // const rgx = /[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n    var rgx = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n    var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + \"\";\n    return {\n        original: value,\n        numbers: value.match(rgx) ? value.match(rgx).map(Number) : [\n            0\n        ],\n        strings: is.str(val) || unit ? value.split(rgx) : []\n    };\n}\n// Animatables\nfunction parseTargets(targets) {\n    var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];\n    return filterArray(targetsArray, function(item, pos, self) {\n        return self.indexOf(item) === pos;\n    });\n}\nfunction getAnimatables(targets) {\n    var parsed = parseTargets(targets);\n    return parsed.map(function(t, i) {\n        return {\n            target: t,\n            id: i,\n            total: parsed.length,\n            transforms: {\n                list: getElementTransforms(t)\n            }\n        };\n    });\n}\n// Properties\nfunction normalizePropertyTweens(prop, tweenSettings) {\n    var settings = cloneObject(tweenSettings);\n    // Override duration if easing is a spring\n    if (/^spring/.test(settings.easing)) {\n        settings.duration = spring(settings.easing);\n    }\n    if (is.arr(prop)) {\n        var l = prop.length;\n        var isFromTo = l === 2 && !is.obj(prop[0]);\n        if (!isFromTo) {\n            // Duration divided by the number of tweens\n            if (!is.fnc(tweenSettings.duration)) {\n                settings.duration = tweenSettings.duration / l;\n            }\n        } else {\n            // Transform [from, to] values shorthand to a valid tween value\n            prop = {\n                value: prop\n            };\n        }\n    }\n    var propArray = is.arr(prop) ? prop : [\n        prop\n    ];\n    return propArray.map(function(v, i) {\n        var obj = is.obj(v) && !is.pth(v) ? v : {\n            value: v\n        };\n        // Default delay value should only be applied to the first tween\n        if (is.und(obj.delay)) {\n            obj.delay = !i ? tweenSettings.delay : 0;\n        }\n        // Default endDelay value should only be applied to the last tween\n        if (is.und(obj.endDelay)) {\n            obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;\n        }\n        return obj;\n    }).map(function(k) {\n        return mergeObjects(k, settings);\n    });\n}\nfunction flattenKeyframes(keyframes) {\n    var propertyNames = filterArray(flattenArray(keyframes.map(function(key) {\n        return Object.keys(key);\n    })), function(p) {\n        return is.key(p);\n    }).reduce(function(a, b) {\n        if (a.indexOf(b) < 0) {\n            a.push(b);\n        }\n        return a;\n    }, []);\n    var properties = {};\n    var loop = function(i) {\n        var propName = propertyNames[i];\n        properties[propName] = keyframes.map(function(key) {\n            var newKey = {};\n            for(var p in key){\n                if (is.key(p)) {\n                    if (p == propName) {\n                        newKey.value = key[p];\n                    }\n                } else {\n                    newKey[p] = key[p];\n                }\n            }\n            return newKey;\n        });\n    };\n    for(var i = 0; i < propertyNames.length; i++)loop(i);\n    return properties;\n}\nfunction getProperties(tweenSettings, params) {\n    var properties = [];\n    var keyframes = params.keyframes;\n    if (keyframes) {\n        params = mergeObjects(flattenKeyframes(keyframes), params);\n    }\n    for(var p in params){\n        if (is.key(p)) {\n            properties.push({\n                name: p,\n                tweens: normalizePropertyTweens(params[p], tweenSettings)\n            });\n        }\n    }\n    return properties;\n}\n// Tweens\nfunction normalizeTweenValues(tween, animatable) {\n    var t = {};\n    for(var p in tween){\n        var value = getFunctionValue(tween[p], animatable);\n        if (is.arr(value)) {\n            value = value.map(function(v) {\n                return getFunctionValue(v, animatable);\n            });\n            if (value.length === 1) {\n                value = value[0];\n            }\n        }\n        t[p] = value;\n    }\n    t.duration = parseFloat(t.duration);\n    t.delay = parseFloat(t.delay);\n    return t;\n}\nfunction normalizeTweens(prop, animatable) {\n    var previousTween;\n    return prop.tweens.map(function(t) {\n        var tween = normalizeTweenValues(t, animatable);\n        var tweenValue = tween.value;\n        var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;\n        var toUnit = getUnit(to);\n        var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);\n        var previousValue = previousTween ? previousTween.to.original : originalValue;\n        var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;\n        var fromUnit = getUnit(from) || getUnit(originalValue);\n        var unit = toUnit || fromUnit;\n        if (is.und(to)) {\n            to = previousValue;\n        }\n        tween.from = decomposeValue(from, unit);\n        tween.to = decomposeValue(getRelativeValue(to, from), unit);\n        tween.start = previousTween ? previousTween.end : 0;\n        tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;\n        tween.easing = parseEasings(tween.easing, tween.duration);\n        tween.isPath = is.pth(tweenValue);\n        tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);\n        tween.isColor = is.col(tween.from.original);\n        if (tween.isColor) {\n            tween.round = 1;\n        }\n        previousTween = tween;\n        return tween;\n    });\n}\n// Tween progress\nvar setProgressValue = {\n    css: function(t, p, v) {\n        return t.style[p] = v;\n    },\n    attribute: function(t, p, v) {\n        return t.setAttribute(p, v);\n    },\n    object: function(t, p, v) {\n        return t[p] = v;\n    },\n    transform: function(t, p, v, transforms, manual) {\n        transforms.list.set(p, v);\n        if (p === transforms.last || manual) {\n            var str = \"\";\n            transforms.list.forEach(function(value, prop) {\n                str += prop + \"(\" + value + \") \";\n            });\n            t.style.transform = str;\n        }\n    }\n};\n// Set Value helper\nfunction setTargetsValue(targets, properties) {\n    var animatables = getAnimatables(targets);\n    animatables.forEach(function(animatable) {\n        for(var property in properties){\n            var value = getFunctionValue(properties[property], animatable);\n            var target = animatable.target;\n            var valueUnit = getUnit(value);\n            var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);\n            var unit = valueUnit || getUnit(originalValue);\n            var to = getRelativeValue(validateValue(value, unit), originalValue);\n            var animType = getAnimationType(target, property);\n            setProgressValue[animType](target, property, to, animatable.transforms, true);\n        }\n    });\n}\n// Animations\nfunction createAnimation(animatable, prop) {\n    var animType = getAnimationType(animatable.target, prop.name);\n    if (animType) {\n        var tweens = normalizeTweens(prop, animatable);\n        var lastTween = tweens[tweens.length - 1];\n        return {\n            type: animType,\n            property: prop.name,\n            animatable: animatable,\n            tweens: tweens,\n            duration: lastTween.end,\n            delay: tweens[0].delay,\n            endDelay: lastTween.endDelay\n        };\n    }\n}\nfunction getAnimations(animatables, properties) {\n    return filterArray(flattenArray(animatables.map(function(animatable) {\n        return properties.map(function(prop) {\n            return createAnimation(animatable, prop);\n        });\n    })), function(a) {\n        return !is.und(a);\n    });\n}\n// Create Instance\nfunction getInstanceTimings(animations, tweenSettings) {\n    var animLength = animations.length;\n    var getTlOffset = function(anim) {\n        return anim.timelineOffset ? anim.timelineOffset : 0;\n    };\n    var timings = {};\n    timings.duration = animLength ? Math.max.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.duration;\n    })) : tweenSettings.duration;\n    timings.delay = animLength ? Math.min.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.delay;\n    })) : tweenSettings.delay;\n    timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.duration - anim.endDelay;\n    })) : tweenSettings.endDelay;\n    return timings;\n}\nvar instanceID = 0;\nfunction createNewInstance(params) {\n    var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);\n    var tweenSettings = replaceObjectProps(defaultTweenSettings, params);\n    var properties = getProperties(tweenSettings, params);\n    var animatables = getAnimatables(params.targets);\n    var animations = getAnimations(animatables, properties);\n    var timings = getInstanceTimings(animations, tweenSettings);\n    var id = instanceID;\n    instanceID++;\n    return mergeObjects(instanceSettings, {\n        id: id,\n        children: [],\n        animatables: animatables,\n        animations: animations,\n        duration: timings.duration,\n        delay: timings.delay,\n        endDelay: timings.endDelay\n    });\n}\n// Core\nvar activeInstances = [];\nvar engine = function() {\n    var raf;\n    function play() {\n        if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {\n            raf = requestAnimationFrame(step);\n        }\n    }\n    function step(t) {\n        // memo on algorithm issue:\n        // dangerous iteration over mutable `activeInstances`\n        // (that collection may be updated from within callbacks of `tick`-ed animation instances)\n        var activeInstancesLength = activeInstances.length;\n        var i = 0;\n        while(i < activeInstancesLength){\n            var activeInstance = activeInstances[i];\n            if (!activeInstance.paused) {\n                activeInstance.tick(t);\n                i++;\n            } else {\n                activeInstances.splice(i, 1);\n                activeInstancesLength--;\n            }\n        }\n        raf = i > 0 ? requestAnimationFrame(step) : undefined;\n    }\n    function handleVisibilityChange() {\n        if (!anime.suspendWhenDocumentHidden) {\n            return;\n        }\n        if (isDocumentHidden()) {\n            // suspend ticks\n            raf = cancelAnimationFrame(raf);\n        } else {\n            // first adjust animations to consider the time that ticks were suspended\n            activeInstances.forEach(function(instance) {\n                return instance._onDocumentVisibility();\n            });\n            engine();\n        }\n    }\n    if (typeof document !== \"undefined\") {\n        document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    }\n    return play;\n}();\nfunction isDocumentHidden() {\n    return !!document && document.hidden;\n}\n// Public Instance\nfunction anime(params) {\n    if (params === void 0) params = {};\n    var startTime = 0, lastTime = 0, now = 0;\n    var children, childrenLength = 0;\n    var resolve = null;\n    function makePromise(instance) {\n        var promise = window.Promise && new Promise(function(_resolve) {\n            return resolve = _resolve;\n        });\n        instance.finished = promise;\n        return promise;\n    }\n    var instance = createNewInstance(params);\n    var promise = makePromise(instance);\n    function toggleInstanceDirection() {\n        var direction = instance.direction;\n        if (direction !== \"alternate\") {\n            instance.direction = direction !== \"normal\" ? \"normal\" : \"reverse\";\n        }\n        instance.reversed = !instance.reversed;\n        children.forEach(function(child) {\n            return child.reversed = instance.reversed;\n        });\n    }\n    function adjustTime(time) {\n        return instance.reversed ? instance.duration - time : time;\n    }\n    function resetTime() {\n        startTime = 0;\n        lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);\n    }\n    function seekChild(time, child) {\n        if (child) {\n            child.seek(time - child.timelineOffset);\n        }\n    }\n    function syncInstanceChildren(time) {\n        if (!instance.reversePlayback) {\n            for(var i = 0; i < childrenLength; i++){\n                seekChild(time, children[i]);\n            }\n        } else {\n            for(var i$1 = childrenLength; i$1--;){\n                seekChild(time, children[i$1]);\n            }\n        }\n    }\n    function setAnimationsProgress(insTime) {\n        var i = 0;\n        var animations = instance.animations;\n        var animationsLength = animations.length;\n        while(i < animationsLength){\n            var anim = animations[i];\n            var animatable = anim.animatable;\n            var tweens = anim.tweens;\n            var tweenLength = tweens.length - 1;\n            var tween = tweens[tweenLength];\n            // Only check for keyframes if there is more than one tween\n            if (tweenLength) {\n                tween = filterArray(tweens, function(t) {\n                    return insTime < t.end;\n                })[0] || tween;\n            }\n            var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;\n            var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);\n            var strings = tween.to.strings;\n            var round = tween.round;\n            var numbers = [];\n            var toNumbersLength = tween.to.numbers.length;\n            var progress = void 0;\n            for(var n = 0; n < toNumbersLength; n++){\n                var value = void 0;\n                var toNumber = tween.to.numbers[n];\n                var fromNumber = tween.from.numbers[n] || 0;\n                if (!tween.isPath) {\n                    value = fromNumber + eased * (toNumber - fromNumber);\n                } else {\n                    value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);\n                }\n                if (round) {\n                    if (!(tween.isColor && n > 2)) {\n                        value = Math.round(value * round) / round;\n                    }\n                }\n                numbers.push(value);\n            }\n            // Manual Array.reduce for better performances\n            var stringsLength = strings.length;\n            if (!stringsLength) {\n                progress = numbers[0];\n            } else {\n                progress = strings[0];\n                for(var s = 0; s < stringsLength; s++){\n                    var a = strings[s];\n                    var b = strings[s + 1];\n                    var n$1 = numbers[s];\n                    if (!isNaN(n$1)) {\n                        if (!b) {\n                            progress += n$1 + \" \";\n                        } else {\n                            progress += n$1 + b;\n                        }\n                    }\n                }\n            }\n            setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);\n            anim.currentValue = progress;\n            i++;\n        }\n    }\n    function setCallback(cb) {\n        if (instance[cb] && !instance.passThrough) {\n            instance[cb](instance);\n        }\n    }\n    function countIteration() {\n        if (instance.remaining && instance.remaining !== true) {\n            instance.remaining--;\n        }\n    }\n    function setInstanceProgress(engineTime) {\n        var insDuration = instance.duration;\n        var insDelay = instance.delay;\n        var insEndDelay = insDuration - instance.endDelay;\n        var insTime = adjustTime(engineTime);\n        instance.progress = minMax(insTime / insDuration * 100, 0, 100);\n        instance.reversePlayback = insTime < instance.currentTime;\n        if (children) {\n            syncInstanceChildren(insTime);\n        }\n        if (!instance.began && instance.currentTime > 0) {\n            instance.began = true;\n            setCallback(\"begin\");\n        }\n        if (!instance.loopBegan && instance.currentTime > 0) {\n            instance.loopBegan = true;\n            setCallback(\"loopBegin\");\n        }\n        if (insTime <= insDelay && instance.currentTime !== 0) {\n            setAnimationsProgress(0);\n        }\n        if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {\n            setAnimationsProgress(insDuration);\n        }\n        if (insTime > insDelay && insTime < insEndDelay) {\n            if (!instance.changeBegan) {\n                instance.changeBegan = true;\n                instance.changeCompleted = false;\n                setCallback(\"changeBegin\");\n            }\n            setCallback(\"change\");\n            setAnimationsProgress(insTime);\n        } else {\n            if (instance.changeBegan) {\n                instance.changeCompleted = true;\n                instance.changeBegan = false;\n                setCallback(\"changeComplete\");\n            }\n        }\n        instance.currentTime = minMax(insTime, 0, insDuration);\n        if (instance.began) {\n            setCallback(\"update\");\n        }\n        if (engineTime >= insDuration) {\n            lastTime = 0;\n            countIteration();\n            if (!instance.remaining) {\n                instance.paused = true;\n                if (!instance.completed) {\n                    instance.completed = true;\n                    setCallback(\"loopComplete\");\n                    setCallback(\"complete\");\n                    if (!instance.passThrough && \"Promise\" in window) {\n                        resolve();\n                        promise = makePromise(instance);\n                    }\n                }\n            } else {\n                startTime = now;\n                setCallback(\"loopComplete\");\n                instance.loopBegan = false;\n                if (instance.direction === \"alternate\") {\n                    toggleInstanceDirection();\n                }\n            }\n        }\n    }\n    instance.reset = function() {\n        var direction = instance.direction;\n        instance.passThrough = false;\n        instance.currentTime = 0;\n        instance.progress = 0;\n        instance.paused = true;\n        instance.began = false;\n        instance.loopBegan = false;\n        instance.changeBegan = false;\n        instance.completed = false;\n        instance.changeCompleted = false;\n        instance.reversePlayback = false;\n        instance.reversed = direction === \"reverse\";\n        instance.remaining = instance.loop;\n        children = instance.children;\n        childrenLength = children.length;\n        for(var i = childrenLength; i--;){\n            instance.children[i].reset();\n        }\n        if (instance.reversed && instance.loop !== true || direction === \"alternate\" && instance.loop === 1) {\n            instance.remaining++;\n        }\n        setAnimationsProgress(instance.reversed ? instance.duration : 0);\n    };\n    // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)\n    instance._onDocumentVisibility = resetTime;\n    // Set Value helper\n    instance.set = function(targets, properties) {\n        setTargetsValue(targets, properties);\n        return instance;\n    };\n    instance.tick = function(t) {\n        now = t;\n        if (!startTime) {\n            startTime = now;\n        }\n        setInstanceProgress((now + (lastTime - startTime)) * anime.speed);\n    };\n    instance.seek = function(time) {\n        setInstanceProgress(adjustTime(time));\n    };\n    instance.pause = function() {\n        instance.paused = true;\n        resetTime();\n    };\n    instance.play = function() {\n        if (!instance.paused) {\n            return;\n        }\n        if (instance.completed) {\n            instance.reset();\n        }\n        instance.paused = false;\n        activeInstances.push(instance);\n        resetTime();\n        engine();\n    };\n    instance.reverse = function() {\n        toggleInstanceDirection();\n        instance.completed = instance.reversed ? false : true;\n        resetTime();\n    };\n    instance.restart = function() {\n        instance.reset();\n        instance.play();\n    };\n    instance.remove = function(targets) {\n        var targetsArray = parseTargets(targets);\n        removeTargetsFromInstance(targetsArray, instance);\n    };\n    instance.reset();\n    if (instance.autoplay) {\n        instance.play();\n    }\n    return instance;\n}\n// Remove targets from animation\nfunction removeTargetsFromAnimations(targetsArray, animations) {\n    for(var a = animations.length; a--;){\n        if (arrayContains(targetsArray, animations[a].animatable.target)) {\n            animations.splice(a, 1);\n        }\n    }\n}\nfunction removeTargetsFromInstance(targetsArray, instance) {\n    var animations = instance.animations;\n    var children = instance.children;\n    removeTargetsFromAnimations(targetsArray, animations);\n    for(var c = children.length; c--;){\n        var child = children[c];\n        var childAnimations = child.animations;\n        removeTargetsFromAnimations(targetsArray, childAnimations);\n        if (!childAnimations.length && !child.children.length) {\n            children.splice(c, 1);\n        }\n    }\n    if (!animations.length && !children.length) {\n        instance.pause();\n    }\n}\nfunction removeTargetsFromActiveInstances(targets) {\n    var targetsArray = parseTargets(targets);\n    for(var i = activeInstances.length; i--;){\n        var instance = activeInstances[i];\n        removeTargetsFromInstance(targetsArray, instance);\n    }\n}\n// Stagger helpers\nfunction stagger(val, params) {\n    if (params === void 0) params = {};\n    var direction = params.direction || \"normal\";\n    var easing = params.easing ? parseEasings(params.easing) : null;\n    var grid = params.grid;\n    var axis = params.axis;\n    var fromIndex = params.from || 0;\n    var fromFirst = fromIndex === \"first\";\n    var fromCenter = fromIndex === \"center\";\n    var fromLast = fromIndex === \"last\";\n    var isRange = is.arr(val);\n    var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);\n    var val2 = isRange ? parseFloat(val[1]) : 0;\n    var unit = getUnit(isRange ? val[1] : val) || 0;\n    var start = params.start || 0 + (isRange ? val1 : 0);\n    var values = [];\n    var maxValue = 0;\n    return function(el, i, t) {\n        if (fromFirst) {\n            fromIndex = 0;\n        }\n        if (fromCenter) {\n            fromIndex = (t - 1) / 2;\n        }\n        if (fromLast) {\n            fromIndex = t - 1;\n        }\n        if (!values.length) {\n            for(var index = 0; index < t; index++){\n                if (!grid) {\n                    values.push(Math.abs(fromIndex - index));\n                } else {\n                    var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n                    var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n                    var toX = index % grid[0];\n                    var toY = Math.floor(index / grid[0]);\n                    var distanceX = fromX - toX;\n                    var distanceY = fromY - toY;\n                    var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n                    if (axis === \"x\") {\n                        value = -distanceX;\n                    }\n                    if (axis === \"y\") {\n                        value = -distanceY;\n                    }\n                    values.push(value);\n                }\n                maxValue = Math.max.apply(Math, values);\n            }\n            if (easing) {\n                values = values.map(function(val) {\n                    return easing(val / maxValue) * maxValue;\n                });\n            }\n            if (direction === \"reverse\") {\n                values = values.map(function(val) {\n                    return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);\n                });\n            }\n        }\n        var spacing = isRange ? (val2 - val1) / maxValue : val1;\n        return start + spacing * (Math.round(values[i] * 100) / 100) + unit;\n    };\n}\n// Timeline\nfunction timeline(params) {\n    if (params === void 0) params = {};\n    var tl = anime(params);\n    tl.duration = 0;\n    tl.add = function(instanceParams, timelineOffset) {\n        var tlIndex = activeInstances.indexOf(tl);\n        var children = tl.children;\n        if (tlIndex > -1) {\n            activeInstances.splice(tlIndex, 1);\n        }\n        function passThrough(ins) {\n            ins.passThrough = true;\n        }\n        for(var i = 0; i < children.length; i++){\n            passThrough(children[i]);\n        }\n        var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));\n        insParams.targets = insParams.targets || params.targets;\n        var tlDuration = tl.duration;\n        insParams.autoplay = false;\n        insParams.direction = tl.direction;\n        insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);\n        passThrough(tl);\n        tl.seek(insParams.timelineOffset);\n        var ins = anime(insParams);\n        passThrough(ins);\n        children.push(ins);\n        var timings = getInstanceTimings(children, params);\n        tl.delay = timings.delay;\n        tl.endDelay = timings.endDelay;\n        tl.duration = timings.duration;\n        tl.seek(0);\n        tl.reset();\n        if (tl.autoplay) {\n            tl.play();\n        }\n        return tl;\n    };\n    return tl;\n}\nanime.version = \"3.2.1\";\nanime.speed = 1;\n// TODO:#review: naming, documentation\nanime.suspendWhenDocumentHidden = true;\nanime.running = activeInstances;\nanime.remove = removeTargetsFromActiveInstances;\nanime.get = getOriginalTargetValue;\nanime.set = setTargetsValue;\nanime.convertPx = convertPxToUnit;\nanime.path = getPath;\nanime.setDashoffset = setDashoffset;\nanime.stagger = stagger;\nanime.timeline = timeline;\nanime.easing = parseEasings;\nanime.penner = penner;\nanime.random = function(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (anime);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYW5pbWVqcy9saWIvYW5pbWUuZXMuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztDQUtDLEdBRUQsV0FBVztBQUVYLElBQUlBLDBCQUEwQjtJQUM1QkMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxRQUFRO0lBQ1JDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxVQUFVO0lBQ1ZDLGdCQUFnQjtBQUNsQjtBQUVBLElBQUlDLHVCQUF1QjtJQUN6QkMsVUFBVTtJQUNWQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxPQUFPO0FBQ1Q7QUFFQSxJQUFJQyxrQkFBa0I7SUFBQztJQUFjO0lBQWM7SUFBYztJQUFVO0lBQVc7SUFBVztJQUFXO0lBQVM7SUFBVTtJQUFVO0lBQVU7SUFBUTtJQUFTO0lBQVM7SUFBZTtJQUFVO0NBQVc7QUFFak4sVUFBVTtBQUVWLElBQUlDLFFBQVE7SUFDVkMsS0FBSyxDQUFDO0lBQ05DLFNBQVMsQ0FBQztBQUNaO0FBRUEsUUFBUTtBQUVSLFNBQVNDLE9BQU9DLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQzNCLE9BQU9DLEtBQUtGLEdBQUcsQ0FBQ0UsS0FBS0QsR0FBRyxDQUFDRixLQUFLQyxNQUFNQztBQUN0QztBQUVBLFNBQVNFLGVBQWVDLEdBQUcsRUFBRUMsSUFBSTtJQUMvQixPQUFPRCxJQUFJRSxPQUFPLENBQUNELFFBQVEsQ0FBQztBQUM5QjtBQUVBLFNBQVNFLGVBQWVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxPQUFPRCxLQUFLRSxLQUFLLENBQUMsTUFBTUQ7QUFDMUI7QUFFQSxJQUFJRSxLQUFLO0lBQ1BDLEtBQUssU0FBVUMsQ0FBQztRQUFJLE9BQU9DLE1BQU1DLE9BQU8sQ0FBQ0Y7SUFBSTtJQUM3Q0csS0FBSyxTQUFVSCxDQUFD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UUFBUXZWLFFBQVE7UUFDOUJxYyxHQUFHdmMsUUFBUSxHQUFHeVYsUUFBUXpWLFFBQVE7UUFDOUJ1YyxHQUFHaEUsSUFBSSxDQUFDO1FBQ1JnRSxHQUFHaEMsS0FBSztRQUNSLElBQUlnQyxHQUFHMWMsUUFBUSxFQUFFO1lBQUUwYyxHQUFHdEcsSUFBSTtRQUFJO1FBQzlCLE9BQU9zRztJQUNUO0lBQ0EsT0FBT0E7QUFDVDtBQUVBcEcsTUFBTTJHLE9BQU8sR0FBRztBQUNoQjNHLE1BQU1rQyxLQUFLLEdBQUc7QUFDZCxzQ0FBc0M7QUFDdENsQyxNQUFNQyx5QkFBeUIsR0FBRztBQUNsQ0QsTUFBTTRHLE9BQU8sR0FBR2pIO0FBQ2hCSyxNQUFNd0UsTUFBTSxHQUFHSztBQUNmN0UsTUFBTTdILEdBQUcsR0FBR0U7QUFDWjJILE1BQU1oSSxHQUFHLEdBQUcwRztBQUNac0IsTUFBTTZHLFNBQVMsR0FBRzNRO0FBQ2xCOEosTUFBTWhGLElBQUksR0FBR0Q7QUFDYmlGLE1BQU1qRyxhQUFhLEdBQUdBO0FBQ3RCaUcsTUFBTThFLE9BQU8sR0FBR0E7QUFDaEI5RSxNQUFNbUcsUUFBUSxHQUFHQTtBQUNqQm5HLE1BQU1oVyxNQUFNLEdBQUdzSTtBQUNmME4sTUFBTTlPLE1BQU0sR0FBR0E7QUFDZjhPLE1BQU04RyxNQUFNLEdBQUcsU0FBVXRjLEdBQUcsRUFBRUMsR0FBRztJQUFJLE9BQU9DLEtBQUttYixLQUFLLENBQUNuYixLQUFLb2MsTUFBTSxLQUFNcmMsQ0FBQUEsTUFBTUQsTUFBTSxNQUFNQTtBQUFLO0FBRS9GLCtEQUFld1YsS0FBS0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FuaW1lanMvbGliL2FuaW1lLmVzLmpzP2UxZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGFuaW1lLmpzIHYzLjIuMVxuICogKGMpIDIwMjAgSnVsaWFuIEdhcm5pZXJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogYW5pbWVqcy5jb21cbiAqL1xuXG4vLyBEZWZhdWx0c1xuXG52YXIgZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MgPSB7XG4gIHVwZGF0ZTogbnVsbCxcbiAgYmVnaW46IG51bGwsXG4gIGxvb3BCZWdpbjogbnVsbCxcbiAgY2hhbmdlQmVnaW46IG51bGwsXG4gIGNoYW5nZTogbnVsbCxcbiAgY2hhbmdlQ29tcGxldGU6IG51bGwsXG4gIGxvb3BDb21wbGV0ZTogbnVsbCxcbiAgY29tcGxldGU6IG51bGwsXG4gIGxvb3A6IDEsXG4gIGRpcmVjdGlvbjogJ25vcm1hbCcsXG4gIGF1dG9wbGF5OiB0cnVlLFxuICB0aW1lbGluZU9mZnNldDogMFxufTtcblxudmFyIGRlZmF1bHRUd2VlblNldHRpbmdzID0ge1xuICBkdXJhdGlvbjogMTAwMCxcbiAgZGVsYXk6IDAsXG4gIGVuZERlbGF5OiAwLFxuICBlYXNpbmc6ICdlYXNlT3V0RWxhc3RpYygxLCAuNSknLFxuICByb3VuZDogMFxufTtcblxudmFyIHZhbGlkVHJhbnNmb3JtcyA9IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3RyYW5zbGF0ZVonLCAncm90YXRlJywgJ3JvdGF0ZVgnLCAncm90YXRlWScsICdyb3RhdGVaJywgJ3NjYWxlJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnc2NhbGVaJywgJ3NrZXcnLCAnc2tld1gnLCAnc2tld1knLCAncGVyc3BlY3RpdmUnLCAnbWF0cml4JywgJ21hdHJpeDNkJ107XG5cbi8vIENhY2hpbmdcblxudmFyIGNhY2hlID0ge1xuICBDU1M6IHt9LFxuICBzcHJpbmdzOiB7fVxufTtcblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gbWluTWF4KHZhbCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nQ29udGFpbnMoc3RyLCB0ZXh0KSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZih0ZXh0KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBhcHBseUFyZ3VtZW50cyhmdW5jLCBhcmdzKSB7XG4gIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG52YXIgaXMgPSB7XG4gIGFycjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSk7IH0sXG4gIG9iajogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHN0cmluZ0NvbnRhaW5zKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSwgJ09iamVjdCcpOyB9LFxuICBwdGg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBpcy5vYmooYSkgJiYgYS5oYXNPd25Qcm9wZXJ0eSgndG90YWxMZW5ndGgnKTsgfSxcbiAgc3ZnOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7IH0sXG4gIGlucDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50OyB9LFxuICBkb206IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5vZGVUeXBlIHx8IGlzLnN2ZyhhKTsgfSxcbiAgc3RyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICdzdHJpbmcnOyB9LFxuICBmbmM6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgdW5kOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnOyB9LFxuICBuaWw6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBpcy51bmQoYSkgfHwgYSA9PT0gbnVsbDsgfSxcbiAgaGV4OiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoYSk7IH0sXG4gIHJnYjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC9ecmdiLy50ZXN0KGEpOyB9LFxuICBoc2w6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvXmhzbC8udGVzdChhKTsgfSxcbiAgY29sOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKGlzLmhleChhKSB8fCBpcy5yZ2IoYSkgfHwgaXMuaHNsKGEpKTsgfSxcbiAga2V5OiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIWRlZmF1bHRJbnN0YW5jZVNldHRpbmdzLmhhc093blByb3BlcnR5KGEpICYmICFkZWZhdWx0VHdlZW5TZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShhKSAmJiBhICE9PSAndGFyZ2V0cycgJiYgYSAhPT0gJ2tleWZyYW1lcyc7IH0sXG59O1xuXG4vLyBFYXNpbmdzXG5cbmZ1bmN0aW9uIHBhcnNlRWFzaW5nUGFyYW1ldGVycyhzdHJpbmcpIHtcbiAgdmFyIG1hdGNoID0gL1xcKChbXildKylcXCkvLmV4ZWMoc3RyaW5nKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHBhcnNlRmxvYXQocCk7IH0pIDogW107XG59XG5cbi8vIFNwcmluZyBzb2x2ZXIgaW5zcGlyZWQgYnkgV2Via2l0IENvcHlyaWdodCDCqSAyMDE2IEFwcGxlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gaHR0cHM6Ly93ZWJraXQub3JnL2RlbW9zL3NwcmluZy9zcHJpbmcuanNcblxuZnVuY3Rpb24gc3ByaW5nKHN0cmluZywgZHVyYXRpb24pIHtcblxuICB2YXIgcGFyYW1zID0gcGFyc2VFYXNpbmdQYXJhbWV0ZXJzKHN0cmluZyk7XG4gIHZhciBtYXNzID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMF0pID8gMSA6IHBhcmFtc1swXSwgLjEsIDEwMCk7XG4gIHZhciBzdGlmZm5lc3MgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1sxXSkgPyAxMDAgOiBwYXJhbXNbMV0sIC4xLCAxMDApO1xuICB2YXIgZGFtcGluZyA9IG1pbk1heChpcy51bmQocGFyYW1zWzJdKSA/IDEwIDogcGFyYW1zWzJdLCAuMSwgMTAwKTtcbiAgdmFyIHZlbG9jaXR5ID0gIG1pbk1heChpcy51bmQocGFyYW1zWzNdKSA/IDAgOiBwYXJhbXNbM10sIC4xLCAxMDApO1xuICB2YXIgdzAgPSBNYXRoLnNxcnQoc3RpZmZuZXNzIC8gbWFzcyk7XG4gIHZhciB6ZXRhID0gZGFtcGluZyAvICgyICogTWF0aC5zcXJ0KHN0aWZmbmVzcyAqIG1hc3MpKTtcbiAgdmFyIHdkID0gemV0YSA8IDEgPyB3MCAqIE1hdGguc3FydCgxIC0gemV0YSAqIHpldGEpIDogMDtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IHpldGEgPCAxID8gKHpldGEgKiB3MCArIC12ZWxvY2l0eSkgLyB3ZCA6IC12ZWxvY2l0eSArIHcwO1xuXG4gIGZ1bmN0aW9uIHNvbHZlcih0KSB7XG4gICAgdmFyIHByb2dyZXNzID0gZHVyYXRpb24gPyAoZHVyYXRpb24gKiB0KSAvIDEwMDAgOiB0O1xuICAgIGlmICh6ZXRhIDwgMSkge1xuICAgICAgcHJvZ3Jlc3MgPSBNYXRoLmV4cCgtcHJvZ3Jlc3MgKiB6ZXRhICogdzApICogKGEgKiBNYXRoLmNvcyh3ZCAqIHByb2dyZXNzKSArIGIgKiBNYXRoLnNpbih3ZCAqIHByb2dyZXNzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dyZXNzID0gKGEgKyBiICogcHJvZ3Jlc3MpICogTWF0aC5leHAoLXByb2dyZXNzICogdzApO1xuICAgIH1cbiAgICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7IHJldHVybiB0OyB9XG4gICAgcmV0dXJuIDEgLSBwcm9ncmVzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldER1cmF0aW9uKCkge1xuICAgIHZhciBjYWNoZWQgPSBjYWNoZS5zcHJpbmdzW3N0cmluZ107XG4gICAgaWYgKGNhY2hlZCkgeyByZXR1cm4gY2FjaGVkOyB9XG4gICAgdmFyIGZyYW1lID0gMS82O1xuICAgIHZhciBlbGFwc2VkID0gMDtcbiAgICB2YXIgcmVzdCA9IDA7XG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgZWxhcHNlZCArPSBmcmFtZTtcbiAgICAgIGlmIChzb2x2ZXIoZWxhcHNlZCkgPT09IDEpIHtcbiAgICAgICAgcmVzdCsrO1xuICAgICAgICBpZiAocmVzdCA+PSAxNikgeyBicmVhazsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkdXJhdGlvbiA9IGVsYXBzZWQgKiBmcmFtZSAqIDEwMDA7XG4gICAgY2FjaGUuc3ByaW5nc1tzdHJpbmddID0gZHVyYXRpb247XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGR1cmF0aW9uID8gc29sdmVyIDogZ2V0RHVyYXRpb247XG5cbn1cblxuLy8gQmFzaWMgc3RlcHMgZWFzaW5nIGltcGxlbWVudGF0aW9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2ZyL2RvY3MvV2ViL0NTUy90cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblxuXG5mdW5jdGlvbiBzdGVwcyhzdGVwcykge1xuICBpZiAoIHN0ZXBzID09PSB2b2lkIDAgKSBzdGVwcyA9IDEwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gTWF0aC5jZWlsKChtaW5NYXgodCwgMC4wMDAwMDEsIDEpKSAqIHN0ZXBzKSAqICgxIC8gc3RlcHMpOyB9O1xufVxuXG4vLyBCZXppZXJFYXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nXG5cbnZhciBiZXppZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG4gIHZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5cbiAgZnVuY3Rpb24gQShhQTEsIGFBMikgeyByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExIH1cbiAgZnVuY3Rpb24gQihhQTEsIGFBMikgeyByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExIH1cbiAgZnVuY3Rpb24gQyhhQTEpICAgICAgeyByZXR1cm4gMy4wICogYUExIH1cblxuICBmdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikgeyByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQgfVxuICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSkgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7IGFCID0gY3VycmVudFQ7IH0gZWxzZSB7IGFBID0gY3VycmVudFQ7IH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiAwLjAwMDAwMDEgJiYgKytpIDwgMTApO1xuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7IHJldHVybiBhR3Vlc3NUOyB9XG4gICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH1cblxuICBmdW5jdGlvbiBiZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG5cbiAgICBpZiAoISgwIDw9IG1YMSAmJiBtWDEgPD0gMSAmJiAwIDw9IG1YMiAmJiBtWDIgPD0gMSkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cbiAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG5cbiAgICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgfVxuXG4gICAgICAtLWN1cnJlbnRTYW1wbGU7XG5cbiAgICAgIHZhciBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSAwLjAwMSkge1xuICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHsgcmV0dXJuIHg7IH1cbiAgICAgIGlmICh4ID09PSAwIHx8IHggPT09IDEpIHsgcmV0dXJuIHg7IH1cbiAgICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gYmV6aWVyO1xuXG59KSgpO1xuXG52YXIgcGVubmVyID0gKGZ1bmN0aW9uICgpIHtcblxuICAvLyBCYXNlZCBvbiBqUXVlcnkgVUkncyBpbXBsZW1lbmF0aW9uIG9mIGVhc2luZyBlcXVhdGlvbnMgZnJvbSBSb2JlcnQgUGVubmVyIChodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nKVxuXG4gIHZhciBlYXNlcyA9IHsgbGluZWFyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfTsgfSB9O1xuXG4gIHZhciBmdW5jdGlvbkVhc2luZ3MgPSB7XG4gICAgU2luZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpOyB9OyB9LFxuICAgIENpcmM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7IH07IH0sXG4gICAgQmFjazogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0ICogKDMgKiB0IC0gMik7IH07IH0sXG4gICAgQm91bmNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIHBvdzIsIGIgPSA0O1xuICAgICAgd2hpbGUgKHQgPCAoKCBwb3cyID0gTWF0aC5wb3coMiwgLS1iKSkgLSAxKSAvIDExKSB7fVxuICAgICAgcmV0dXJuIDEgLyBNYXRoLnBvdyg0LCAzIC0gYikgLSA3LjU2MjUgKiBNYXRoLnBvdygoIHBvdzIgKiAzIC0gMiApIC8gMjIgLSB0LCAyKVxuICAgIH07IH0sXG4gICAgRWxhc3RpYzogZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgICBpZiAoIGFtcGxpdHVkZSA9PT0gdm9pZCAwICkgYW1wbGl0dWRlID0gMTtcbiAgICAgIGlmICggcGVyaW9kID09PSB2b2lkIDAgKSBwZXJpb2QgPSAuNTtcblxuICAgICAgdmFyIGEgPSBtaW5NYXgoYW1wbGl0dWRlLCAxLCAxMCk7XG4gICAgICB2YXIgcCA9IG1pbk1heChwZXJpb2QsIC4xLCAyKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyB0IDogXG4gICAgICAgICAgLWEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICogTWF0aC5zaW4oKCgodCAtIDEpIC0gKHAgLyAoTWF0aC5QSSAqIDIpICogTWF0aC5hc2luKDEgLyBhKSkpICogKE1hdGguUEkgKiAyKSkgLyBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGJhc2VFYXNpbmdzID0gWydRdWFkJywgJ0N1YmljJywgJ1F1YXJ0JywgJ1F1aW50JywgJ0V4cG8nXTtcblxuICBiYXNlRWFzaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgZnVuY3Rpb25FYXNpbmdzW25hbWVdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucG93KHQsIGkgKyAyKTsgfTsgfTtcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMoZnVuY3Rpb25FYXNpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGVhc2VJbiA9IGZ1bmN0aW9uRWFzaW5nc1tuYW1lXTtcbiAgICBlYXNlc1snZWFzZUluJyArIG5hbWVdID0gZWFzZUluO1xuICAgIGVhc2VzWydlYXNlT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gZWFzZUluKGEsIGIpKDEgLSB0KTsgfTsgfTtcbiAgICBlYXNlc1snZWFzZUluT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgMC41ID8gZWFzZUluKGEsIGIpKHQgKiAyKSAvIDIgOiBcbiAgICAgIDEgLSBlYXNlSW4oYSwgYikodCAqIC0yICsgMikgLyAyOyB9OyB9O1xuICAgIGVhc2VzWydlYXNlT3V0SW4nICsgbmFtZV0gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAwLjUgPyAoMSAtIGVhc2VJbihhLCBiKSgxIC0gdCAqIDIpKSAvIDIgOiBcbiAgICAgIChlYXNlSW4oYSwgYikodCAqIDIgLSAxKSArIDEpIC8gMjsgfTsgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2VzO1xuXG59KSgpO1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ3MoZWFzaW5nLCBkdXJhdGlvbikge1xuICBpZiAoaXMuZm5jKGVhc2luZykpIHsgcmV0dXJuIGVhc2luZzsgfVxuICB2YXIgbmFtZSA9IGVhc2luZy5zcGxpdCgnKCcpWzBdO1xuICB2YXIgZWFzZSA9IHBlbm5lcltuYW1lXTtcbiAgdmFyIGFyZ3MgPSBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoZWFzaW5nKTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc3ByaW5nJyA6IHJldHVybiBzcHJpbmcoZWFzaW5nLCBkdXJhdGlvbik7XG4gICAgY2FzZSAnY3ViaWNCZXppZXInIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGJlemllciwgYXJncyk7XG4gICAgY2FzZSAnc3RlcHMnIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKHN0ZXBzLCBhcmdzKTtcbiAgICBkZWZhdWx0IDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGVhc2UsIGFyZ3MpO1xuICB9XG59XG5cbi8vIFN0cmluZ3NcblxuZnVuY3Rpb24gc2VsZWN0U3RyaW5nKHN0cikge1xuICB0cnkge1xuICAgIHZhciBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc3RyKTtcbiAgICByZXR1cm4gbm9kZXM7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG4vLyBBcnJheXNcblxuZnVuY3Rpb24gZmlsdGVyQXJyYXkoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpIGluIGFycikge1xuICAgICAgdmFyIHZhbCA9IGFycltpXTtcbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbCwgaSwgYXJyKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChpcy5hcnIoYikgPyBmbGF0dGVuQXJyYXkoYikgOiBiKTsgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KG8pIHtcbiAgaWYgKGlzLmFycihvKSkgeyByZXR1cm4gbzsgfVxuICBpZiAoaXMuc3RyKG8pKSB7IG8gPSBzZWxlY3RTdHJpbmcobykgfHwgbzsgfVxuICBpZiAobyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IG8gaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvbikgeyByZXR1cm4gW10uc2xpY2UuY2FsbChvKTsgfVxuICByZXR1cm4gW29dO1xufVxuXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSA9PT0gdmFsOyB9KTtcbn1cblxuLy8gT2JqZWN0c1xuXG5mdW5jdGlvbiBjbG9uZU9iamVjdChvKSB7XG4gIHZhciBjbG9uZSA9IHt9O1xuICBmb3IgKHZhciBwIGluIG8pIHsgY2xvbmVbcF0gPSBvW3BdOyB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZU9iamVjdFByb3BzKG8xLCBvMikge1xuICB2YXIgbyA9IGNsb25lT2JqZWN0KG8xKTtcbiAgZm9yICh2YXIgcCBpbiBvMSkgeyBvW3BdID0gbzIuaGFzT3duUHJvcGVydHkocCkgPyBvMltwXSA6IG8xW3BdOyB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMobzEsIG8yKSB7XG4gIHZhciBvID0gY2xvbmVPYmplY3QobzEpO1xuICBmb3IgKHZhciBwIGluIG8yKSB7IG9bcF0gPSBpcy51bmQobzFbcF0pID8gbzJbcF0gOiBvMVtwXTsgfVxuICByZXR1cm4gbztcbn1cblxuLy8gQ29sb3JzXG5cbmZ1bmN0aW9uIHJnYlRvUmdiYShyZ2JWYWx1ZSkge1xuICB2YXIgcmdiID0gL3JnYlxcKChcXGQrLFxccypbXFxkXSssXFxzKltcXGRdKylcXCkvZy5leGVjKHJnYlZhbHVlKTtcbiAgcmV0dXJuIHJnYiA/IChcInJnYmEoXCIgKyAocmdiWzFdKSArIFwiLDEpXCIpIDogcmdiVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGhleFRvUmdiYShoZXhWYWx1ZSkge1xuICB2YXIgcmd4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcbiAgdmFyIGhleCA9IGhleFZhbHVlLnJlcGxhY2Uocmd4LCBmdW5jdGlvbiAobSwgciwgZywgYikgeyByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiOyB9ICk7XG4gIHZhciByZ2IgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgdmFyIHIgPSBwYXJzZUludChyZ2JbMV0sIDE2KTtcbiAgdmFyIGcgPSBwYXJzZUludChyZ2JbMl0sIDE2KTtcbiAgdmFyIGIgPSBwYXJzZUludChyZ2JbM10sIDE2KTtcbiAgcmV0dXJuIChcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsMSlcIik7XG59XG5cbmZ1bmN0aW9uIGhzbFRvUmdiYShoc2xWYWx1ZSkge1xuICB2YXIgaHNsID0gL2hzbFxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJVxcKS9nLmV4ZWMoaHNsVmFsdWUpIHx8IC9oc2xhXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKylcXCkvZy5leGVjKGhzbFZhbHVlKTtcbiAgdmFyIGggPSBwYXJzZUludChoc2xbMV0sIDEwKSAvIDM2MDtcbiAgdmFyIHMgPSBwYXJzZUludChoc2xbMl0sIDEwKSAvIDEwMDtcbiAgdmFyIGwgPSBwYXJzZUludChoc2xbM10sIDEwKSAvIDEwMDtcbiAgdmFyIGEgPSBoc2xbNF0gfHwgMTtcbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7IHQgKz0gMTsgfVxuICAgIGlmICh0ID4gMSkgeyB0IC09IDE7IH1cbiAgICBpZiAodCA8IDEvNikgeyByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDsgfVxuICAgIGlmICh0IDwgMS8yKSB7IHJldHVybiBxOyB9XG4gICAgaWYgKHQgPCAyLzMpIHsgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjsgfVxuICAgIHJldHVybiBwO1xuICB9XG4gIHZhciByLCBnLCBiO1xuICBpZiAocyA9PSAwKSB7XG4gICAgciA9IGcgPSBiID0gbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEvMyk7XG4gICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gIH1cbiAgcmV0dXJuIChcInJnYmEoXCIgKyAociAqIDI1NSkgKyBcIixcIiArIChnICogMjU1KSArIFwiLFwiICsgKGIgKiAyNTUpICsgXCIsXCIgKyBhICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvUmdiKHZhbCkge1xuICBpZiAoaXMucmdiKHZhbCkpIHsgcmV0dXJuIHJnYlRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oZXgodmFsKSkgeyByZXR1cm4gaGV4VG9SZ2JhKHZhbCk7IH1cbiAgaWYgKGlzLmhzbCh2YWwpKSB7IHJldHVybiBoc2xUb1JnYmEodmFsKTsgfVxufVxuXG4vLyBVbml0c1xuXG5mdW5jdGlvbiBnZXRVbml0KHZhbCkge1xuICB2YXIgc3BsaXQgPSAvWystXT9cXGQqXFwuP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8oJXxweHxwdHxlbXxyZW18aW58Y218bW18ZXh8Y2h8cGN8dnd8dmh8dm1pbnx2bWF4fGRlZ3xyYWR8dHVybik/JC8uZXhlYyh2YWwpO1xuICBpZiAoc3BsaXQpIHsgcmV0dXJuIHNwbGl0WzFdOyB9XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVVuaXQocHJvcE5hbWUpIHtcbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAndHJhbnNsYXRlJykgfHwgcHJvcE5hbWUgPT09ICdwZXJzcGVjdGl2ZScpIHsgcmV0dXJuICdweCc7IH1cbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdza2V3JykpIHsgcmV0dXJuICdkZWcnOyB9XG59XG5cbi8vIFZhbHVlc1xuXG5mdW5jdGlvbiBnZXRGdW5jdGlvblZhbHVlKHZhbCwgYW5pbWF0YWJsZSkge1xuICBpZiAoIWlzLmZuYyh2YWwpKSB7IHJldHVybiB2YWw7IH1cbiAgcmV0dXJuIHZhbChhbmltYXRhYmxlLnRhcmdldCwgYW5pbWF0YWJsZS5pZCwgYW5pbWF0YWJsZS50b3RhbCk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgcHJvcCkge1xuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKHByb3ApO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSB7XG4gIHZhciB2YWx1ZVVuaXQgPSBnZXRVbml0KHZhbHVlKTtcbiAgaWYgKGFycmF5Q29udGFpbnMoW3VuaXQsICdkZWcnLCAncmFkJywgJ3R1cm4nXSwgdmFsdWVVbml0KSkgeyByZXR1cm4gdmFsdWU7IH1cbiAgdmFyIGNhY2hlZCA9IGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdO1xuICBpZiAoIWlzLnVuZChjYWNoZWQpKSB7IHJldHVybiBjYWNoZWQ7IH1cbiAgdmFyIGJhc2VsaW5lID0gMTAwO1xuICB2YXIgdGVtcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbC50YWdOYW1lKTtcbiAgdmFyIHBhcmVudEVsID0gKGVsLnBhcmVudE5vZGUgJiYgKGVsLnBhcmVudE5vZGUgIT09IGRvY3VtZW50KSkgPyBlbC5wYXJlbnROb2RlIDogZG9jdW1lbnQuYm9keTtcbiAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGVtcEVsKTtcbiAgdGVtcEVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgdGVtcEVsLnN0eWxlLndpZHRoID0gYmFzZWxpbmUgKyB1bml0O1xuICB2YXIgZmFjdG9yID0gYmFzZWxpbmUgLyB0ZW1wRWwub2Zmc2V0V2lkdGg7XG4gIHBhcmVudEVsLnJlbW92ZUNoaWxkKHRlbXBFbCk7XG4gIHZhciBjb252ZXJ0ZWRVbml0ID0gZmFjdG9yICogcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdID0gY29udmVydGVkVW5pdDtcbiAgcmV0dXJuIGNvbnZlcnRlZFVuaXQ7XG59XG5cbmZ1bmN0aW9uIGdldENTU1ZhbHVlKGVsLCBwcm9wLCB1bml0KSB7XG4gIGlmIChwcm9wIGluIGVsLnN0eWxlKSB7XG4gICAgdmFyIHVwcGVyY2FzZVByb3BOYW1lID0gcHJvcC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB2YWx1ZSA9IGVsLnN0eWxlW3Byb3BdIHx8IGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodXBwZXJjYXNlUHJvcE5hbWUpIHx8ICcwJztcbiAgICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uVHlwZShlbCwgcHJvcCkge1xuICBpZiAoaXMuZG9tKGVsKSAmJiAhaXMuaW5wKGVsKSAmJiAoIWlzLm5pbChnZXRBdHRyaWJ1dGUoZWwsIHByb3ApKSB8fCAoaXMuc3ZnKGVsKSAmJiBlbFtwcm9wXSkpKSB7IHJldHVybiAnYXR0cmlidXRlJzsgfVxuICBpZiAoaXMuZG9tKGVsKSAmJiBhcnJheUNvbnRhaW5zKHZhbGlkVHJhbnNmb3JtcywgcHJvcCkpIHsgcmV0dXJuICd0cmFuc2Zvcm0nOyB9XG4gIGlmIChpcy5kb20oZWwpICYmIChwcm9wICE9PSAndHJhbnNmb3JtJyAmJiBnZXRDU1NWYWx1ZShlbCwgcHJvcCkpKSB7IHJldHVybiAnY3NzJzsgfVxuICBpZiAoZWxbcHJvcF0gIT0gbnVsbCkgeyByZXR1cm4gJ29iamVjdCc7IH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFRyYW5zZm9ybXMoZWwpIHtcbiAgaWYgKCFpcy5kb20oZWwpKSB7IHJldHVybjsgfVxuICB2YXIgc3RyID0gZWwuc3R5bGUudHJhbnNmb3JtIHx8ICcnO1xuICB2YXIgcmVnICA9IC8oXFx3KylcXCgoW14pXSopXFwpL2c7XG4gIHZhciB0cmFuc2Zvcm1zID0gbmV3IE1hcCgpO1xuICB2YXIgbTsgd2hpbGUgKG0gPSByZWcuZXhlYyhzdHIpKSB7IHRyYW5zZm9ybXMuc2V0KG1bMV0sIG1bMl0pOyB9XG4gIHJldHVybiB0cmFuc2Zvcm1zO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1WYWx1ZShlbCwgcHJvcE5hbWUsIGFuaW1hdGFibGUsIHVuaXQpIHtcbiAgdmFyIGRlZmF1bHRWYWwgPSBzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3NjYWxlJykgPyAxIDogMCArIGdldFRyYW5zZm9ybVVuaXQocHJvcE5hbWUpO1xuICB2YXIgdmFsdWUgPSBnZXRFbGVtZW50VHJhbnNmb3JtcyhlbCkuZ2V0KHByb3BOYW1lKSB8fCBkZWZhdWx0VmFsO1xuICBpZiAoYW5pbWF0YWJsZSkge1xuICAgIGFuaW1hdGFibGUudHJhbnNmb3Jtcy5saXN0LnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgIGFuaW1hdGFibGUudHJhbnNmb3Jtc1snbGFzdCddID0gcHJvcE5hbWU7XG4gIH1cbiAgcmV0dXJuIHVuaXQgPyBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHVuaXQsIGFuaW1hdGFibGUpIHtcbiAgc3dpdGNoIChnZXRBbmltYXRpb25UeXBlKHRhcmdldCwgcHJvcE5hbWUpKSB7XG4gICAgY2FzZSAndHJhbnNmb3JtJzogcmV0dXJuIGdldFRyYW5zZm9ybVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGFibGUsIHVuaXQpO1xuICAgIGNhc2UgJ2Nzcyc6IHJldHVybiBnZXRDU1NWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB1bml0KTtcbiAgICBjYXNlICdhdHRyaWJ1dGUnOiByZXR1cm4gZ2V0QXR0cmlidXRlKHRhcmdldCwgcHJvcE5hbWUpO1xuICAgIGRlZmF1bHQ6IHJldHVybiB0YXJnZXRbcHJvcE5hbWVdIHx8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVWYWx1ZSh0bywgZnJvbSkge1xuICB2YXIgb3BlcmF0b3IgPSAvXihcXCo9fFxcKz18LT0pLy5leGVjKHRvKTtcbiAgaWYgKCFvcGVyYXRvcikgeyByZXR1cm4gdG87IH1cbiAgdmFyIHUgPSBnZXRVbml0KHRvKSB8fCAwO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoZnJvbSk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdCh0by5yZXBsYWNlKG9wZXJhdG9yWzBdLCAnJykpO1xuICBzd2l0Y2ggKG9wZXJhdG9yWzBdWzBdKSB7XG4gICAgY2FzZSAnKyc6IHJldHVybiB4ICsgeSArIHU7XG4gICAgY2FzZSAnLSc6IHJldHVybiB4IC0geSArIHU7XG4gICAgY2FzZSAnKic6IHJldHVybiB4ICogeSArIHU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWwsIHVuaXQpIHtcbiAgaWYgKGlzLmNvbCh2YWwpKSB7IHJldHVybiBjb2xvclRvUmdiKHZhbCk7IH1cbiAgaWYgKC9cXHMvZy50ZXN0KHZhbCkpIHsgcmV0dXJuIHZhbDsgfVxuICB2YXIgb3JpZ2luYWxVbml0ID0gZ2V0VW5pdCh2YWwpO1xuICB2YXIgdW5pdExlc3MgPSBvcmlnaW5hbFVuaXQgPyB2YWwuc3Vic3RyKDAsIHZhbC5sZW5ndGggLSBvcmlnaW5hbFVuaXQubGVuZ3RoKSA6IHZhbDtcbiAgaWYgKHVuaXQpIHsgcmV0dXJuIHVuaXRMZXNzICsgdW5pdDsgfVxuICByZXR1cm4gdW5pdExlc3M7XG59XG5cbi8vIGdldFRvdGFsTGVuZ3RoKCkgZXF1aXZhbGVudCBmb3IgY2lyY2xlLCByZWN0LCBwb2x5bGluZSwgcG9seWdvbiBhbmQgbGluZSBzaGFwZXNcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9TZWJMYW1ibGEvM2UwNTUwYzQ5NmMyMzY3MDk3NDRcblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDIueCAtIHAxLngsIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2lyY2xlTGVuZ3RoKGVsKSB7XG4gIHJldHVybiBNYXRoLlBJICogMiAqIGdldEF0dHJpYnV0ZShlbCwgJ3InKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdExlbmd0aChlbCkge1xuICByZXR1cm4gKGdldEF0dHJpYnV0ZShlbCwgJ3dpZHRoJykgKiAyKSArIChnZXRBdHRyaWJ1dGUoZWwsICdoZWlnaHQnKSAqIDIpO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGVsKSB7XG4gIHJldHVybiBnZXREaXN0YW5jZShcbiAgICB7eDogZ2V0QXR0cmlidXRlKGVsLCAneDEnKSwgeTogZ2V0QXR0cmlidXRlKGVsLCAneTEnKX0sIFxuICAgIHt4OiBnZXRBdHRyaWJ1dGUoZWwsICd4MicpLCB5OiBnZXRBdHRyaWJ1dGUoZWwsICd5MicpfVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRQb2x5bGluZUxlbmd0aChlbCkge1xuICB2YXIgcG9pbnRzID0gZWwucG9pbnRzO1xuICB2YXIgdG90YWxMZW5ndGggPSAwO1xuICB2YXIgcHJldmlvdXNQb3M7XG4gIGZvciAodmFyIGkgPSAwIDsgaSA8IHBvaW50cy5udW1iZXJPZkl0ZW1zOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFBvcyA9IHBvaW50cy5nZXRJdGVtKGkpO1xuICAgIGlmIChpID4gMCkgeyB0b3RhbExlbmd0aCArPSBnZXREaXN0YW5jZShwcmV2aW91c1BvcywgY3VycmVudFBvcyk7IH1cbiAgICBwcmV2aW91c1BvcyA9IGN1cnJlbnRQb3M7XG4gIH1cbiAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBnZXRQb2x5Z29uTGVuZ3RoKGVsKSB7XG4gIHZhciBwb2ludHMgPSBlbC5wb2ludHM7XG4gIHJldHVybiBnZXRQb2x5bGluZUxlbmd0aChlbCkgKyBnZXREaXN0YW5jZShwb2ludHMuZ2V0SXRlbShwb2ludHMubnVtYmVyT2ZJdGVtcyAtIDEpLCBwb2ludHMuZ2V0SXRlbSgwKSk7XG59XG5cbi8vIFBhdGggYW5pbWF0aW9uXG5cbmZ1bmN0aW9uIGdldFRvdGFsTGVuZ3RoKGVsKSB7XG4gIGlmIChlbC5nZXRUb3RhbExlbmd0aCkgeyByZXR1cm4gZWwuZ2V0VG90YWxMZW5ndGgoKTsgfVxuICBzd2l0Y2goZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnY2lyY2xlJzogcmV0dXJuIGdldENpcmNsZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncmVjdCc6IHJldHVybiBnZXRSZWN0TGVuZ3RoKGVsKTtcbiAgICBjYXNlICdsaW5lJzogcmV0dXJuIGdldExpbmVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3BvbHlsaW5lJzogcmV0dXJuIGdldFBvbHlsaW5lTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdwb2x5Z29uJzogcmV0dXJuIGdldFBvbHlnb25MZW5ndGgoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldERhc2hvZmZzZXQoZWwpIHtcbiAgdmFyIHBhdGhMZW5ndGggPSBnZXRUb3RhbExlbmd0aChlbCk7XG4gIGVsLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIHBhdGhMZW5ndGgpO1xuICByZXR1cm4gcGF0aExlbmd0aDtcbn1cblxuLy8gTW90aW9uIHBhdGhcblxuZnVuY3Rpb24gZ2V0UGFyZW50U3ZnRWwoZWwpIHtcbiAgdmFyIHBhcmVudEVsID0gZWwucGFyZW50Tm9kZTtcbiAgd2hpbGUgKGlzLnN2ZyhwYXJlbnRFbCkpIHtcbiAgICBpZiAoIWlzLnN2ZyhwYXJlbnRFbC5wYXJlbnROb2RlKSkgeyBicmVhazsgfVxuICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gcGFyZW50RWw7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFN2ZyhwYXRoRWwsIHN2Z0RhdGEpIHtcbiAgdmFyIHN2ZyA9IHN2Z0RhdGEgfHwge307XG4gIHZhciBwYXJlbnRTdmdFbCA9IHN2Zy5lbCB8fCBnZXRQYXJlbnRTdmdFbChwYXRoRWwpO1xuICB2YXIgcmVjdCA9IHBhcmVudFN2Z0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgdmlld0JveEF0dHIgPSBnZXRBdHRyaWJ1dGUocGFyZW50U3ZnRWwsICd2aWV3Qm94Jyk7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIHZpZXdCb3ggPSBzdmcudmlld0JveCB8fCAodmlld0JveEF0dHIgPyB2aWV3Qm94QXR0ci5zcGxpdCgnICcpIDogWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcbiAgcmV0dXJuIHtcbiAgICBlbDogcGFyZW50U3ZnRWwsXG4gICAgdmlld0JveDogdmlld0JveCxcbiAgICB4OiB2aWV3Qm94WzBdIC8gMSxcbiAgICB5OiB2aWV3Qm94WzFdIC8gMSxcbiAgICB3OiB3aWR0aCxcbiAgICBoOiBoZWlnaHQsXG4gICAgdlc6IHZpZXdCb3hbMl0sXG4gICAgdkg6IHZpZXdCb3hbM11cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoKHBhdGgsIHBlcmNlbnQpIHtcbiAgdmFyIHBhdGhFbCA9IGlzLnN0cihwYXRoKSA/IHNlbGVjdFN0cmluZyhwYXRoKVswXSA6IHBhdGg7XG4gIHZhciBwID0gcGVyY2VudCB8fCAxMDA7XG4gIHJldHVybiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICBlbDogcGF0aEVsLFxuICAgICAgc3ZnOiBnZXRQYXJlbnRTdmcocGF0aEVsKSxcbiAgICAgIHRvdGFsTGVuZ3RoOiBnZXRUb3RhbExlbmd0aChwYXRoRWwpICogKHAgLyAxMDApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhQcm9ncmVzcyhwYXRoLCBwcm9ncmVzcywgaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHKSB7XG4gIGZ1bmN0aW9uIHBvaW50KG9mZnNldCkge1xuICAgIGlmICggb2Zmc2V0ID09PSB2b2lkIDAgKSBvZmZzZXQgPSAwO1xuXG4gICAgdmFyIGwgPSBwcm9ncmVzcyArIG9mZnNldCA+PSAxID8gcHJvZ3Jlc3MgKyBvZmZzZXQgOiAwO1xuICAgIHJldHVybiBwYXRoLmVsLmdldFBvaW50QXRMZW5ndGgobCk7XG4gIH1cbiAgdmFyIHN2ZyA9IGdldFBhcmVudFN2ZyhwYXRoLmVsLCBwYXRoLnN2Zyk7XG4gIHZhciBwID0gcG9pbnQoKTtcbiAgdmFyIHAwID0gcG9pbnQoLTEpO1xuICB2YXIgcDEgPSBwb2ludCgrMSk7XG4gIHZhciBzY2FsZVggPSBpc1BhdGhUYXJnZXRJbnNpZGVTVkcgPyAxIDogc3ZnLncgLyBzdmcudlc7XG4gIHZhciBzY2FsZVkgPSBpc1BhdGhUYXJnZXRJbnNpZGVTVkcgPyAxIDogc3ZnLmggLyBzdmcudkg7XG4gIHN3aXRjaCAocGF0aC5wcm9wZXJ0eSkge1xuICAgIGNhc2UgJ3gnOiByZXR1cm4gKHAueCAtIHN2Zy54KSAqIHNjYWxlWDtcbiAgICBjYXNlICd5JzogcmV0dXJuIChwLnkgLSBzdmcueSkgKiBzY2FsZVk7XG4gICAgY2FzZSAnYW5nbGUnOiByZXR1cm4gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxufVxuXG4vLyBEZWNvbXBvc2UgdmFsdWVcblxuZnVuY3Rpb24gZGVjb21wb3NlVmFsdWUodmFsLCB1bml0KSB7XG4gIC8vIGNvbnN0IHJneCA9IC8tP1xcZCpcXC4/XFxkKy9nOyAvLyBoYW5kbGVzIGJhc2ljIG51bWJlcnNcbiAgLy8gY29uc3Qgcmd4ID0gL1srLV0/XFxkKyg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPy9nOyAvLyBoYW5kbGVzIGV4cG9uZW50cyBub3RhdGlvblxuICB2YXIgcmd4ID0gL1srLV0/XFxkKlxcLj9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/L2c7IC8vIGhhbmRsZXMgZXhwb25lbnRzIG5vdGF0aW9uXG4gIHZhciB2YWx1ZSA9IHZhbGlkYXRlVmFsdWUoKGlzLnB0aCh2YWwpID8gdmFsLnRvdGFsTGVuZ3RoIDogdmFsKSwgdW5pdCkgKyAnJztcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW5hbDogdmFsdWUsXG4gICAgbnVtYmVyczogdmFsdWUubWF0Y2gocmd4KSA/IHZhbHVlLm1hdGNoKHJneCkubWFwKE51bWJlcikgOiBbMF0sXG4gICAgc3RyaW5nczogKGlzLnN0cih2YWwpIHx8IHVuaXQpID8gdmFsdWUuc3BsaXQocmd4KSA6IFtdXG4gIH1cbn1cblxuLy8gQW5pbWF0YWJsZXNcblxuZnVuY3Rpb24gcGFyc2VUYXJnZXRzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldHNBcnJheSA9IHRhcmdldHMgPyAoZmxhdHRlbkFycmF5KGlzLmFycih0YXJnZXRzKSA/IHRhcmdldHMubWFwKHRvQXJyYXkpIDogdG9BcnJheSh0YXJnZXRzKSkpIDogW107XG4gIHJldHVybiBmaWx0ZXJBcnJheSh0YXJnZXRzQXJyYXksIGZ1bmN0aW9uIChpdGVtLCBwb3MsIHNlbGYpIHsgcmV0dXJuIHNlbGYuaW5kZXhPZihpdGVtKSA9PT0gcG9zOyB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZXModGFyZ2V0cykge1xuICB2YXIgcGFyc2VkID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICByZXR1cm4gcGFyc2VkLm1hcChmdW5jdGlvbiAodCwgaSkge1xuICAgIHJldHVybiB7dGFyZ2V0OiB0LCBpZDogaSwgdG90YWw6IHBhcnNlZC5sZW5ndGgsIHRyYW5zZm9ybXM6IHsgbGlzdDogZ2V0RWxlbWVudFRyYW5zZm9ybXModCkgfSB9O1xuICB9KTtcbn1cblxuLy8gUHJvcGVydGllc1xuXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwcm9wLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBzZXR0aW5ncyA9IGNsb25lT2JqZWN0KHR3ZWVuU2V0dGluZ3MpO1xuICAvLyBPdmVycmlkZSBkdXJhdGlvbiBpZiBlYXNpbmcgaXMgYSBzcHJpbmdcbiAgaWYgKC9ec3ByaW5nLy50ZXN0KHNldHRpbmdzLmVhc2luZykpIHsgc2V0dGluZ3MuZHVyYXRpb24gPSBzcHJpbmcoc2V0dGluZ3MuZWFzaW5nKTsgfVxuICBpZiAoaXMuYXJyKHByb3ApKSB7XG4gICAgdmFyIGwgPSBwcm9wLmxlbmd0aDtcbiAgICB2YXIgaXNGcm9tVG8gPSAobCA9PT0gMiAmJiAhaXMub2JqKHByb3BbMF0pKTtcbiAgICBpZiAoIWlzRnJvbVRvKSB7XG4gICAgICAvLyBEdXJhdGlvbiBkaXZpZGVkIGJ5IHRoZSBudW1iZXIgb2YgdHdlZW5zXG4gICAgICBpZiAoIWlzLmZuYyh0d2VlblNldHRpbmdzLmR1cmF0aW9uKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24gLyBsOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYW5zZm9ybSBbZnJvbSwgdG9dIHZhbHVlcyBzaG9ydGhhbmQgdG8gYSB2YWxpZCB0d2VlbiB2YWx1ZVxuICAgICAgcHJvcCA9IHt2YWx1ZTogcHJvcH07XG4gICAgfVxuICB9XG4gIHZhciBwcm9wQXJyYXkgPSBpcy5hcnIocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xuICByZXR1cm4gcHJvcEFycmF5Lm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgIHZhciBvYmogPSAoaXMub2JqKHYpICYmICFpcy5wdGgodikpID8gdiA6IHt2YWx1ZTogdn07XG4gICAgLy8gRGVmYXVsdCBkZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBmaXJzdCB0d2VlblxuICAgIGlmIChpcy51bmQob2JqLmRlbGF5KSkgeyBvYmouZGVsYXkgPSAhaSA/IHR3ZWVuU2V0dGluZ3MuZGVsYXkgOiAwOyB9XG4gICAgLy8gRGVmYXVsdCBlbmREZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBsYXN0IHR3ZWVuXG4gICAgaWYgKGlzLnVuZChvYmouZW5kRGVsYXkpKSB7IG9iai5lbmREZWxheSA9IGkgPT09IHByb3BBcnJheS5sZW5ndGggLSAxID8gdHdlZW5TZXR0aW5ncy5lbmREZWxheSA6IDA7IH1cbiAgICByZXR1cm4gb2JqO1xuICB9KS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIG1lcmdlT2JqZWN0cyhrLCBzZXR0aW5ncyk7IH0pO1xufVxuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5LZXlmcmFtZXMoa2V5ZnJhbWVzKSB7XG4gIHZhciBwcm9wZXJ0eU5hbWVzID0gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gT2JqZWN0LmtleXMoa2V5KTsgfSkpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gaXMua2V5KHApOyB9KVxuICAucmVkdWNlKGZ1bmN0aW9uIChhLGIpIHsgaWYgKGEuaW5kZXhPZihiKSA8IDApIHsgYS5wdXNoKGIpOyB9IHJldHVybiBhOyB9LCBbXSk7XG4gIHZhciBwcm9wZXJ0aWVzID0ge307XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5TmFtZXNbaV07XG4gICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBrZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBuZXdLZXkgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4ga2V5KSB7XG4gICAgICAgIGlmIChpcy5rZXkocCkpIHtcbiAgICAgICAgICBpZiAocCA9PSBwcm9wTmFtZSkgeyBuZXdLZXkudmFsdWUgPSBrZXlbcF07IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdLZXlbcF0gPSBrZXlbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKHR3ZWVuU2V0dGluZ3MsIHBhcmFtcykge1xuICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICB2YXIga2V5ZnJhbWVzID0gcGFyYW1zLmtleWZyYW1lcztcbiAgaWYgKGtleWZyYW1lcykgeyBwYXJhbXMgPSBtZXJnZU9iamVjdHMoZmxhdHRlbktleWZyYW1lcyhrZXlmcmFtZXMpLCBwYXJhbXMpOyB9XG4gIGZvciAodmFyIHAgaW4gcGFyYW1zKSB7XG4gICAgaWYgKGlzLmtleShwKSkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogcCxcbiAgICAgICAgdHdlZW5zOiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwYXJhbXNbcF0sIHR3ZWVuU2V0dGluZ3MpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbi8vIFR3ZWVuc1xuXG5mdW5jdGlvbiBub3JtYWxpemVUd2VlblZhbHVlcyh0d2VlbiwgYW5pbWF0YWJsZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHR3ZWVuKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZSh0d2VlbltwXSwgYW5pbWF0YWJsZSk7XG4gICAgaWYgKGlzLmFycih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBnZXRGdW5jdGlvblZhbHVlKHYsIGFuaW1hdGFibGUpOyB9KTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHsgdmFsdWUgPSB2YWx1ZVswXTsgfVxuICAgIH1cbiAgICB0W3BdID0gdmFsdWU7XG4gIH1cbiAgdC5kdXJhdGlvbiA9IHBhcnNlRmxvYXQodC5kdXJhdGlvbik7XG4gIHQuZGVsYXkgPSBwYXJzZUZsb2F0KHQuZGVsYXkpO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVHdlZW5zKHByb3AsIGFuaW1hdGFibGUpIHtcbiAgdmFyIHByZXZpb3VzVHdlZW47XG4gIHJldHVybiBwcm9wLnR3ZWVucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgdHdlZW4gPSBub3JtYWxpemVUd2VlblZhbHVlcyh0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgdHdlZW5WYWx1ZSA9IHR3ZWVuLnZhbHVlO1xuICAgIHZhciB0byA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMV0gOiB0d2VlblZhbHVlO1xuICAgIHZhciB0b1VuaXQgPSBnZXRVbml0KHRvKTtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSwgdG9Vbml0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVHdlZW4gPyBwcmV2aW91c1R3ZWVuLnRvLm9yaWdpbmFsIDogb3JpZ2luYWxWYWx1ZTtcbiAgICB2YXIgZnJvbSA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMF0gOiBwcmV2aW91c1ZhbHVlO1xuICAgIHZhciBmcm9tVW5pdCA9IGdldFVuaXQoZnJvbSkgfHwgZ2V0VW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICB2YXIgdW5pdCA9IHRvVW5pdCB8fCBmcm9tVW5pdDtcbiAgICBpZiAoaXMudW5kKHRvKSkgeyB0byA9IHByZXZpb3VzVmFsdWU7IH1cbiAgICB0d2Vlbi5mcm9tID0gZGVjb21wb3NlVmFsdWUoZnJvbSwgdW5pdCk7XG4gICAgdHdlZW4udG8gPSBkZWNvbXBvc2VWYWx1ZShnZXRSZWxhdGl2ZVZhbHVlKHRvLCBmcm9tKSwgdW5pdCk7XG4gICAgdHdlZW4uc3RhcnQgPSBwcmV2aW91c1R3ZWVuID8gcHJldmlvdXNUd2Vlbi5lbmQgOiAwO1xuICAgIHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0ICsgdHdlZW4uZGVsYXkgKyB0d2Vlbi5kdXJhdGlvbiArIHR3ZWVuLmVuZERlbGF5O1xuICAgIHR3ZWVuLmVhc2luZyA9IHBhcnNlRWFzaW5ncyh0d2Vlbi5lYXNpbmcsIHR3ZWVuLmR1cmF0aW9uKTtcbiAgICB0d2Vlbi5pc1BhdGggPSBpcy5wdGgodHdlZW5WYWx1ZSk7XG4gICAgdHdlZW4uaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHID0gdHdlZW4uaXNQYXRoICYmIGlzLnN2ZyhhbmltYXRhYmxlLnRhcmdldCk7XG4gICAgdHdlZW4uaXNDb2xvciA9IGlzLmNvbCh0d2Vlbi5mcm9tLm9yaWdpbmFsKTtcbiAgICBpZiAodHdlZW4uaXNDb2xvcikgeyB0d2Vlbi5yb3VuZCA9IDE7IH1cbiAgICBwcmV2aW91c1R3ZWVuID0gdHdlZW47XG4gICAgcmV0dXJuIHR3ZWVuO1xuICB9KTtcbn1cblxuLy8gVHdlZW4gcHJvZ3Jlc3NcblxudmFyIHNldFByb2dyZXNzVmFsdWUgPSB7XG4gIGNzczogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHQuc3R5bGVbcF0gPSB2OyB9LFxuICBhdHRyaWJ1dGU6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0LnNldEF0dHJpYnV0ZShwLCB2KTsgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdFtwXSA9IHY7IH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKHQsIHAsIHYsIHRyYW5zZm9ybXMsIG1hbnVhbCkge1xuICAgIHRyYW5zZm9ybXMubGlzdC5zZXQocCwgdik7XG4gICAgaWYgKHAgPT09IHRyYW5zZm9ybXMubGFzdCB8fCBtYW51YWwpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIHRyYW5zZm9ybXMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcHJvcCkgeyBzdHIgKz0gcHJvcCArIFwiKFwiICsgdmFsdWUgKyBcIikgXCI7IH0pO1xuICAgICAgdC5zdHlsZS50cmFuc2Zvcm0gPSBzdHI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBTZXQgVmFsdWUgaGVscGVyXG5cbmZ1bmN0aW9uIHNldFRhcmdldHNWYWx1ZSh0YXJnZXRzLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBhbmltYXRhYmxlcyA9IGdldEFuaW1hdGFibGVzKHRhcmdldHMpO1xuICBhbmltYXRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZShwcm9wZXJ0aWVzW3Byb3BlcnR5XSwgYW5pbWF0YWJsZSk7XG4gICAgICB2YXIgdGFyZ2V0ID0gYW5pbWF0YWJsZS50YXJnZXQ7XG4gICAgICB2YXIgdmFsdWVVbml0ID0gZ2V0VW5pdCh2YWx1ZSk7XG4gICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWVVbml0LCBhbmltYXRhYmxlKTtcbiAgICAgIHZhciB1bml0ID0gdmFsdWVVbml0IHx8IGdldFVuaXQob3JpZ2luYWxWYWx1ZSk7XG4gICAgICB2YXIgdG8gPSBnZXRSZWxhdGl2ZVZhbHVlKHZhbGlkYXRlVmFsdWUodmFsdWUsIHVuaXQpLCBvcmlnaW5hbFZhbHVlKTtcbiAgICAgIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBzZXRQcm9ncmVzc1ZhbHVlW2FuaW1UeXBlXSh0YXJnZXQsIHByb3BlcnR5LCB0bywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBBbmltYXRpb25zXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKSB7XG4gIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSk7XG4gIGlmIChhbmltVHlwZSkge1xuICAgIHZhciB0d2VlbnMgPSBub3JtYWxpemVUd2VlbnMocHJvcCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIGxhc3RUd2VlbiA9IHR3ZWVuc1t0d2VlbnMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFuaW1UeXBlLFxuICAgICAgcHJvcGVydHk6IHByb3AubmFtZSxcbiAgICAgIGFuaW1hdGFibGU6IGFuaW1hdGFibGUsXG4gICAgICB0d2VlbnM6IHR3ZWVucyxcbiAgICAgIGR1cmF0aW9uOiBsYXN0VHdlZW4uZW5kLFxuICAgICAgZGVsYXk6IHR3ZWVuc1swXS5kZWxheSxcbiAgICAgIGVuZERlbGF5OiBsYXN0VHdlZW4uZW5kRGVsYXlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcykge1xuICByZXR1cm4gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGFuaW1hdGFibGVzLm1hcChmdW5jdGlvbiAoYW5pbWF0YWJsZSkge1xuICAgIHJldHVybiBwcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKTtcbiAgICB9KTtcbiAgfSkpLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIWlzLnVuZChhKTsgfSk7XG59XG5cbi8vIENyZWF0ZSBJbnN0YW5jZVxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZVRpbWluZ3MoYW5pbWF0aW9ucywgdHdlZW5TZXR0aW5ncykge1xuICB2YXIgYW5pbUxlbmd0aCA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuICB2YXIgZ2V0VGxPZmZzZXQgPSBmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gYW5pbS50aW1lbGluZU9mZnNldCA/IGFuaW0udGltZWxpbmVPZmZzZXQgOiAwOyB9O1xuICB2YXIgdGltaW5ncyA9IHt9O1xuICB0aW1pbmdzLmR1cmF0aW9uID0gYW5pbUxlbmd0aCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBnZXRUbE9mZnNldChhbmltKSArIGFuaW0uZHVyYXRpb247IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb247XG4gIHRpbWluZ3MuZGVsYXkgPSBhbmltTGVuZ3RoID8gTWF0aC5taW4uYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kZWxheTsgfSkpIDogdHdlZW5TZXR0aW5ncy5kZWxheTtcbiAgdGltaW5ncy5lbmREZWxheSA9IGFuaW1MZW5ndGggPyB0aW1pbmdzLmR1cmF0aW9uIC0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kdXJhdGlvbiAtIGFuaW0uZW5kRGVsYXk7IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZW5kRGVsYXk7XG4gIHJldHVybiB0aW1pbmdzO1xufVxuXG52YXIgaW5zdGFuY2VJRCA9IDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcykge1xuICB2YXIgaW5zdGFuY2VTZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHR3ZWVuU2V0dGluZ3MgPSByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdFR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gZ2V0UHJvcGVydGllcyh0d2VlblNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgYW5pbWF0YWJsZXMgPSBnZXRBbmltYXRhYmxlcyhwYXJhbXMudGFyZ2V0cyk7XG4gIHZhciBhbmltYXRpb25zID0gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcyk7XG4gIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGFuaW1hdGlvbnMsIHR3ZWVuU2V0dGluZ3MpO1xuICB2YXIgaWQgPSBpbnN0YW5jZUlEO1xuICBpbnN0YW5jZUlEKys7XG4gIHJldHVybiBtZXJnZU9iamVjdHMoaW5zdGFuY2VTZXR0aW5ncywge1xuICAgIGlkOiBpZCxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgYW5pbWF0YWJsZXM6IGFuaW1hdGFibGVzLFxuICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgZHVyYXRpb246IHRpbWluZ3MuZHVyYXRpb24sXG4gICAgZGVsYXk6IHRpbWluZ3MuZGVsYXksXG4gICAgZW5kRGVsYXk6IHRpbWluZ3MuZW5kRGVsYXlcbiAgfSk7XG59XG5cbi8vIENvcmVcblxudmFyIGFjdGl2ZUluc3RhbmNlcyA9IFtdO1xuXG52YXIgZW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhZjtcblxuICBmdW5jdGlvbiBwbGF5KCkge1xuICAgIGlmICghcmFmICYmICghaXNEb2N1bWVudEhpZGRlbigpIHx8ICFhbmltZS5zdXNwZW5kV2hlbkRvY3VtZW50SGlkZGVuKSAmJiBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdGVwKHQpIHtcbiAgICAvLyBtZW1vIG9uIGFsZ29yaXRobSBpc3N1ZTpcbiAgICAvLyBkYW5nZXJvdXMgaXRlcmF0aW9uIG92ZXIgbXV0YWJsZSBgYWN0aXZlSW5zdGFuY2VzYFxuICAgIC8vICh0aGF0IGNvbGxlY3Rpb24gbWF5IGJlIHVwZGF0ZWQgZnJvbSB3aXRoaW4gY2FsbGJhY2tzIG9mIGB0aWNrYC1lZCBhbmltYXRpb24gaW5zdGFuY2VzKVxuICAgIHZhciBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFjdGl2ZUluc3RhbmNlc0xlbmd0aCkge1xuICAgICAgdmFyIGFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2VzW2ldO1xuICAgICAgaWYgKCFhY3RpdmVJbnN0YW5jZS5wYXVzZWQpIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UudGljayh0KTtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJhZiA9IGkgPiAwID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoIWFuaW1lLnN1c3BlbmRXaGVuRG9jdW1lbnRIaWRkZW4pIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoaXNEb2N1bWVudEhpZGRlbigpKSB7XG4gICAgICAvLyBzdXNwZW5kIHRpY2tzXG4gICAgICByYWYgPSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgIH0gZWxzZSB7IC8vIGlzIGJhY2sgdG8gYWN0aXZlIHRhYlxuICAgICAgLy8gZmlyc3QgYWRqdXN0IGFuaW1hdGlvbnMgdG8gY29uc2lkZXIgdGhlIHRpbWUgdGhhdCB0aWNrcyB3ZXJlIHN1c3BlbmRlZFxuICAgICAgYWN0aXZlSW5zdGFuY2VzLmZvckVhY2goXG4gICAgICAgIGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UgLl9vbkRvY3VtZW50VmlzaWJpbGl0eSgpOyB9XG4gICAgICApO1xuICAgICAgZW5naW5lKCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICB9XG5cbiAgcmV0dXJuIHBsYXk7XG59KSgpO1xuXG5mdW5jdGlvbiBpc0RvY3VtZW50SGlkZGVuKCkge1xuICByZXR1cm4gISFkb2N1bWVudCAmJiBkb2N1bWVudC5oaWRkZW47XG59XG5cbi8vIFB1YmxpYyBJbnN0YW5jZVxuXG5mdW5jdGlvbiBhbmltZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG5cbiAgdmFyIHN0YXJ0VGltZSA9IDAsIGxhc3RUaW1lID0gMCwgbm93ID0gMDtcbiAgdmFyIGNoaWxkcmVuLCBjaGlsZHJlbkxlbmd0aCA9IDA7XG4gIHZhciByZXNvbHZlID0gbnVsbDtcblxuICBmdW5jdGlvbiBtYWtlUHJvbWlzZShpbnN0YW5jZSkge1xuICAgIHZhciBwcm9taXNlID0gd2luZG93LlByb21pc2UgJiYgbmV3IFByb21pc2UoZnVuY3Rpb24gKF9yZXNvbHZlKSB7IHJldHVybiByZXNvbHZlID0gX3Jlc29sdmU7IH0pO1xuICAgIGluc3RhbmNlLmZpbmlzaGVkID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcyk7XG4gIHZhciBwcm9taXNlID0gbWFrZVByb21pc2UoaW5zdGFuY2UpO1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnN0YW5jZS5kaXJlY3Rpb247XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgIGluc3RhbmNlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbiAhPT0gJ25vcm1hbCcgPyAnbm9ybWFsJyA6ICdyZXZlcnNlJztcbiAgICB9XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSAhaW5zdGFuY2UucmV2ZXJzZWQ7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnJldmVyc2VkID0gaW5zdGFuY2UucmV2ZXJzZWQ7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRqdXN0VGltZSh0aW1lKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gLSB0aW1lIDogdGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VGltZSgpIHtcbiAgICBzdGFydFRpbWUgPSAwO1xuICAgIGxhc3RUaW1lID0gYWRqdXN0VGltZShpbnN0YW5jZS5jdXJyZW50VGltZSkgKiAoMSAvIGFuaW1lLnNwZWVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlZWtDaGlsZCh0aW1lLCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCkgeyBjaGlsZC5zZWVrKHRpbWUgLSBjaGlsZC50aW1lbGluZU9mZnNldCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmNJbnN0YW5jZUNoaWxkcmVuKHRpbWUpIHtcbiAgICBpZiAoIWluc3RhbmNlLnJldmVyc2VQbGF5YmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7IHNlZWtDaGlsZCh0aW1lLCBjaGlsZHJlbltpXSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSQxID0gY2hpbGRyZW5MZW5ndGg7IGkkMS0tOykgeyBzZWVrQ2hpbGQodGltZSwgY2hpbGRyZW5baSQxXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zVGltZSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gICAgdmFyIGFuaW1hdGlvbnNMZW5ndGggPSBhbmltYXRpb25zLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGFuaW1hdGlvbnNMZW5ndGgpIHtcbiAgICAgIHZhciBhbmltID0gYW5pbWF0aW9uc1tpXTtcbiAgICAgIHZhciBhbmltYXRhYmxlID0gYW5pbS5hbmltYXRhYmxlO1xuICAgICAgdmFyIHR3ZWVucyA9IGFuaW0udHdlZW5zO1xuICAgICAgdmFyIHR3ZWVuTGVuZ3RoID0gdHdlZW5zLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgdHdlZW4gPSB0d2VlbnNbdHdlZW5MZW5ndGhdO1xuICAgICAgLy8gT25seSBjaGVjayBmb3Iga2V5ZnJhbWVzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgdHdlZW5cbiAgICAgIGlmICh0d2Vlbkxlbmd0aCkgeyB0d2VlbiA9IGZpbHRlckFycmF5KHR3ZWVucywgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChpbnNUaW1lIDwgdC5lbmQpOyB9KVswXSB8fCB0d2VlbjsgfVxuICAgICAgdmFyIGVsYXBzZWQgPSBtaW5NYXgoaW5zVGltZSAtIHR3ZWVuLnN0YXJ0IC0gdHdlZW4uZGVsYXksIDAsIHR3ZWVuLmR1cmF0aW9uKSAvIHR3ZWVuLmR1cmF0aW9uO1xuICAgICAgdmFyIGVhc2VkID0gaXNOYU4oZWxhcHNlZCkgPyAxIDogdHdlZW4uZWFzaW5nKGVsYXBzZWQpO1xuICAgICAgdmFyIHN0cmluZ3MgPSB0d2Vlbi50by5zdHJpbmdzO1xuICAgICAgdmFyIHJvdW5kID0gdHdlZW4ucm91bmQ7XG4gICAgICB2YXIgbnVtYmVycyA9IFtdO1xuICAgICAgdmFyIHRvTnVtYmVyc0xlbmd0aCA9IHR3ZWVuLnRvLm51bWJlcnMubGVuZ3RoO1xuICAgICAgdmFyIHByb2dyZXNzID0gKHZvaWQgMCk7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRvTnVtYmVyc0xlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgdG9OdW1iZXIgPSB0d2Vlbi50by5udW1iZXJzW25dO1xuICAgICAgICB2YXIgZnJvbU51bWJlciA9IHR3ZWVuLmZyb20ubnVtYmVyc1tuXSB8fCAwO1xuICAgICAgICBpZiAoIXR3ZWVuLmlzUGF0aCkge1xuICAgICAgICAgIHZhbHVlID0gZnJvbU51bWJlciArIChlYXNlZCAqICh0b051bWJlciAtIGZyb21OdW1iZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldFBhdGhQcm9ncmVzcyh0d2Vlbi52YWx1ZSwgZWFzZWQgKiB0b051bWJlciwgdHdlZW4uaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICBpZiAoISh0d2Vlbi5pc0NvbG9yICYmIG4gPiAyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogcm91bmQpIC8gcm91bmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBNYW51YWwgQXJyYXkucmVkdWNlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VzXG4gICAgICB2YXIgc3RyaW5nc0xlbmd0aCA9IHN0cmluZ3MubGVuZ3RoO1xuICAgICAgaWYgKCFzdHJpbmdzTGVuZ3RoKSB7XG4gICAgICAgIHByb2dyZXNzID0gbnVtYmVyc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyZXNzID0gc3RyaW5nc1swXTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdHJpbmdzTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICB2YXIgYSA9IHN0cmluZ3Nbc107XG4gICAgICAgICAgdmFyIGIgPSBzdHJpbmdzW3MgKyAxXTtcbiAgICAgICAgICB2YXIgbiQxID0gbnVtYmVyc1tzXTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG4kMSkpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyAnICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0UHJvZ3Jlc3NWYWx1ZVthbmltLnR5cGVdKGFuaW1hdGFibGUudGFyZ2V0LCBhbmltLnByb3BlcnR5LCBwcm9ncmVzcywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zKTtcbiAgICAgIGFuaW0uY3VycmVudFZhbHVlID0gcHJvZ3Jlc3M7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FsbGJhY2soY2IpIHtcbiAgICBpZiAoaW5zdGFuY2VbY2JdICYmICFpbnN0YW5jZS5wYXNzVGhyb3VnaCkgeyBpbnN0YW5jZVtjYl0oaW5zdGFuY2UpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudEl0ZXJhdGlvbigpIHtcbiAgICBpZiAoaW5zdGFuY2UucmVtYWluaW5nICYmIGluc3RhbmNlLnJlbWFpbmluZyAhPT0gdHJ1ZSkge1xuICAgICAgaW5zdGFuY2UucmVtYWluaW5nLS07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW5zdGFuY2VQcm9ncmVzcyhlbmdpbmVUaW1lKSB7XG4gICAgdmFyIGluc0R1cmF0aW9uID0gaW5zdGFuY2UuZHVyYXRpb247XG4gICAgdmFyIGluc0RlbGF5ID0gaW5zdGFuY2UuZGVsYXk7XG4gICAgdmFyIGluc0VuZERlbGF5ID0gaW5zRHVyYXRpb24gLSBpbnN0YW5jZS5lbmREZWxheTtcbiAgICB2YXIgaW5zVGltZSA9IGFkanVzdFRpbWUoZW5naW5lVGltZSk7XG4gICAgaW5zdGFuY2UucHJvZ3Jlc3MgPSBtaW5NYXgoKGluc1RpbWUgLyBpbnNEdXJhdGlvbikgKiAxMDAsIDAsIDEwMCk7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gaW5zVGltZSA8IGluc3RhbmNlLmN1cnJlbnRUaW1lO1xuICAgIGlmIChjaGlsZHJlbikgeyBzeW5jSW5zdGFuY2VDaGlsZHJlbihpbnNUaW1lKTsgfVxuICAgIGlmICghaW5zdGFuY2UuYmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5iZWdhbiA9IHRydWU7XG4gICAgICBzZXRDYWxsYmFjaygnYmVnaW4nKTtcbiAgICB9XG4gICAgaWYgKCFpbnN0YW5jZS5sb29wQmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSB0cnVlO1xuICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BCZWdpbicpO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA8PSBpbnNEZWxheSAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSAhPT0gMCkge1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKDApO1xuICAgIH1cbiAgICBpZiAoKGluc1RpbWUgPj0gaW5zRW5kRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IGluc0R1cmF0aW9uKSB8fCAhaW5zRHVyYXRpb24pIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNEdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChpbnNUaW1lID4gaW5zRGVsYXkgJiYgaW5zVGltZSA8IGluc0VuZERlbGF5KSB7XG4gICAgICBpZiAoIWluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VCZWdpbicpO1xuICAgICAgfVxuICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZScpO1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zdGFuY2UuY2hhbmdlQmVnYW4pIHtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZUNvbXBsZXRlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gbWluTWF4KGluc1RpbWUsIDAsIGluc0R1cmF0aW9uKTtcbiAgICBpZiAoaW5zdGFuY2UuYmVnYW4pIHsgc2V0Q2FsbGJhY2soJ3VwZGF0ZScpOyB9XG4gICAgaWYgKGVuZ2luZVRpbWUgPj0gaW5zRHVyYXRpb24pIHtcbiAgICAgIGxhc3RUaW1lID0gMDtcbiAgICAgIGNvdW50SXRlcmF0aW9uKCk7XG4gICAgICBpZiAoIWluc3RhbmNlLnJlbWFpbmluZykge1xuICAgICAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWluc3RhbmNlLmNvbXBsZXRlZCkge1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICAgIHNldENhbGxiYWNrKCdjb21wbGV0ZScpO1xuICAgICAgICAgIGlmICghaW5zdGFuY2UucGFzc1Rocm91Z2ggJiYgJ1Byb21pc2UnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmRpcmVjdGlvbiA9PT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgICAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5zdGFuY2UucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5zdGFuY2UuZGlyZWN0aW9uO1xuICAgIGluc3RhbmNlLnBhc3NUaHJvdWdoID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY3VycmVudFRpbWUgPSAwO1xuICAgIGluc3RhbmNlLnByb2dyZXNzID0gMDtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIGluc3RhbmNlLmJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jaGFuZ2VDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlZCA9IGRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnO1xuICAgIGluc3RhbmNlLnJlbWFpbmluZyA9IGluc3RhbmNlLmxvb3A7XG4gICAgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgICBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gY2hpbGRyZW5MZW5ndGg7IGktLTspIHsgaW5zdGFuY2UuY2hpbGRyZW5baV0ucmVzZXQoKTsgfVxuICAgIGlmIChpbnN0YW5jZS5yZXZlcnNlZCAmJiBpbnN0YW5jZS5sb29wICE9PSB0cnVlIHx8IChkaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnICYmIGluc3RhbmNlLmxvb3AgPT09IDEpKSB7IGluc3RhbmNlLnJlbWFpbmluZysrOyB9XG4gICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gOiAwKTtcbiAgfTtcblxuICAvLyBpbnRlcm5hbCBtZXRob2QgKGZvciBlbmdpbmUpIHRvIGFkanVzdCBhbmltYXRpb24gdGltaW5ncyBiZWZvcmUgcmVzdG9yaW5nIGVuZ2luZSB0aWNrcyAockFGKVxuICBpbnN0YW5jZS5fb25Eb2N1bWVudFZpc2liaWxpdHkgPSByZXNldFRpbWU7XG5cbiAgLy8gU2V0IFZhbHVlIGhlbHBlclxuXG4gIGluc3RhbmNlLnNldCA9IGZ1bmN0aW9uKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgICBzZXRUYXJnZXRzVmFsdWUodGFyZ2V0cywgcHJvcGVydGllcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGluc3RhbmNlLnRpY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgbm93ID0gdDtcbiAgICBpZiAoIXN0YXJ0VGltZSkgeyBzdGFydFRpbWUgPSBub3c7IH1cbiAgICBzZXRJbnN0YW5jZVByb2dyZXNzKChub3cgKyAobGFzdFRpbWUgLSBzdGFydFRpbWUpKSAqIGFuaW1lLnNwZWVkKTtcbiAgfTtcblxuICBpbnN0YW5jZS5zZWVrID0gZnVuY3Rpb24odGltZSkge1xuICAgIHNldEluc3RhbmNlUHJvZ3Jlc3MoYWRqdXN0VGltZSh0aW1lKSk7XG4gIH07XG5cbiAgaW5zdGFuY2UucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWluc3RhbmNlLnBhdXNlZCkgeyByZXR1cm47IH1cbiAgICBpZiAoaW5zdGFuY2UuY29tcGxldGVkKSB7IGluc3RhbmNlLnJlc2V0KCk7IH1cbiAgICBpbnN0YW5jZS5wYXVzZWQgPSBmYWxzZTtcbiAgICBhY3RpdmVJbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgcmVzZXRUaW1lKCk7XG4gICAgZW5naW5lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCk7XG4gICAgaW5zdGFuY2UuY29tcGxldGVkID0gaW5zdGFuY2UucmV2ZXJzZWQgPyBmYWxzZSA6IHRydWU7XG4gICAgcmVzZXRUaW1lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGluc3RhbmNlLnJlc2V0KCk7XG4gICAgaW5zdGFuY2UucGxheSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlbW92ZSA9IGZ1bmN0aW9uKHRhcmdldHMpIHtcbiAgICB2YXIgdGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICAgIHJlbW92ZVRhcmdldHNGcm9tSW5zdGFuY2UodGFyZ2V0c0FycmF5LCBpbnN0YW5jZSk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmVzZXQoKTtcblxuICBpZiAoaW5zdGFuY2UuYXV0b3BsYXkpIHsgaW5zdGFuY2UucGxheSgpOyB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xuXG59XG5cbi8vIFJlbW92ZSB0YXJnZXRzIGZyb20gYW5pbWF0aW9uXG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnMpIHtcbiAgZm9yICh2YXIgYSA9IGFuaW1hdGlvbnMubGVuZ3RoOyBhLS07KSB7XG4gICAgaWYgKGFycmF5Q29udGFpbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zW2FdLmFuaW1hdGFibGUudGFyZ2V0KSkge1xuICAgICAgYW5pbWF0aW9ucy5zcGxpY2UoYSwgMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHNGcm9tSW5zdGFuY2UodGFyZ2V0c0FycmF5LCBpbnN0YW5jZSkge1xuICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gIHZhciBjaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuO1xuICByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zKTtcbiAgZm9yICh2YXIgYyA9IGNoaWxkcmVuLmxlbmd0aDsgYy0tOykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2NdO1xuICAgIHZhciBjaGlsZEFuaW1hdGlvbnMgPSBjaGlsZC5hbmltYXRpb25zO1xuICAgIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGNoaWxkQW5pbWF0aW9ucyk7XG4gICAgaWYgKCFjaGlsZEFuaW1hdGlvbnMubGVuZ3RoICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHsgY2hpbGRyZW4uc3BsaWNlKGMsIDEpOyB9XG4gIH1cbiAgaWYgKCFhbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGRyZW4ubGVuZ3RoKSB7IGluc3RhbmNlLnBhdXNlKCk7IH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0c0Zyb21BY3RpdmVJbnN0YW5jZXModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICBmb3IgKHZhciBpID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDsgaS0tOykge1xuICAgIHZhciBpbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICByZW1vdmVUYXJnZXRzRnJvbUluc3RhbmNlKHRhcmdldHNBcnJheSwgaW5zdGFuY2UpO1xuICB9XG59XG5cbi8vIFN0YWdnZXIgaGVscGVyc1xuXG5mdW5jdGlvbiBzdGFnZ2VyKHZhbCwgcGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgZGlyZWN0aW9uID0gcGFyYW1zLmRpcmVjdGlvbiB8fCAnbm9ybWFsJztcbiAgdmFyIGVhc2luZyA9IHBhcmFtcy5lYXNpbmcgPyBwYXJzZUVhc2luZ3MocGFyYW1zLmVhc2luZykgOiBudWxsO1xuICB2YXIgZ3JpZCA9IHBhcmFtcy5ncmlkO1xuICB2YXIgYXhpcyA9IHBhcmFtcy5heGlzO1xuICB2YXIgZnJvbUluZGV4ID0gcGFyYW1zLmZyb20gfHwgMDtcbiAgdmFyIGZyb21GaXJzdCA9IGZyb21JbmRleCA9PT0gJ2ZpcnN0JztcbiAgdmFyIGZyb21DZW50ZXIgPSBmcm9tSW5kZXggPT09ICdjZW50ZXInO1xuICB2YXIgZnJvbUxhc3QgPSBmcm9tSW5kZXggPT09ICdsYXN0JztcbiAgdmFyIGlzUmFuZ2UgPSBpcy5hcnIodmFsKTtcbiAgdmFyIHZhbDEgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMF0pIDogcGFyc2VGbG9hdCh2YWwpO1xuICB2YXIgdmFsMiA9IGlzUmFuZ2UgPyBwYXJzZUZsb2F0KHZhbFsxXSkgOiAwO1xuICB2YXIgdW5pdCA9IGdldFVuaXQoaXNSYW5nZSA/IHZhbFsxXSA6IHZhbCkgfHwgMDtcbiAgdmFyIHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDAgKyAoaXNSYW5nZSA/IHZhbDEgOiAwKTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgbWF4VmFsdWUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCBpLCB0KSB7XG4gICAgaWYgKGZyb21GaXJzdCkgeyBmcm9tSW5kZXggPSAwOyB9XG4gICAgaWYgKGZyb21DZW50ZXIpIHsgZnJvbUluZGV4ID0gKHQgLSAxKSAvIDI7IH1cbiAgICBpZiAoZnJvbUxhc3QpIHsgZnJvbUluZGV4ID0gdCAtIDE7IH1cbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0OyBpbmRleCsrKSB7XG4gICAgICAgIGlmICghZ3JpZCkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKE1hdGguYWJzKGZyb21JbmRleCAtIGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb21YID0gIWZyb21DZW50ZXIgPyBmcm9tSW5kZXglZ3JpZFswXSA6IChncmlkWzBdLTEpLzI7XG4gICAgICAgICAgdmFyIGZyb21ZID0gIWZyb21DZW50ZXIgPyBNYXRoLmZsb29yKGZyb21JbmRleC9ncmlkWzBdKSA6IChncmlkWzFdLTEpLzI7XG4gICAgICAgICAgdmFyIHRvWCA9IGluZGV4JWdyaWRbMF07XG4gICAgICAgICAgdmFyIHRvWSA9IE1hdGguZmxvb3IoaW5kZXgvZ3JpZFswXSk7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBmcm9tWSAtIHRvWTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLnNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7IHZhbHVlID0gLWRpc3RhbmNlWDsgfVxuICAgICAgICAgIGlmIChheGlzID09PSAneScpIHsgdmFsdWUgPSAtZGlzdGFuY2VZOyB9XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlYXNpbmcpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBlYXNpbmcodmFsIC8gbWF4VmFsdWUpICogbWF4VmFsdWU7IH0pOyB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAncmV2ZXJzZScpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBheGlzID8gKHZhbCA8IDApID8gdmFsICogLTEgOiAtdmFsIDogTWF0aC5hYnMobWF4VmFsdWUgLSB2YWwpOyB9KTsgfVxuICAgIH1cbiAgICB2YXIgc3BhY2luZyA9IGlzUmFuZ2UgPyAodmFsMiAtIHZhbDEpIC8gbWF4VmFsdWUgOiB2YWwxO1xuICAgIHJldHVybiBzdGFydCArIChzcGFjaW5nICogKE1hdGgucm91bmQodmFsdWVzW2ldICogMTAwKSAvIDEwMCkpICsgdW5pdDtcbiAgfVxufVxuXG4vLyBUaW1lbGluZVxuXG5mdW5jdGlvbiB0aW1lbGluZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG4gIHZhciB0bCA9IGFuaW1lKHBhcmFtcyk7XG4gIHRsLmR1cmF0aW9uID0gMDtcbiAgdGwuYWRkID0gZnVuY3Rpb24oaW5zdGFuY2VQYXJhbXMsIHRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgdmFyIHRsSW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZih0bCk7XG4gICAgdmFyIGNoaWxkcmVuID0gdGwuY2hpbGRyZW47XG4gICAgaWYgKHRsSW5kZXggPiAtMSkgeyBhY3RpdmVJbnN0YW5jZXMuc3BsaWNlKHRsSW5kZXgsIDEpOyB9XG4gICAgZnVuY3Rpb24gcGFzc1Rocm91Z2goaW5zKSB7IGlucy5wYXNzVGhyb3VnaCA9IHRydWU7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IHBhc3NUaHJvdWdoKGNoaWxkcmVuW2ldKTsgfVxuICAgIHZhciBpbnNQYXJhbXMgPSBtZXJnZU9iamVjdHMoaW5zdGFuY2VQYXJhbXMsIHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKSk7XG4gICAgaW5zUGFyYW1zLnRhcmdldHMgPSBpbnNQYXJhbXMudGFyZ2V0cyB8fCBwYXJhbXMudGFyZ2V0cztcbiAgICB2YXIgdGxEdXJhdGlvbiA9IHRsLmR1cmF0aW9uO1xuICAgIGluc1BhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgIGluc1BhcmFtcy5kaXJlY3Rpb24gPSB0bC5kaXJlY3Rpb247XG4gICAgaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0ID0gaXMudW5kKHRpbWVsaW5lT2Zmc2V0KSA/IHRsRHVyYXRpb24gOiBnZXRSZWxhdGl2ZVZhbHVlKHRpbWVsaW5lT2Zmc2V0LCB0bER1cmF0aW9uKTtcbiAgICBwYXNzVGhyb3VnaCh0bCk7XG4gICAgdGwuc2VlayhpbnNQYXJhbXMudGltZWxpbmVPZmZzZXQpO1xuICAgIHZhciBpbnMgPSBhbmltZShpbnNQYXJhbXMpO1xuICAgIHBhc3NUaHJvdWdoKGlucyk7XG4gICAgY2hpbGRyZW4ucHVzaChpbnMpO1xuICAgIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGNoaWxkcmVuLCBwYXJhbXMpO1xuICAgIHRsLmRlbGF5ID0gdGltaW5ncy5kZWxheTtcbiAgICB0bC5lbmREZWxheSA9IHRpbWluZ3MuZW5kRGVsYXk7XG4gICAgdGwuZHVyYXRpb24gPSB0aW1pbmdzLmR1cmF0aW9uO1xuICAgIHRsLnNlZWsoMCk7XG4gICAgdGwucmVzZXQoKTtcbiAgICBpZiAodGwuYXV0b3BsYXkpIHsgdGwucGxheSgpOyB9XG4gICAgcmV0dXJuIHRsO1xuICB9O1xuICByZXR1cm4gdGw7XG59XG5cbmFuaW1lLnZlcnNpb24gPSAnMy4yLjEnO1xuYW5pbWUuc3BlZWQgPSAxO1xuLy8gVE9ETzojcmV2aWV3OiBuYW1pbmcsIGRvY3VtZW50YXRpb25cbmFuaW1lLnN1c3BlbmRXaGVuRG9jdW1lbnRIaWRkZW4gPSB0cnVlO1xuYW5pbWUucnVubmluZyA9IGFjdGl2ZUluc3RhbmNlcztcbmFuaW1lLnJlbW92ZSA9IHJlbW92ZVRhcmdldHNGcm9tQWN0aXZlSW5zdGFuY2VzO1xuYW5pbWUuZ2V0ID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZTtcbmFuaW1lLnNldCA9IHNldFRhcmdldHNWYWx1ZTtcbmFuaW1lLmNvbnZlcnRQeCA9IGNvbnZlcnRQeFRvVW5pdDtcbmFuaW1lLnBhdGggPSBnZXRQYXRoO1xuYW5pbWUuc2V0RGFzaG9mZnNldCA9IHNldERhc2hvZmZzZXQ7XG5hbmltZS5zdGFnZ2VyID0gc3RhZ2dlcjtcbmFuaW1lLnRpbWVsaW5lID0gdGltZWxpbmU7XG5hbmltZS5lYXNpbmcgPSBwYXJzZUVhc2luZ3M7XG5hbmltZS5wZW5uZXIgPSBwZW5uZXI7XG5hbmltZS5yYW5kb20gPSBmdW5jdGlvbiAobWluLCBtYXgpIHsgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47IH07XG5cbmV4cG9ydCBkZWZhdWx0IGFuaW1lO1xuIl0sIm5hbWVzIjpbImRlZmF1bHRJbnN0YW5jZVNldHRpbmdzIiwidXBkYXRlIiwiYmVnaW4iLCJsb29wQmVnaW4iLCJjaGFuZ2VCZWdpbiIsImNoYW5nZSIsImNoYW5nZUNvbXBsZXRlIiwibG9vcENvbXBsZXRlIiwiY29tcGxldGUiLCJsb29wIiwiZGlyZWN0aW9uIiwiYXV0b3BsYXkiLCJ0aW1lbGluZU9mZnNldCIsImRlZmF1bHRUd2VlblNldHRpbmdzIiwiZHVyYXRpb24iLCJkZWxheSIsImVuZERlbGF5IiwiZWFzaW5nIiwicm91bmQiLCJ2YWxpZFRyYW5zZm9ybXMiLCJjYWNoZSIsIkNTUyIsInNwcmluZ3MiLCJtaW5NYXgiLCJ2YWwiLCJtaW4iLCJtYXgiLCJNYXRoIiwic3RyaW5nQ29udGFpbnMiLCJzdHIiLCJ0ZXh0IiwiaW5kZXhPZiIsImFwcGx5QXJndW1lbnRzIiwiZnVuYyIsImFyZ3MiLCJhcHBseSIsImlzIiwiYXJyIiwiYSIsIkFycmF5IiwiaXNBcnJheSIsIm9iaiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInB0aCIsImhhc093blByb3BlcnR5Iiwic3ZnIiwiU1ZHRWxlbWVudCIsImlucCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJkb20iLCJub2RlVHlwZSIsImZuYyIsInVuZCIsIm5pbCIsImhleCIsInRlc3QiLCJyZ2IiLCJoc2wiLCJjb2wiLCJrZXkiLCJwYXJzZUVhc2luZ1BhcmFtZXRlcnMiLCJzdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJzcGxpdCIsIm1hcCIsInAiLCJwYXJzZUZsb2F0Iiwic3ByaW5nIiwicGFyYW1zIiwibWFzcyIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJ2ZWxvY2l0eSIsIncwIiwic3FydCIsInpldGEiLCJ3ZCIsImIiLCJzb2x2ZXIiLCJ0IiwicHJvZ3Jlc3MiLCJleHAiLCJjb3MiLCJzaW4iLCJnZXREdXJhdGlvbiIsImNhY2hlZCIsImZyYW1lIiwiZWxhcHNlZCIsInJlc3QiLCJzdGVwcyIsImNlaWwiLCJiZXppZXIiLCJrU3BsaW5lVGFibGVTaXplIiwia1NhbXBsZVN0ZXBTaXplIiwiQSIsImFBMSIsImFBMiIsIkIiLCJDIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsImFBIiwiYUIiLCJtWDEiLCJtWDIiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwiaSIsImFicyIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsIm1ZMSIsIm1ZMiIsInNhbXBsZVZhbHVlcyIsIkZsb2F0MzJBcnJheSIsImdldFRGb3JYIiwiaW50ZXJ2YWxTdGFydCIsImN1cnJlbnRTYW1wbGUiLCJsYXN0U2FtcGxlIiwiZGlzdCIsImd1ZXNzRm9yVCIsImluaXRpYWxTbG9wZSIsIngiLCJwZW5uZXIiLCJlYXNlcyIsImxpbmVhciIsImZ1bmN0aW9uRWFzaW5ncyIsIlNpbmUiLCJQSSIsIkNpcmMiLCJCYWNrIiwiQm91bmNlIiwicG93MiIsInBvdyIsIkVsYXN0aWMiLCJhbXBsaXR1ZGUiLCJwZXJpb2QiLCJhc2luIiwiYmFzZUVhc2luZ3MiLCJmb3JFYWNoIiwibmFtZSIsImtleXMiLCJlYXNlSW4iLCJwYXJzZUVhc2luZ3MiLCJlYXNlIiwic2VsZWN0U3RyaW5nIiwibm9kZXMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJlIiwiZmlsdGVyQXJyYXkiLCJjYWxsYmFjayIsImxlbiIsImxlbmd0aCIsInRoaXNBcmciLCJhcmd1bWVudHMiLCJyZXN1bHQiLCJwdXNoIiwiZmxhdHRlbkFycmF5IiwicmVkdWNlIiwiY29uY2F0IiwidG9BcnJheSIsIm8iLCJOb2RlTGlzdCIsIkhUTUxDb2xsZWN0aW9uIiwic2xpY2UiLCJhcnJheUNvbnRhaW5zIiwic29tZSIsImNsb25lT2JqZWN0IiwiY2xvbmUiLCJyZXBsYWNlT2JqZWN0UHJvcHMiLCJvMSIsIm8yIiwibWVyZ2VPYmplY3RzIiwicmdiVG9SZ2JhIiwicmdiVmFsdWUiLCJoZXhUb1JnYmEiLCJoZXhWYWx1ZSIsInJneCIsInJlcGxhY2UiLCJtIiwiciIsImciLCJwYXJzZUludCIsImhzbFRvUmdiYSIsImhzbFZhbHVlIiwiaCIsInMiLCJsIiwiaHVlMnJnYiIsInEiLCJjb2xvclRvUmdiIiwiZ2V0VW5pdCIsImdldFRyYW5zZm9ybVVuaXQiLCJwcm9wTmFtZSIsImdldEZ1bmN0aW9uVmFsdWUiLCJhbmltYXRhYmxlIiwidGFyZ2V0IiwiaWQiLCJ0b3RhbCIsImdldEF0dHJpYnV0ZSIsImVsIiwicHJvcCIsImNvbnZlcnRQeFRvVW5pdCIsInZhbHVlIiwidW5pdCIsInZhbHVlVW5pdCIsImJhc2VsaW5lIiwidGVtcEVsIiwiY3JlYXRlRWxlbWVudCIsInRhZ05hbWUiLCJwYXJlbnRFbCIsInBhcmVudE5vZGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJzdHlsZSIsInBvc2l0aW9uIiwid2lkdGgiLCJmYWN0b3IiLCJvZmZzZXRXaWR0aCIsInJlbW92ZUNoaWxkIiwiY29udmVydGVkVW5pdCIsImdldENTU1ZhbHVlIiwidXBwZXJjYXNlUHJvcE5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZ2V0QW5pbWF0aW9uVHlwZSIsImdldEVsZW1lbnRUcmFuc2Zvcm1zIiwidHJhbnNmb3JtIiwicmVnIiwidHJhbnNmb3JtcyIsIk1hcCIsInNldCIsImdldFRyYW5zZm9ybVZhbHVlIiwiZGVmYXVsdFZhbCIsImdldCIsImxpc3QiLCJnZXRPcmlnaW5hbFRhcmdldFZhbHVlIiwiZ2V0UmVsYXRpdmVWYWx1ZSIsInRvIiwiZnJvbSIsIm9wZXJhdG9yIiwidSIsInkiLCJ2YWxpZGF0ZVZhbHVlIiwib3JpZ2luYWxVbml0IiwidW5pdExlc3MiLCJzdWJzdHIiLCJnZXREaXN0YW5jZSIsInAxIiwicDIiLCJnZXRDaXJjbGVMZW5ndGgiLCJnZXRSZWN0TGVuZ3RoIiwiZ2V0TGluZUxlbmd0aCIsImdldFBvbHlsaW5lTGVuZ3RoIiwicG9pbnRzIiwidG90YWxMZW5ndGgiLCJwcmV2aW91c1BvcyIsIm51bWJlck9mSXRlbXMiLCJjdXJyZW50UG9zIiwiZ2V0SXRlbSIsImdldFBvbHlnb25MZW5ndGgiLCJnZXRUb3RhbExlbmd0aCIsInNldERhc2hvZmZzZXQiLCJwYXRoTGVuZ3RoIiwic2V0QXR0cmlidXRlIiwiZ2V0UGFyZW50U3ZnRWwiLCJnZXRQYXJlbnRTdmciLCJwYXRoRWwiLCJzdmdEYXRhIiwicGFyZW50U3ZnRWwiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwidmlld0JveEF0dHIiLCJoZWlnaHQiLCJ2aWV3Qm94IiwidyIsInZXIiwidkgiLCJnZXRQYXRoIiwicGF0aCIsInBlcmNlbnQiLCJwcm9wZXJ0eSIsImdldFBhdGhQcm9ncmVzcyIsImlzUGF0aFRhcmdldEluc2lkZVNWRyIsInBvaW50Iiwib2Zmc2V0IiwiZ2V0UG9pbnRBdExlbmd0aCIsInAwIiwic2NhbGVYIiwic2NhbGVZIiwiYXRhbjIiLCJkZWNvbXBvc2VWYWx1ZSIsIm9yaWdpbmFsIiwibnVtYmVycyIsIk51bWJlciIsInN0cmluZ3MiLCJwYXJzZVRhcmdldHMiLCJ0YXJnZXRzIiwidGFyZ2V0c0FycmF5IiwiaXRlbSIsInBvcyIsInNlbGYiLCJnZXRBbmltYXRhYmxlcyIsInBhcnNlZCIsIm5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zIiwidHdlZW5TZXR0aW5ncyIsInNldHRpbmdzIiwiaXNGcm9tVG8iLCJwcm9wQXJyYXkiLCJ2IiwiayIsImZsYXR0ZW5LZXlmcmFtZXMiLCJrZXlmcmFtZXMiLCJwcm9wZXJ0eU5hbWVzIiwicHJvcGVydGllcyIsIm5ld0tleSIsImdldFByb3BlcnRpZXMiLCJ0d2VlbnMiLCJub3JtYWxpemVUd2VlblZhbHVlcyIsInR3ZWVuIiwibm9ybWFsaXplVHdlZW5zIiwicHJldmlvdXNUd2VlbiIsInR3ZWVuVmFsdWUiLCJ0b1VuaXQiLCJvcmlnaW5hbFZhbHVlIiwicHJldmlvdXNWYWx1ZSIsImZyb21Vbml0Iiwic3RhcnQiLCJlbmQiLCJpc1BhdGgiLCJpc0NvbG9yIiwic2V0UHJvZ3Jlc3NWYWx1ZSIsImNzcyIsImF0dHJpYnV0ZSIsIm9iamVjdCIsIm1hbnVhbCIsImxhc3QiLCJzZXRUYXJnZXRzVmFsdWUiLCJhbmltYXRhYmxlcyIsImFuaW1UeXBlIiwiY3JlYXRlQW5pbWF0aW9uIiwibGFzdFR3ZWVuIiwidHlwZSIsImdldEFuaW1hdGlvbnMiLCJnZXRJbnN0YW5jZVRpbWluZ3MiLCJhbmltYXRpb25zIiwiYW5pbUxlbmd0aCIsImdldFRsT2Zmc2V0IiwiYW5pbSIsInRpbWluZ3MiLCJpbnN0YW5jZUlEIiwiY3JlYXRlTmV3SW5zdGFuY2UiLCJpbnN0YW5jZVNldHRpbmdzIiwiY2hpbGRyZW4iLCJhY3RpdmVJbnN0YW5jZXMiLCJlbmdpbmUiLCJyYWYiLCJwbGF5IiwiaXNEb2N1bWVudEhpZGRlbiIsImFuaW1lIiwic3VzcGVuZFdoZW5Eb2N1bWVudEhpZGRlbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInN0ZXAiLCJhY3RpdmVJbnN0YW5jZXNMZW5ndGgiLCJhY3RpdmVJbnN0YW5jZSIsInBhdXNlZCIsInRpY2siLCJzcGxpY2UiLCJ1bmRlZmluZWQiLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpbnN0YW5jZSIsIl9vbkRvY3VtZW50VmlzaWJpbGl0eSIsImFkZEV2ZW50TGlzdGVuZXIiLCJoaWRkZW4iLCJzdGFydFRpbWUiLCJsYXN0VGltZSIsIm5vdyIsImNoaWxkcmVuTGVuZ3RoIiwicmVzb2x2ZSIsIm1ha2VQcm9taXNlIiwicHJvbWlzZSIsIndpbmRvdyIsIlByb21pc2UiLCJfcmVzb2x2ZSIsImZpbmlzaGVkIiwidG9nZ2xlSW5zdGFuY2VEaXJlY3Rpb24iLCJyZXZlcnNlZCIsImNoaWxkIiwiYWRqdXN0VGltZSIsInRpbWUiLCJyZXNldFRpbWUiLCJjdXJyZW50VGltZSIsInNwZWVkIiwic2Vla0NoaWxkIiwic2VlayIsInN5bmNJbnN0YW5jZUNoaWxkcmVuIiwicmV2ZXJzZVBsYXliYWNrIiwiaSQxIiwic2V0QW5pbWF0aW9uc1Byb2dyZXNzIiwiaW5zVGltZSIsImFuaW1hdGlvbnNMZW5ndGgiLCJ0d2Vlbkxlbmd0aCIsImVhc2VkIiwiaXNOYU4iLCJ0b051bWJlcnNMZW5ndGgiLCJuIiwidG9OdW1iZXIiLCJmcm9tTnVtYmVyIiwic3RyaW5nc0xlbmd0aCIsIm4kMSIsImN1cnJlbnRWYWx1ZSIsInNldENhbGxiYWNrIiwiY2IiLCJwYXNzVGhyb3VnaCIsImNvdW50SXRlcmF0aW9uIiwicmVtYWluaW5nIiwic2V0SW5zdGFuY2VQcm9ncmVzcyIsImVuZ2luZVRpbWUiLCJpbnNEdXJhdGlvbiIsImluc0RlbGF5IiwiaW5zRW5kRGVsYXkiLCJiZWdhbiIsImxvb3BCZWdhbiIsImNoYW5nZUJlZ2FuIiwiY2hhbmdlQ29tcGxldGVkIiwiY29tcGxldGVkIiwicmVzZXQiLCJwYXVzZSIsInJldmVyc2UiLCJyZXN0YXJ0IiwicmVtb3ZlIiwicmVtb3ZlVGFyZ2V0c0Zyb21JbnN0YW5jZSIsInJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyIsImMiLCJjaGlsZEFuaW1hdGlvbnMiLCJyZW1vdmVUYXJnZXRzRnJvbUFjdGl2ZUluc3RhbmNlcyIsInN0YWdnZXIiLCJncmlkIiwiYXhpcyIsImZyb21JbmRleCIsImZyb21GaXJzdCIsImZyb21DZW50ZXIiLCJmcm9tTGFzdCIsImlzUmFuZ2UiLCJ2YWwxIiwidmFsMiIsInZhbHVlcyIsIm1heFZhbHVlIiwiaW5kZXgiLCJmcm9tWCIsImZyb21ZIiwiZmxvb3IiLCJ0b1giLCJ0b1kiLCJkaXN0YW5jZVgiLCJkaXN0YW5jZVkiLCJzcGFjaW5nIiwidGltZWxpbmUiLCJ0bCIsImFkZCIsImluc3RhbmNlUGFyYW1zIiwidGxJbmRleCIsImlucyIsImluc1BhcmFtcyIsInRsRHVyYXRpb24iLCJ2ZXJzaW9uIiwicnVubmluZyIsImNvbnZlcnRQeCIsInJhbmRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../node_modules/animejs/lib/anime.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/animation/opening/Opening.jsx":
/*!*******************************************!*\
  !*** ./src/animation/opening/Opening.jsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/gsap/index.js\");\n/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! animejs */ \"(app-pages-browser)/../../../node_modules/animejs/lib/anime.es.js\");\n/* harmony import */ var _Opening_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Opening.css */ \"(app-pages-browser)/./src/animation/opening/Opening.css\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst Opening = (param)=>{\n    let { isLoading } = param;\n    _s();\n    const [animationComplete, setAnimationComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const counterRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const titleRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const cairoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const barsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Array(5).fill(null));\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let currentValue = 0;\n        const updateCounter = ()=>{\n            currentValue++;\n            if (currentValue <= 100) {\n                if (counterRef.current) {\n                    counterRef.current.textContent = currentValue;\n                }\n            } else {\n                clearInterval(interval);\n                setAnimationComplete(true);\n            }\n        };\n        const interval = setInterval(updateCounter, 30);\n        return ()=>clearInterval(interval);\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // if (animationComplete) {\n        //     const tl = gsap.timeline({\n        //         onComplete: () => {\n        //             sessionStorage.setItem('hasAnimationShown', 'true');\n        //             isLoading();\n        //         }\n        //     });\n        //     tl.to(\".counter\", { duration: 0.5, opacity: 0, ease: 'power2.inOut' });\n        //     tl.to(cairoRef.current, { opacity: 1, duration: 2, ease: 'power2.inOut' })\n        //         .to(cairoRef.current, { opacity: 0, duration: 1, ease: 'power2.inOut' });\n        //     barsRef.current.forEach(bar => {\n        //         tl.to(bar, {\n        //             duration: 2,\n        //             opacity: 1,\n        //             height: 0,\n        //             y: -400,\n        //             ease: 'power3.inOut'\n        //         }, \"<\");\n        //     });\n        // }\n        gsap__WEBPACK_IMPORTED_MODULE_4__[\"default\"].to(\".count\", {\n            opacity: 0,\n            delay: 3.5,\n            deuration: 5\n        });\n        let textWrapper = document.querySelector(\".ml16\");\n        textWrapper.innerHTML = textWrapper.textContent.replace(/\\S/g, \"<span class='letter'>$&</span>\");\n        animejs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].timeline({\n            loop: false\n        }).add({\n            targets: \".ml16 .letter\",\n            translateY: [\n                -100,\n                0\n            ],\n            easing: \"easeOutExpo\",\n            duration: 1400,\n            delay: (el, i)=>30 * i\n        }).add({\n            targets: \".ml16 .letter\",\n            translateY: [\n                0,\n                100\n            ],\n            duration: 1000,\n            easing: \"easeOutExpo\",\n            delay: (el, i)=>2000 + 30 * i\n        });\n    // gsap.to(\".ml16\", {opacity: 1, delay: 4, duration: 5});\n    // gsap.to(\".loader-2\", {opacity: 0, delay: 5, duration: 5});\n    // gsap.to(\".loader\", {opacity: 0, delay: 5, duration: 5});\n    // gsap.to(\".loader-bg\", {opacity: 0, delay: 5, duration: 5});\n    // gsap.to(\".ml16\", {opacity: 0, delay: 10, duration: 5});\n    // gsap.to(\".preloader\", {opacity: 0, delay: 10, duration: 5});\n    }, [\n        animationComplete,\n        isLoading\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"preloader\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"loader\"\n                    }, void 0, false, {\n                        fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                        lineNumber: 88,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"loader-bg\"\n                    }, void 0, false, {\n                        fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                        lineNumber: 89,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                lineNumber: 87,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"loader-content\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"count\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            ref: counterRef,\n                            children: \"0\"\n                        }, void 0, false, {\n                            fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                            lineNumber: 92,\n                            columnNumber: 40\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                        lineNumber: 92,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"copy\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"ml16\",\n                            children: \"F365\"\n                        }, void 0, false, {\n                            fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                            lineNumber: 93,\n                            columnNumber: 39\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                        lineNumber: 93,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                lineNumber: 91,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"loader-2\"\n            }, void 0, false, {\n                fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                lineNumber: 95,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true);\n};\n_s(Opening, \"S1Vv03zzM64JLpAI+2zQvXxRbSQ=\");\n_c = Opening;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Opening);\nvar _c;\n$RefreshReg$(_c, \"Opening\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hbmltYXRpb24vb3BlbmluZy9PcGVuaW5nLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkQ7QUFDbkM7QUFDSTtBQUNMO0FBRXZCLE1BQU1NLFVBQVU7UUFBQyxFQUFFQyxTQUFTLEVBQUU7O0lBQzFCLE1BQU0sQ0FBQ0MsbUJBQW1CQyxxQkFBcUIsR0FBR1AsK0NBQVFBLENBQUM7SUFDM0QsTUFBTVEsYUFBYVAsNkNBQU1BLENBQUM7SUFDMUIsTUFBTVEsWUFBWVIsNkNBQU1BLENBQUMsRUFBRTtJQUMzQixNQUFNUyxXQUFXVCw2Q0FBTUEsQ0FBQztJQUN4QixNQUFNVSxVQUFVViw2Q0FBTUEsQ0FBQyxJQUFJVyxNQUFNLEdBQUdDLElBQUksQ0FBQztJQUd6Q2QsZ0RBQVNBLENBQUM7UUFDTixJQUFJZSxlQUFlO1FBQ25CLE1BQU1DLGdCQUFnQjtZQUNsQkQ7WUFDQSxJQUFJQSxnQkFBZ0IsS0FBSztnQkFDckIsSUFBSU4sV0FBV1EsT0FBTyxFQUFFO29CQUNwQlIsV0FBV1EsT0FBTyxDQUFDQyxXQUFXLEdBQUdIO2dCQUNyQztZQUNKLE9BQU87Z0JBQ0hJLGNBQWNDO2dCQUNkWixxQkFBcUI7WUFDekI7UUFDSjtRQUVBLE1BQU1ZLFdBQVdDLFlBQVlMLGVBQWU7UUFDNUMsT0FBTyxJQUFNRyxjQUFjQztJQUMvQixHQUFHLEVBQUU7SUFFTHBCLGdEQUFTQSxDQUFDO1FBQ04sMkJBQTJCO1FBQzNCLGlDQUFpQztRQUNqQyw4QkFBOEI7UUFDOUIsbUVBQW1FO1FBQ25FLDJCQUEyQjtRQUMzQixZQUFZO1FBQ1osVUFBVTtRQUVWLDhFQUE4RTtRQUU5RSxpRkFBaUY7UUFDakYsb0ZBQW9GO1FBRXBGLHVDQUF1QztRQUN2Qyx1QkFBdUI7UUFDdkIsMkJBQTJCO1FBQzNCLDBCQUEwQjtRQUMxQix5QkFBeUI7UUFDekIsdUJBQXVCO1FBQ3ZCLG1DQUFtQztRQUNuQyxtQkFBbUI7UUFDbkIsVUFBVTtRQUNWLElBQUk7UUFFSkcsNENBQUlBLENBQUNtQixFQUFFLENBQUMsVUFBVTtZQUFFQyxTQUFTO1lBQUdDLE9BQU87WUFBS0MsV0FBVztRQUFFO1FBQ3pELElBQUlDLGNBQWNDLFNBQVNDLGFBQWEsQ0FBQztRQUN6Q0YsWUFBWUcsU0FBUyxHQUFHSCxZQUFZUixXQUFXLENBQUNZLE9BQU8sQ0FBQyxPQUFPO1FBQy9EMUIsK0NBQUtBLENBQUMyQixRQUFRLENBQUM7WUFBRUMsTUFBTTtRQUFNLEdBQ3hCQyxHQUFHLENBQUM7WUFDREMsU0FBUztZQUNUQyxZQUFZO2dCQUFDLENBQUM7Z0JBQUs7YUFBRTtZQUNyQkMsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZiLE9BQU8sQ0FBQ2MsSUFBSUMsSUFBTSxLQUFLQTtRQUMzQixHQUFHTixHQUFHLENBQUM7WUFDSEMsU0FBUztZQUNUQyxZQUFZO2dCQUFDO2dCQUFHO2FBQUk7WUFDcEJFLFVBQVU7WUFDVkQsUUFBUTtZQUNSWixPQUFPLENBQUNjLElBQUlDLElBQU0sT0FBTyxLQUFLQTtRQUNsQztJQUVKLHlEQUF5RDtJQUN6RCw2REFBNkQ7SUFDN0QsMkRBQTJEO0lBQzNELDhEQUE4RDtJQUM5RCwwREFBMEQ7SUFDMUQsK0RBQStEO0lBRW5FLEdBQUc7UUFBQ2hDO1FBQW1CRDtLQUFVO0lBRWpDLHFCQUVJOzswQkFDSSw4REFBQ2tDO2dCQUFJQyxXQUFVOztrQ0FDWCw4REFBQ0Q7d0JBQUlDLFdBQVU7Ozs7OztrQ0FDZiw4REFBQ0Q7d0JBQUlDLFdBQVU7Ozs7Ozs7Ozs7OzswQkFFbkIsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDWCw4REFBQ0Q7d0JBQUlDLFdBQVU7a0NBQVEsNEVBQUNDOzRCQUFFQyxLQUFLbEM7c0NBQVk7Ozs7Ozs7Ozs7O2tDQUMzQyw4REFBQytCO3dCQUFJQyxXQUFVO2tDQUFPLDRFQUFDQzs0QkFBRUQsV0FBVTtzQ0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBRTlDLDhEQUFDRDtnQkFBSUMsV0FBVTs7Ozs7Ozs7QUFNM0I7R0EvRk1wQztLQUFBQTtBQWlHTiwrREFBZUEsT0FBT0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYW5pbWF0aW9uL29wZW5pbmcvT3BlbmluZy5qc3g/NDM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XG5pbXBvcnQgYW5pbWUgZnJvbSAnYW5pbWVqcyc7XG5pbXBvcnQgJy4vT3BlbmluZy5jc3MnO1xuXG5jb25zdCBPcGVuaW5nID0gKHsgaXNMb2FkaW5nIH0pID0+IHtcbiAgICBjb25zdCBbYW5pbWF0aW9uQ29tcGxldGUsIHNldEFuaW1hdGlvbkNvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBjb3VudGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHRpdGxlUmVmcyA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgY2Fpcm9SZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgYmFyc1JlZiA9IHVzZVJlZihuZXcgQXJyYXkoNSkuZmlsbChudWxsKSk7XG5cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSAwO1xuICAgICAgICBjb25zdCB1cGRhdGVDb3VudGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlKys7XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIDw9IDEwMCkge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclJlZi5jdXJyZW50LnRleHRDb250ZW50ID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgc2V0QW5pbWF0aW9uQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh1cGRhdGVDb3VudGVyLCAzMCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBpZiAoYW5pbWF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgLy8gICAgIGNvbnN0IHRsID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgIC8vICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdoYXNBbmltYXRpb25TaG93bicsICd0cnVlJyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIGlzTG9hZGluZygpO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH0pO1xuXG4gICAgICAgIC8vICAgICB0bC50byhcIi5jb3VudGVyXCIsIHsgZHVyYXRpb246IDAuNSwgb3BhY2l0eTogMCwgZWFzZTogJ3Bvd2VyMi5pbk91dCcgfSk7XG5cbiAgICAgICAgLy8gICAgIHRsLnRvKGNhaXJvUmVmLmN1cnJlbnQsIHsgb3BhY2l0eTogMSwgZHVyYXRpb246IDIsIGVhc2U6ICdwb3dlcjIuaW5PdXQnIH0pXG4gICAgICAgIC8vICAgICAgICAgLnRvKGNhaXJvUmVmLmN1cnJlbnQsIHsgb3BhY2l0eTogMCwgZHVyYXRpb246IDEsIGVhc2U6ICdwb3dlcjIuaW5PdXQnIH0pO1xuXG4gICAgICAgIC8vICAgICBiYXJzUmVmLmN1cnJlbnQuZm9yRWFjaChiYXIgPT4ge1xuICAgICAgICAvLyAgICAgICAgIHRsLnRvKGJhciwge1xuICAgICAgICAvLyAgICAgICAgICAgICBkdXJhdGlvbjogMixcbiAgICAgICAgLy8gICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgLy8gICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAvLyAgICAgICAgICAgICB5OiAtNDAwLFxuICAgICAgICAvLyAgICAgICAgICAgICBlYXNlOiAncG93ZXIzLmluT3V0J1xuICAgICAgICAvLyAgICAgICAgIH0sIFwiPFwiKTtcbiAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgZ3NhcC50byhcIi5jb3VudFwiLCB7IG9wYWNpdHk6IDAsIGRlbGF5OiAzLjUsIGRldXJhdGlvbjogNSB9KTtcbiAgICAgICAgbGV0IHRleHRXcmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1sMTYnKTtcbiAgICAgICAgdGV4dFdyYXBwZXIuaW5uZXJIVE1MID0gdGV4dFdyYXBwZXIudGV4dENvbnRlbnQucmVwbGFjZSgvXFxTL2csIFwiPHNwYW4gY2xhc3M9J2xldHRlcic+JCY8L3NwYW4+XCIpO1xuICAgICAgICBhbmltZS50aW1lbGluZSh7IGxvb3A6IGZhbHNlIH0pXG4gICAgICAgICAgICAuYWRkKHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiAnLm1sMTYgLmxldHRlcicsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogWy0xMDAsIDBdLFxuICAgICAgICAgICAgICAgIGVhc2luZzogXCJlYXNlT3V0RXhwb1wiLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxNDAwLFxuICAgICAgICAgICAgICAgIGRlbGF5OiAoZWwsIGkpID0+IDMwICogaVxuICAgICAgICAgICAgfSkuYWRkKHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiAnLm1sMTYgLmxldHRlcicsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogWzAsIDEwMF0sXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICAgICAgICAgICAgZWFzaW5nOiBcImVhc2VPdXRFeHBvXCIsXG4gICAgICAgICAgICAgICAgZGVsYXk6IChlbCwgaSkgPT4gMjAwMCArIDMwICogaVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZ3NhcC50byhcIi5tbDE2XCIsIHtvcGFjaXR5OiAxLCBkZWxheTogNCwgZHVyYXRpb246IDV9KTtcbiAgICAgICAgLy8gZ3NhcC50byhcIi5sb2FkZXItMlwiLCB7b3BhY2l0eTogMCwgZGVsYXk6IDUsIGR1cmF0aW9uOiA1fSk7XG4gICAgICAgIC8vIGdzYXAudG8oXCIubG9hZGVyXCIsIHtvcGFjaXR5OiAwLCBkZWxheTogNSwgZHVyYXRpb246IDV9KTtcbiAgICAgICAgLy8gZ3NhcC50byhcIi5sb2FkZXItYmdcIiwge29wYWNpdHk6IDAsIGRlbGF5OiA1LCBkdXJhdGlvbjogNX0pO1xuICAgICAgICAvLyBnc2FwLnRvKFwiLm1sMTZcIiwge29wYWNpdHk6IDAsIGRlbGF5OiAxMCwgZHVyYXRpb246IDV9KTtcbiAgICAgICAgLy8gZ3NhcC50byhcIi5wcmVsb2FkZXJcIiwge29wYWNpdHk6IDAsIGRlbGF5OiAxMCwgZHVyYXRpb246IDV9KTtcblxuICAgIH0sIFthbmltYXRpb25Db21wbGV0ZSwgaXNMb2FkaW5nXSk7XG5cbiAgICByZXR1cm4gKFxuXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncHJlbG9hZGVyJz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nbG9hZGVyJz48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nbG9hZGVyLWJnJz48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsb2FkZXItY29udGVudFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb3VudCc+PHAgcmVmPXtjb3VudGVyUmVmfT4wPC9wPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb3B5Jz48cCBjbGFzc05hbWU9J21sMTYnPkYzNjU8L3A+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdsb2FkZXItMic+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cblxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBPcGVuaW5nO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJnc2FwIiwiYW5pbWUiLCJPcGVuaW5nIiwiaXNMb2FkaW5nIiwiYW5pbWF0aW9uQ29tcGxldGUiLCJzZXRBbmltYXRpb25Db21wbGV0ZSIsImNvdW50ZXJSZWYiLCJ0aXRsZVJlZnMiLCJjYWlyb1JlZiIsImJhcnNSZWYiLCJBcnJheSIsImZpbGwiLCJjdXJyZW50VmFsdWUiLCJ1cGRhdGVDb3VudGVyIiwiY3VycmVudCIsInRleHRDb250ZW50IiwiY2xlYXJJbnRlcnZhbCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ0byIsIm9wYWNpdHkiLCJkZWxheSIsImRldXJhdGlvbiIsInRleHRXcmFwcGVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiaW5uZXJIVE1MIiwicmVwbGFjZSIsInRpbWVsaW5lIiwibG9vcCIsImFkZCIsInRhcmdldHMiLCJ0cmFuc2xhdGVZIiwiZWFzaW5nIiwiZHVyYXRpb24iLCJlbCIsImkiLCJkaXYiLCJjbGFzc05hbWUiLCJwIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/animation/opening/Opening.jsx\n"));

/***/ })

});