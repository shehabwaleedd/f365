"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/animejs/lib/anime.es.js":
/*!**********************************************!*\
  !*** ./node_modules/animejs/lib/anime.es.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/*\n * anime.js v3.2.2\n * (c) 2023 Julian Garnier\n * Released under the MIT license\n * animejs.com\n */ // Defaults\nvar defaultInstanceSettings = {\n    update: null,\n    begin: null,\n    loopBegin: null,\n    changeBegin: null,\n    change: null,\n    changeComplete: null,\n    loopComplete: null,\n    complete: null,\n    loop: 1,\n    direction: \"normal\",\n    autoplay: true,\n    timelineOffset: 0\n};\nvar defaultTweenSettings = {\n    duration: 1000,\n    delay: 0,\n    endDelay: 0,\n    easing: \"easeOutElastic(1, .5)\",\n    round: 0\n};\nvar validTransforms = [\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"scaleZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n    \"perspective\",\n    \"matrix\",\n    \"matrix3d\"\n];\n// Caching\nvar cache = {\n    CSS: {},\n    springs: {}\n};\n// Utils\nfunction minMax(val, min, max) {\n    return Math.min(Math.max(val, min), max);\n}\nfunction stringContains(str, text) {\n    return str.indexOf(text) > -1;\n}\nfunction applyArguments(func, args) {\n    return func.apply(null, args);\n}\nvar is = {\n    arr: function(a) {\n        return Array.isArray(a);\n    },\n    obj: function(a) {\n        return stringContains(Object.prototype.toString.call(a), \"Object\");\n    },\n    pth: function(a) {\n        return is.obj(a) && a.hasOwnProperty(\"totalLength\");\n    },\n    svg: function(a) {\n        return a instanceof SVGElement;\n    },\n    inp: function(a) {\n        return a instanceof HTMLInputElement;\n    },\n    dom: function(a) {\n        return a.nodeType || is.svg(a);\n    },\n    str: function(a) {\n        return typeof a === \"string\";\n    },\n    fnc: function(a) {\n        return typeof a === \"function\";\n    },\n    und: function(a) {\n        return typeof a === \"undefined\";\n    },\n    nil: function(a) {\n        return is.und(a) || a === null;\n    },\n    hex: function(a) {\n        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);\n    },\n    rgb: function(a) {\n        return /^rgb/.test(a);\n    },\n    hsl: function(a) {\n        return /^hsl/.test(a);\n    },\n    col: function(a) {\n        return is.hex(a) || is.rgb(a) || is.hsl(a);\n    },\n    key: function(a) {\n        return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== \"targets\" && a !== \"keyframes\";\n    }\n};\n// Easings\nfunction parseEasingParameters(string) {\n    var match = /\\(([^)]+)\\)/.exec(string);\n    return match ? match[1].split(\",\").map(function(p) {\n        return parseFloat(p);\n    }) : [];\n}\n// Spring solver inspired by Webkit Copyright Â© 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js\nfunction spring(string, duration) {\n    var params = parseEasingParameters(string);\n    var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);\n    var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);\n    var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);\n    var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);\n    var w0 = Math.sqrt(stiffness / mass);\n    var zeta = damping / (2 * Math.sqrt(stiffness * mass));\n    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;\n    var a = 1;\n    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;\n    function solver(t) {\n        var progress = duration ? duration * t / 1000 : t;\n        if (zeta < 1) {\n            progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));\n        } else {\n            progress = (a + b * progress) * Math.exp(-progress * w0);\n        }\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        return 1 - progress;\n    }\n    function getDuration() {\n        var cached = cache.springs[string];\n        if (cached) {\n            return cached;\n        }\n        var frame = 1 / 6;\n        var elapsed = 0;\n        var rest = 0;\n        while(true){\n            elapsed += frame;\n            if (solver(elapsed) === 1) {\n                rest++;\n                if (rest >= 16) {\n                    break;\n                }\n            } else {\n                rest = 0;\n            }\n        }\n        var duration = elapsed * frame * 1000;\n        cache.springs[string] = duration;\n        return duration;\n    }\n    return duration ? solver : getDuration;\n}\n// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\nfunction steps(steps) {\n    if (steps === void 0) steps = 10;\n    return function(t) {\n        return Math.ceil(minMax(t, 0.000001, 1) * steps) * (1 / steps);\n    };\n}\n// BezierEasing https://github.com/gre/bezier-easing\nvar bezier = function() {\n    var kSplineTableSize = 11;\n    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n    function A(aA1, aA2) {\n        return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n    function B(aA1, aA2) {\n        return 3.0 * aA2 - 6.0 * aA1;\n    }\n    function C(aA1) {\n        return 3.0 * aA1;\n    }\n    function calcBezier(aT, aA1, aA2) {\n        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    }\n    function getSlope(aT, aA1, aA2) {\n        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n    function binarySubdivide(aX, aA, aB, mX1, mX2) {\n        var currentX, currentT, i = 0;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        }while (Math.abs(currentX) > 0.0000001 && ++i < 10);\n        return currentT;\n    }\n    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n        for(var i = 0; i < 4; ++i){\n            var currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    }\n    function bezier(mX1, mY1, mX2, mY2) {\n        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n            return;\n        }\n        var sampleValues = new Float32Array(kSplineTableSize);\n        if (mX1 !== mY1 || mX2 !== mY2) {\n            for(var i = 0; i < kSplineTableSize; ++i){\n                sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n            }\n        }\n        function getTForX(aX) {\n            var intervalStart = 0;\n            var currentSample = 1;\n            var lastSample = kSplineTableSize - 1;\n            for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n                intervalStart += kSampleStepSize;\n            }\n            --currentSample;\n            var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n            var guessForT = intervalStart + dist * kSampleStepSize;\n            var initialSlope = getSlope(guessForT, mX1, mX2);\n            if (initialSlope >= 0.001) {\n                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n            } else if (initialSlope === 0.0) {\n                return guessForT;\n            } else {\n                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n            }\n        }\n        return function(x) {\n            if (mX1 === mY1 && mX2 === mY2) {\n                return x;\n            }\n            if (x === 0 || x === 1) {\n                return x;\n            }\n            return calcBezier(getTForX(x), mY1, mY2);\n        };\n    }\n    return bezier;\n}();\nvar penner = function() {\n    // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)\n    var eases = {\n        linear: function() {\n            return function(t) {\n                return t;\n            };\n        }\n    };\n    var functionEasings = {\n        Sine: function() {\n            return function(t) {\n                return 1 - Math.cos(t * Math.PI / 2);\n            };\n        },\n        Expo: function() {\n            return function(t) {\n                return t ? Math.pow(2, 10 * t - 10) : 0;\n            };\n        },\n        Circ: function() {\n            return function(t) {\n                return 1 - Math.sqrt(1 - t * t);\n            };\n        },\n        Back: function() {\n            return function(t) {\n                return t * t * (3 * t - 2);\n            };\n        },\n        Bounce: function() {\n            return function(t) {\n                var pow2, b = 4;\n                while(t < ((pow2 = Math.pow(2, --b)) - 1) / 11){}\n                return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);\n            };\n        },\n        Elastic: function(amplitude, period) {\n            if (amplitude === void 0) amplitude = 1;\n            if (period === void 0) period = .5;\n            var a = minMax(amplitude, 1, 10);\n            var p = minMax(period, .1, 2);\n            return function(t) {\n                return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);\n            };\n        }\n    };\n    var baseEasings = [\n        \"Quad\",\n        \"Cubic\",\n        \"Quart\",\n        \"Quint\"\n    ];\n    baseEasings.forEach(function(name, i) {\n        functionEasings[name] = function() {\n            return function(t) {\n                return Math.pow(t, i + 2);\n            };\n        };\n    });\n    Object.keys(functionEasings).forEach(function(name) {\n        var easeIn = functionEasings[name];\n        eases[\"easeIn\" + name] = easeIn;\n        eases[\"easeOut\" + name] = function(a, b) {\n            return function(t) {\n                return 1 - easeIn(a, b)(1 - t);\n            };\n        };\n        eases[\"easeInOut\" + name] = function(a, b) {\n            return function(t) {\n                return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;\n            };\n        };\n        eases[\"easeOutIn\" + name] = function(a, b) {\n            return function(t) {\n                return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : (easeIn(a, b)(t * 2 - 1) + 1) / 2;\n            };\n        };\n    });\n    return eases;\n}();\nfunction parseEasings(easing, duration) {\n    if (is.fnc(easing)) {\n        return easing;\n    }\n    var name = easing.split(\"(\")[0];\n    var ease = penner[name];\n    var args = parseEasingParameters(easing);\n    switch(name){\n        case \"spring\":\n            return spring(easing, duration);\n        case \"cubicBezier\":\n            return applyArguments(bezier, args);\n        case \"steps\":\n            return applyArguments(steps, args);\n        default:\n            return applyArguments(ease, args);\n    }\n}\n// Strings\nfunction selectString(str) {\n    try {\n        var nodes = document.querySelectorAll(str);\n        return nodes;\n    } catch (e) {\n        return;\n    }\n}\n// Arrays\nfunction filterArray(arr, callback) {\n    var len = arr.length;\n    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n    var result = [];\n    for(var i = 0; i < len; i++){\n        if (i in arr) {\n            var val = arr[i];\n            if (callback.call(thisArg, val, i, arr)) {\n                result.push(val);\n            }\n        }\n    }\n    return result;\n}\nfunction flattenArray(arr) {\n    return arr.reduce(function(a, b) {\n        return a.concat(is.arr(b) ? flattenArray(b) : b);\n    }, []);\n}\nfunction toArray(o) {\n    if (is.arr(o)) {\n        return o;\n    }\n    if (is.str(o)) {\n        o = selectString(o) || o;\n    }\n    if (o instanceof NodeList || o instanceof HTMLCollection) {\n        return [].slice.call(o);\n    }\n    return [\n        o\n    ];\n}\nfunction arrayContains(arr, val) {\n    return arr.some(function(a) {\n        return a === val;\n    });\n}\n// Objects\nfunction cloneObject(o) {\n    var clone = {};\n    for(var p in o){\n        clone[p] = o[p];\n    }\n    return clone;\n}\nfunction replaceObjectProps(o1, o2) {\n    var o = cloneObject(o1);\n    for(var p in o1){\n        o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];\n    }\n    return o;\n}\nfunction mergeObjects(o1, o2) {\n    var o = cloneObject(o1);\n    for(var p in o2){\n        o[p] = is.und(o1[p]) ? o2[p] : o1[p];\n    }\n    return o;\n}\n// Colors\nfunction rgbToRgba(rgbValue) {\n    var rgb = /rgb\\((\\d+,\\s*[\\d]+,\\s*[\\d]+)\\)/g.exec(rgbValue);\n    return rgb ? \"rgba(\" + rgb[1] + \",1)\" : rgbValue;\n}\nfunction hexToRgba(hexValue) {\n    var rgx = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    var hex = hexValue.replace(rgx, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n    });\n    var rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    var r = parseInt(rgb[1], 16);\n    var g = parseInt(rgb[2], 16);\n    var b = parseInt(rgb[3], 16);\n    return \"rgba(\" + r + \",\" + g + \",\" + b + \",1)\";\n}\nfunction hslToRgba(hslValue) {\n    var hsl = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(hslValue) || /hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*([\\d.]+)\\)/g.exec(hslValue);\n    var h = parseInt(hsl[1], 10) / 360;\n    var s = parseInt(hsl[2], 10) / 100;\n    var l = parseInt(hsl[3], 10) / 100;\n    var a = hsl[4] || 1;\n    function hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    var r, g, b;\n    if (s == 0) {\n        r = g = b = l;\n    } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return \"rgba(\" + r * 255 + \",\" + g * 255 + \",\" + b * 255 + \",\" + a + \")\";\n}\nfunction colorToRgb(val) {\n    if (is.rgb(val)) {\n        return rgbToRgba(val);\n    }\n    if (is.hex(val)) {\n        return hexToRgba(val);\n    }\n    if (is.hsl(val)) {\n        return hslToRgba(val);\n    }\n}\n// Units\nfunction getUnit(val) {\n    var split = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);\n    if (split) {\n        return split[1];\n    }\n}\nfunction getTransformUnit(propName) {\n    if (stringContains(propName, \"translate\") || propName === \"perspective\") {\n        return \"px\";\n    }\n    if (stringContains(propName, \"rotate\") || stringContains(propName, \"skew\")) {\n        return \"deg\";\n    }\n}\n// Values\nfunction getFunctionValue(val, animatable) {\n    if (!is.fnc(val)) {\n        return val;\n    }\n    return val(animatable.target, animatable.id, animatable.total);\n}\nfunction getAttribute(el, prop) {\n    return el.getAttribute(prop);\n}\nfunction convertPxToUnit(el, value, unit) {\n    var valueUnit = getUnit(value);\n    if (arrayContains([\n        unit,\n        \"deg\",\n        \"rad\",\n        \"turn\"\n    ], valueUnit)) {\n        return value;\n    }\n    var cached = cache.CSS[value + unit];\n    if (!is.und(cached)) {\n        return cached;\n    }\n    var baseline = 100;\n    var tempEl = document.createElement(el.tagName);\n    var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;\n    parentEl.appendChild(tempEl);\n    tempEl.style.position = \"absolute\";\n    tempEl.style.width = baseline + unit;\n    var factor = baseline / tempEl.offsetWidth;\n    parentEl.removeChild(tempEl);\n    var convertedUnit = factor * parseFloat(value);\n    cache.CSS[value + unit] = convertedUnit;\n    return convertedUnit;\n}\nfunction getCSSValue(el, prop, unit) {\n    if (prop in el.style) {\n        var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n        var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || \"0\";\n        return unit ? convertPxToUnit(el, value, unit) : value;\n    }\n}\nfunction getAnimationType(el, prop) {\n    if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || is.svg(el) && el[prop])) {\n        return \"attribute\";\n    }\n    if (is.dom(el) && arrayContains(validTransforms, prop)) {\n        return \"transform\";\n    }\n    if (is.dom(el) && prop !== \"transform\" && getCSSValue(el, prop)) {\n        return \"css\";\n    }\n    if (el[prop] != null) {\n        return \"object\";\n    }\n}\nfunction getElementTransforms(el) {\n    if (!is.dom(el)) {\n        return;\n    }\n    var str = el.style.transform || \"\";\n    var reg = /(\\w+)\\(([^)]*)\\)/g;\n    var transforms = new Map();\n    var m;\n    while(m = reg.exec(str)){\n        transforms.set(m[1], m[2]);\n    }\n    return transforms;\n}\nfunction getTransformValue(el, propName, animatable, unit) {\n    var defaultVal = stringContains(propName, \"scale\") ? 1 : 0 + getTransformUnit(propName);\n    var value = getElementTransforms(el).get(propName) || defaultVal;\n    if (animatable) {\n        animatable.transforms.list.set(propName, value);\n        animatable.transforms[\"last\"] = propName;\n    }\n    return unit ? convertPxToUnit(el, value, unit) : value;\n}\nfunction getOriginalTargetValue(target, propName, unit, animatable) {\n    switch(getAnimationType(target, propName)){\n        case \"transform\":\n            return getTransformValue(target, propName, animatable, unit);\n        case \"css\":\n            return getCSSValue(target, propName, unit);\n        case \"attribute\":\n            return getAttribute(target, propName);\n        default:\n            return target[propName] || 0;\n    }\n}\nfunction getRelativeValue(to, from) {\n    var operator = /^(\\*=|\\+=|-=)/.exec(to);\n    if (!operator) {\n        return to;\n    }\n    var u = getUnit(to) || 0;\n    var x = parseFloat(from);\n    var y = parseFloat(to.replace(operator[0], \"\"));\n    switch(operator[0][0]){\n        case \"+\":\n            return x + y + u;\n        case \"-\":\n            return x - y + u;\n        case \"*\":\n            return x * y + u;\n    }\n}\nfunction validateValue(val, unit) {\n    if (is.col(val)) {\n        return colorToRgb(val);\n    }\n    if (/\\s/g.test(val)) {\n        return val;\n    }\n    var originalUnit = getUnit(val);\n    var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;\n    if (unit) {\n        return unitLess + unit;\n    }\n    return unitLess;\n}\n// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes\n// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744\nfunction getDistance(p1, p2) {\n    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\nfunction getCircleLength(el) {\n    return Math.PI * 2 * getAttribute(el, \"r\");\n}\nfunction getRectLength(el) {\n    return getAttribute(el, \"width\") * 2 + getAttribute(el, \"height\") * 2;\n}\nfunction getLineLength(el) {\n    return getDistance({\n        x: getAttribute(el, \"x1\"),\n        y: getAttribute(el, \"y1\")\n    }, {\n        x: getAttribute(el, \"x2\"),\n        y: getAttribute(el, \"y2\")\n    });\n}\nfunction getPolylineLength(el) {\n    var points = el.points;\n    var totalLength = 0;\n    var previousPos;\n    for(var i = 0; i < points.numberOfItems; i++){\n        var currentPos = points.getItem(i);\n        if (i > 0) {\n            totalLength += getDistance(previousPos, currentPos);\n        }\n        previousPos = currentPos;\n    }\n    return totalLength;\n}\nfunction getPolygonLength(el) {\n    var points = el.points;\n    return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));\n}\n// Path animation\nfunction getTotalLength(el) {\n    if (el.getTotalLength) {\n        return el.getTotalLength();\n    }\n    switch(el.tagName.toLowerCase()){\n        case \"circle\":\n            return getCircleLength(el);\n        case \"rect\":\n            return getRectLength(el);\n        case \"line\":\n            return getLineLength(el);\n        case \"polyline\":\n            return getPolylineLength(el);\n        case \"polygon\":\n            return getPolygonLength(el);\n    }\n}\nfunction setDashoffset(el) {\n    var pathLength = getTotalLength(el);\n    el.setAttribute(\"stroke-dasharray\", pathLength);\n    return pathLength;\n}\n// Motion path\nfunction getParentSvgEl(el) {\n    var parentEl = el.parentNode;\n    while(is.svg(parentEl)){\n        if (!is.svg(parentEl.parentNode)) {\n            break;\n        }\n        parentEl = parentEl.parentNode;\n    }\n    return parentEl;\n}\nfunction getParentSvg(pathEl, svgData) {\n    var svg = svgData || {};\n    var parentSvgEl = svg.el || getParentSvgEl(pathEl);\n    var rect = parentSvgEl.getBoundingClientRect();\n    var viewBoxAttr = getAttribute(parentSvgEl, \"viewBox\");\n    var width = rect.width;\n    var height = rect.height;\n    var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(\" \") : [\n        0,\n        0,\n        width,\n        height\n    ]);\n    return {\n        el: parentSvgEl,\n        viewBox: viewBox,\n        x: viewBox[0] / 1,\n        y: viewBox[1] / 1,\n        w: width,\n        h: height,\n        vW: viewBox[2],\n        vH: viewBox[3]\n    };\n}\nfunction getPath(path, percent) {\n    var pathEl = is.str(path) ? selectString(path)[0] : path;\n    var p = percent || 100;\n    return function(property) {\n        return {\n            property: property,\n            el: pathEl,\n            svg: getParentSvg(pathEl),\n            totalLength: getTotalLength(pathEl) * (p / 100)\n        };\n    };\n}\nfunction getPathProgress(path, progress, isPathTargetInsideSVG) {\n    function point(offset) {\n        if (offset === void 0) offset = 0;\n        var l = progress + offset >= 1 ? progress + offset : 0;\n        return path.el.getPointAtLength(l);\n    }\n    var svg = getParentSvg(path.el, path.svg);\n    var p = point();\n    var p0 = point(-1);\n    var p1 = point(+1);\n    var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;\n    var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;\n    switch(path.property){\n        case \"x\":\n            return (p.x - svg.x) * scaleX;\n        case \"y\":\n            return (p.y - svg.y) * scaleY;\n        case \"angle\":\n            return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;\n    }\n}\n// Decompose value\nfunction decomposeValue(val, unit) {\n    // const rgx = /-?\\d*\\.?\\d+/g; // handles basic numbers\n    // const rgx = /[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n    var rgx = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n    var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + \"\";\n    return {\n        original: value,\n        numbers: value.match(rgx) ? value.match(rgx).map(Number) : [\n            0\n        ],\n        strings: is.str(val) || unit ? value.split(rgx) : []\n    };\n}\n// Animatables\nfunction parseTargets(targets) {\n    var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];\n    return filterArray(targetsArray, function(item, pos, self) {\n        return self.indexOf(item) === pos;\n    });\n}\nfunction getAnimatables(targets) {\n    var parsed = parseTargets(targets);\n    return parsed.map(function(t, i) {\n        return {\n            target: t,\n            id: i,\n            total: parsed.length,\n            transforms: {\n                list: getElementTransforms(t)\n            }\n        };\n    });\n}\n// Properties\nfunction normalizePropertyTweens(prop, tweenSettings) {\n    var settings = cloneObject(tweenSettings);\n    // Override duration if easing is a spring\n    if (/^spring/.test(settings.easing)) {\n        settings.duration = spring(settings.easing);\n    }\n    if (is.arr(prop)) {\n        var l = prop.length;\n        var isFromTo = l === 2 && !is.obj(prop[0]);\n        if (!isFromTo) {\n            // Duration divided by the number of tweens\n            if (!is.fnc(tweenSettings.duration)) {\n                settings.duration = tweenSettings.duration / l;\n            }\n        } else {\n            // Transform [from, to] values shorthand to a valid tween value\n            prop = {\n                value: prop\n            };\n        }\n    }\n    var propArray = is.arr(prop) ? prop : [\n        prop\n    ];\n    return propArray.map(function(v, i) {\n        var obj = is.obj(v) && !is.pth(v) ? v : {\n            value: v\n        };\n        // Default delay value should only be applied to the first tween\n        if (is.und(obj.delay)) {\n            obj.delay = !i ? tweenSettings.delay : 0;\n        }\n        // Default endDelay value should only be applied to the last tween\n        if (is.und(obj.endDelay)) {\n            obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;\n        }\n        return obj;\n    }).map(function(k) {\n        return mergeObjects(k, settings);\n    });\n}\nfunction flattenKeyframes(keyframes) {\n    var propertyNames = filterArray(flattenArray(keyframes.map(function(key) {\n        return Object.keys(key);\n    })), function(p) {\n        return is.key(p);\n    }).reduce(function(a, b) {\n        if (a.indexOf(b) < 0) {\n            a.push(b);\n        }\n        return a;\n    }, []);\n    var properties = {};\n    var loop = function(i) {\n        var propName = propertyNames[i];\n        properties[propName] = keyframes.map(function(key) {\n            var newKey = {};\n            for(var p in key){\n                if (is.key(p)) {\n                    if (p == propName) {\n                        newKey.value = key[p];\n                    }\n                } else {\n                    newKey[p] = key[p];\n                }\n            }\n            return newKey;\n        });\n    };\n    for(var i = 0; i < propertyNames.length; i++)loop(i);\n    return properties;\n}\nfunction getProperties(tweenSettings, params) {\n    var properties = [];\n    var keyframes = params.keyframes;\n    if (keyframes) {\n        params = mergeObjects(flattenKeyframes(keyframes), params);\n    }\n    for(var p in params){\n        if (is.key(p)) {\n            properties.push({\n                name: p,\n                tweens: normalizePropertyTweens(params[p], tweenSettings)\n            });\n        }\n    }\n    return properties;\n}\n// Tweens\nfunction normalizeTweenValues(tween, animatable) {\n    var t = {};\n    for(var p in tween){\n        var value = getFunctionValue(tween[p], animatable);\n        if (is.arr(value)) {\n            value = value.map(function(v) {\n                return getFunctionValue(v, animatable);\n            });\n            if (value.length === 1) {\n                value = value[0];\n            }\n        }\n        t[p] = value;\n    }\n    t.duration = parseFloat(t.duration);\n    t.delay = parseFloat(t.delay);\n    return t;\n}\nfunction normalizeTweens(prop, animatable) {\n    var previousTween;\n    return prop.tweens.map(function(t) {\n        var tween = normalizeTweenValues(t, animatable);\n        var tweenValue = tween.value;\n        var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;\n        var toUnit = getUnit(to);\n        var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);\n        var previousValue = previousTween ? previousTween.to.original : originalValue;\n        var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;\n        var fromUnit = getUnit(from) || getUnit(originalValue);\n        var unit = toUnit || fromUnit;\n        if (is.und(to)) {\n            to = previousValue;\n        }\n        tween.from = decomposeValue(from, unit);\n        tween.to = decomposeValue(getRelativeValue(to, from), unit);\n        tween.start = previousTween ? previousTween.end : 0;\n        tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;\n        tween.easing = parseEasings(tween.easing, tween.duration);\n        tween.isPath = is.pth(tweenValue);\n        tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);\n        tween.isColor = is.col(tween.from.original);\n        if (tween.isColor) {\n            tween.round = 1;\n        }\n        previousTween = tween;\n        return tween;\n    });\n}\n// Tween progress\nvar setProgressValue = {\n    css: function(t, p, v) {\n        return t.style[p] = v;\n    },\n    attribute: function(t, p, v) {\n        return t.setAttribute(p, v);\n    },\n    object: function(t, p, v) {\n        return t[p] = v;\n    },\n    transform: function(t, p, v, transforms, manual) {\n        transforms.list.set(p, v);\n        if (p === transforms.last || manual) {\n            var str = \"\";\n            transforms.list.forEach(function(value, prop) {\n                str += prop + \"(\" + value + \") \";\n            });\n            t.style.transform = str;\n        }\n    }\n};\n// Set Value helper\nfunction setTargetsValue(targets, properties) {\n    var animatables = getAnimatables(targets);\n    animatables.forEach(function(animatable) {\n        for(var property in properties){\n            var value = getFunctionValue(properties[property], animatable);\n            var target = animatable.target;\n            var valueUnit = getUnit(value);\n            var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);\n            var unit = valueUnit || getUnit(originalValue);\n            var to = getRelativeValue(validateValue(value, unit), originalValue);\n            var animType = getAnimationType(target, property);\n            setProgressValue[animType](target, property, to, animatable.transforms, true);\n        }\n    });\n}\n// Animations\nfunction createAnimation(animatable, prop) {\n    var animType = getAnimationType(animatable.target, prop.name);\n    if (animType) {\n        var tweens = normalizeTweens(prop, animatable);\n        var lastTween = tweens[tweens.length - 1];\n        return {\n            type: animType,\n            property: prop.name,\n            animatable: animatable,\n            tweens: tweens,\n            duration: lastTween.end,\n            delay: tweens[0].delay,\n            endDelay: lastTween.endDelay\n        };\n    }\n}\nfunction getAnimations(animatables, properties) {\n    return filterArray(flattenArray(animatables.map(function(animatable) {\n        return properties.map(function(prop) {\n            return createAnimation(animatable, prop);\n        });\n    })), function(a) {\n        return !is.und(a);\n    });\n}\n// Create Instance\nfunction getInstanceTimings(animations, tweenSettings) {\n    var animLength = animations.length;\n    var getTlOffset = function(anim) {\n        return anim.timelineOffset ? anim.timelineOffset : 0;\n    };\n    var timings = {};\n    timings.duration = animLength ? Math.max.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.duration;\n    })) : tweenSettings.duration;\n    timings.delay = animLength ? Math.min.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.delay;\n    })) : tweenSettings.delay;\n    timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function(anim) {\n        return getTlOffset(anim) + anim.duration - anim.endDelay;\n    })) : tweenSettings.endDelay;\n    return timings;\n}\nvar instanceID = 0;\nfunction createNewInstance(params) {\n    var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);\n    var tweenSettings = replaceObjectProps(defaultTweenSettings, params);\n    var properties = getProperties(tweenSettings, params);\n    var animatables = getAnimatables(params.targets);\n    var animations = getAnimations(animatables, properties);\n    var timings = getInstanceTimings(animations, tweenSettings);\n    var id = instanceID;\n    instanceID++;\n    return mergeObjects(instanceSettings, {\n        id: id,\n        children: [],\n        animatables: animatables,\n        animations: animations,\n        duration: timings.duration,\n        delay: timings.delay,\n        endDelay: timings.endDelay\n    });\n}\n// Core\nvar activeInstances = [];\nvar engine = function() {\n    var raf;\n    function play() {\n        if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {\n            raf = requestAnimationFrame(step);\n        }\n    }\n    function step(t) {\n        // memo on algorithm issue:\n        // dangerous iteration over mutable `activeInstances`\n        // (that collection may be updated from within callbacks of `tick`-ed animation instances)\n        var activeInstancesLength = activeInstances.length;\n        var i = 0;\n        while(i < activeInstancesLength){\n            var activeInstance = activeInstances[i];\n            if (!activeInstance.paused) {\n                activeInstance.tick(t);\n                i++;\n            } else {\n                activeInstances.splice(i, 1);\n                activeInstancesLength--;\n            }\n        }\n        raf = i > 0 ? requestAnimationFrame(step) : undefined;\n    }\n    function handleVisibilityChange() {\n        if (!anime.suspendWhenDocumentHidden) {\n            return;\n        }\n        if (isDocumentHidden()) {\n            // suspend ticks\n            raf = cancelAnimationFrame(raf);\n        } else {\n            // first adjust animations to consider the time that ticks were suspended\n            activeInstances.forEach(function(instance) {\n                return instance._onDocumentVisibility();\n            });\n            engine();\n        }\n    }\n    if (typeof document !== \"undefined\") {\n        document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    }\n    return play;\n}();\nfunction isDocumentHidden() {\n    return !!document && document.hidden;\n}\n// Public Instance\nfunction anime(params) {\n    if (params === void 0) params = {};\n    var startTime = 0, lastTime = 0, now = 0;\n    var children, childrenLength = 0;\n    var resolve = null;\n    function makePromise(instance) {\n        var promise = window.Promise && new Promise(function(_resolve) {\n            return resolve = _resolve;\n        });\n        instance.finished = promise;\n        return promise;\n    }\n    var instance = createNewInstance(params);\n    var promise = makePromise(instance);\n    function toggleInstanceDirection() {\n        var direction = instance.direction;\n        if (direction !== \"alternate\") {\n            instance.direction = direction !== \"normal\" ? \"normal\" : \"reverse\";\n        }\n        instance.reversed = !instance.reversed;\n        children.forEach(function(child) {\n            return child.reversed = instance.reversed;\n        });\n    }\n    function adjustTime(time) {\n        return instance.reversed ? instance.duration - time : time;\n    }\n    function resetTime() {\n        startTime = 0;\n        lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);\n    }\n    function seekChild(time, child) {\n        if (child) {\n            child.seek(time - child.timelineOffset);\n        }\n    }\n    function syncInstanceChildren(time) {\n        if (!instance.reversePlayback) {\n            for(var i = 0; i < childrenLength; i++){\n                seekChild(time, children[i]);\n            }\n        } else {\n            for(var i$1 = childrenLength; i$1--;){\n                seekChild(time, children[i$1]);\n            }\n        }\n    }\n    function setAnimationsProgress(insTime) {\n        var i = 0;\n        var animations = instance.animations;\n        var animationsLength = animations.length;\n        while(i < animationsLength){\n            var anim = animations[i];\n            var animatable = anim.animatable;\n            var tweens = anim.tweens;\n            var tweenLength = tweens.length - 1;\n            var tween = tweens[tweenLength];\n            // Only check for keyframes if there is more than one tween\n            if (tweenLength) {\n                tween = filterArray(tweens, function(t) {\n                    return insTime < t.end;\n                })[0] || tween;\n            }\n            var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;\n            var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);\n            var strings = tween.to.strings;\n            var round = tween.round;\n            var numbers = [];\n            var toNumbersLength = tween.to.numbers.length;\n            var progress = void 0;\n            for(var n = 0; n < toNumbersLength; n++){\n                var value = void 0;\n                var toNumber = tween.to.numbers[n];\n                var fromNumber = tween.from.numbers[n] || 0;\n                if (!tween.isPath) {\n                    value = fromNumber + eased * (toNumber - fromNumber);\n                } else {\n                    value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);\n                }\n                if (round) {\n                    if (!(tween.isColor && n > 2)) {\n                        value = Math.round(value * round) / round;\n                    }\n                }\n                numbers.push(value);\n            }\n            // Manual Array.reduce for better performances\n            var stringsLength = strings.length;\n            if (!stringsLength) {\n                progress = numbers[0];\n            } else {\n                progress = strings[0];\n                for(var s = 0; s < stringsLength; s++){\n                    var a = strings[s];\n                    var b = strings[s + 1];\n                    var n$1 = numbers[s];\n                    if (!isNaN(n$1)) {\n                        if (!b) {\n                            progress += n$1 + \" \";\n                        } else {\n                            progress += n$1 + b;\n                        }\n                    }\n                }\n            }\n            setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);\n            anim.currentValue = progress;\n            i++;\n        }\n    }\n    function setCallback(cb) {\n        if (instance[cb] && !instance.passThrough) {\n            instance[cb](instance);\n        }\n    }\n    function countIteration() {\n        if (instance.remaining && instance.remaining !== true) {\n            instance.remaining--;\n        }\n    }\n    function setInstanceProgress(engineTime) {\n        var insDuration = instance.duration;\n        var insDelay = instance.delay;\n        var insEndDelay = insDuration - instance.endDelay;\n        var insTime = adjustTime(engineTime);\n        instance.progress = minMax(insTime / insDuration * 100, 0, 100);\n        instance.reversePlayback = insTime < instance.currentTime;\n        if (children) {\n            syncInstanceChildren(insTime);\n        }\n        if (!instance.began && instance.currentTime > 0) {\n            instance.began = true;\n            setCallback(\"begin\");\n        }\n        if (!instance.loopBegan && instance.currentTime > 0) {\n            instance.loopBegan = true;\n            setCallback(\"loopBegin\");\n        }\n        if (insTime <= insDelay && instance.currentTime !== 0) {\n            setAnimationsProgress(0);\n        }\n        if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {\n            setAnimationsProgress(insDuration);\n        }\n        if (insTime > insDelay && insTime < insEndDelay) {\n            if (!instance.changeBegan) {\n                instance.changeBegan = true;\n                instance.changeCompleted = false;\n                setCallback(\"changeBegin\");\n            }\n            setCallback(\"change\");\n            setAnimationsProgress(insTime);\n        } else {\n            if (instance.changeBegan) {\n                instance.changeCompleted = true;\n                instance.changeBegan = false;\n                setCallback(\"changeComplete\");\n            }\n        }\n        instance.currentTime = minMax(insTime, 0, insDuration);\n        if (instance.began) {\n            setCallback(\"update\");\n        }\n        if (engineTime >= insDuration) {\n            lastTime = 0;\n            countIteration();\n            if (!instance.remaining) {\n                instance.paused = true;\n                if (!instance.completed) {\n                    instance.completed = true;\n                    setCallback(\"loopComplete\");\n                    setCallback(\"complete\");\n                    if (!instance.passThrough && \"Promise\" in window) {\n                        resolve();\n                        promise = makePromise(instance);\n                    }\n                }\n            } else {\n                startTime = now;\n                setCallback(\"loopComplete\");\n                instance.loopBegan = false;\n                if (instance.direction === \"alternate\") {\n                    toggleInstanceDirection();\n                }\n            }\n        }\n    }\n    instance.reset = function() {\n        var direction = instance.direction;\n        instance.passThrough = false;\n        instance.currentTime = 0;\n        instance.progress = 0;\n        instance.paused = true;\n        instance.began = false;\n        instance.loopBegan = false;\n        instance.changeBegan = false;\n        instance.completed = false;\n        instance.changeCompleted = false;\n        instance.reversePlayback = false;\n        instance.reversed = direction === \"reverse\";\n        instance.remaining = instance.loop;\n        children = instance.children;\n        childrenLength = children.length;\n        for(var i = childrenLength; i--;){\n            instance.children[i].reset();\n        }\n        if (instance.reversed && instance.loop !== true || direction === \"alternate\" && instance.loop === 1) {\n            instance.remaining++;\n        }\n        setAnimationsProgress(instance.reversed ? instance.duration : 0);\n    };\n    // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)\n    instance._onDocumentVisibility = resetTime;\n    // Set Value helper\n    instance.set = function(targets, properties) {\n        setTargetsValue(targets, properties);\n        return instance;\n    };\n    instance.tick = function(t) {\n        now = t;\n        if (!startTime) {\n            startTime = now;\n        }\n        setInstanceProgress((now + (lastTime - startTime)) * anime.speed);\n    };\n    instance.seek = function(time) {\n        setInstanceProgress(adjustTime(time));\n    };\n    instance.pause = function() {\n        instance.paused = true;\n        resetTime();\n    };\n    instance.play = function() {\n        if (!instance.paused) {\n            return;\n        }\n        if (instance.completed) {\n            instance.reset();\n        }\n        instance.paused = false;\n        activeInstances.push(instance);\n        resetTime();\n        engine();\n    };\n    instance.reverse = function() {\n        toggleInstanceDirection();\n        instance.completed = instance.reversed ? false : true;\n        resetTime();\n    };\n    instance.restart = function() {\n        instance.reset();\n        instance.play();\n    };\n    instance.remove = function(targets) {\n        var targetsArray = parseTargets(targets);\n        removeTargetsFromInstance(targetsArray, instance);\n    };\n    instance.reset();\n    if (instance.autoplay) {\n        instance.play();\n    }\n    return instance;\n}\n// Remove targets from animation\nfunction removeTargetsFromAnimations(targetsArray, animations) {\n    for(var a = animations.length; a--;){\n        if (arrayContains(targetsArray, animations[a].animatable.target)) {\n            animations.splice(a, 1);\n        }\n    }\n}\nfunction removeTargetsFromInstance(targetsArray, instance) {\n    var animations = instance.animations;\n    var children = instance.children;\n    removeTargetsFromAnimations(targetsArray, animations);\n    for(var c = children.length; c--;){\n        var child = children[c];\n        var childAnimations = child.animations;\n        removeTargetsFromAnimations(targetsArray, childAnimations);\n        if (!childAnimations.length && !child.children.length) {\n            children.splice(c, 1);\n        }\n    }\n    if (!animations.length && !children.length) {\n        instance.pause();\n    }\n}\nfunction removeTargetsFromActiveInstances(targets) {\n    var targetsArray = parseTargets(targets);\n    for(var i = activeInstances.length; i--;){\n        var instance = activeInstances[i];\n        removeTargetsFromInstance(targetsArray, instance);\n    }\n}\n// Stagger helpers\nfunction stagger(val, params) {\n    if (params === void 0) params = {};\n    var direction = params.direction || \"normal\";\n    var easing = params.easing ? parseEasings(params.easing) : null;\n    var grid = params.grid;\n    var axis = params.axis;\n    var fromIndex = params.from || 0;\n    var fromFirst = fromIndex === \"first\";\n    var fromCenter = fromIndex === \"center\";\n    var fromLast = fromIndex === \"last\";\n    var isRange = is.arr(val);\n    var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);\n    var val2 = isRange ? parseFloat(val[1]) : 0;\n    var unit = getUnit(isRange ? val[1] : val) || 0;\n    var start = params.start || 0 + (isRange ? val1 : 0);\n    var values = [];\n    var maxValue = 0;\n    return function(el, i, t) {\n        if (fromFirst) {\n            fromIndex = 0;\n        }\n        if (fromCenter) {\n            fromIndex = (t - 1) / 2;\n        }\n        if (fromLast) {\n            fromIndex = t - 1;\n        }\n        if (!values.length) {\n            for(var index = 0; index < t; index++){\n                if (!grid) {\n                    values.push(Math.abs(fromIndex - index));\n                } else {\n                    var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n                    var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n                    var toX = index % grid[0];\n                    var toY = Math.floor(index / grid[0]);\n                    var distanceX = fromX - toX;\n                    var distanceY = fromY - toY;\n                    var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n                    if (axis === \"x\") {\n                        value = -distanceX;\n                    }\n                    if (axis === \"y\") {\n                        value = -distanceY;\n                    }\n                    values.push(value);\n                }\n                maxValue = Math.max.apply(Math, values);\n            }\n            if (easing) {\n                values = values.map(function(val) {\n                    return easing(val / maxValue) * maxValue;\n                });\n            }\n            if (direction === \"reverse\") {\n                values = values.map(function(val) {\n                    return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);\n                });\n            }\n        }\n        var spacing = isRange ? (val2 - val1) / maxValue : val1;\n        return start + spacing * (Math.round(values[i] * 100) / 100) + unit;\n    };\n}\n// Timeline\nfunction timeline(params) {\n    if (params === void 0) params = {};\n    var tl = anime(params);\n    tl.duration = 0;\n    tl.add = function(instanceParams, timelineOffset) {\n        var tlIndex = activeInstances.indexOf(tl);\n        var children = tl.children;\n        if (tlIndex > -1) {\n            activeInstances.splice(tlIndex, 1);\n        }\n        function passThrough(ins) {\n            ins.passThrough = true;\n        }\n        for(var i = 0; i < children.length; i++){\n            passThrough(children[i]);\n        }\n        var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));\n        insParams.targets = insParams.targets || params.targets;\n        var tlDuration = tl.duration;\n        insParams.autoplay = false;\n        insParams.direction = tl.direction;\n        insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);\n        passThrough(tl);\n        tl.seek(insParams.timelineOffset);\n        var ins = anime(insParams);\n        passThrough(ins);\n        children.push(ins);\n        var timings = getInstanceTimings(children, params);\n        tl.delay = timings.delay;\n        tl.endDelay = timings.endDelay;\n        tl.duration = timings.duration;\n        tl.seek(0);\n        tl.reset();\n        if (tl.autoplay) {\n            tl.play();\n        }\n        return tl;\n    };\n    return tl;\n}\nanime.version = \"3.2.1\";\nanime.speed = 1;\n// TODO:#review: naming, documentation\nanime.suspendWhenDocumentHidden = true;\nanime.running = activeInstances;\nanime.remove = removeTargetsFromActiveInstances;\nanime.get = getOriginalTargetValue;\nanime.set = setTargetsValue;\nanime.convertPx = convertPxToUnit;\nanime.path = getPath;\nanime.setDashoffset = setDashoffset;\nanime.stagger = stagger;\nanime.timeline = timeline;\nanime.easing = parseEasings;\nanime.penner = penner;\nanime.random = function(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (anime);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbmltZWpzL2xpYi9hbmltZS5lcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7O0NBS0MsR0FFRCxXQUFXO0FBRVgsSUFBSUEsMEJBQTBCO0lBQzVCQyxRQUFRO0lBQ1JDLE9BQU87SUFDUEMsV0FBVztJQUNYQyxhQUFhO0lBQ2JDLFFBQVE7SUFDUkMsZ0JBQWdCO0lBQ2hCQyxjQUFjO0lBQ2RDLFVBQVU7SUFDVkMsTUFBTTtJQUNOQyxXQUFXO0lBQ1hDLFVBQVU7SUFDVkMsZ0JBQWdCO0FBQ2xCO0FBRUEsSUFBSUMsdUJBQXVCO0lBQ3pCQyxVQUFVO0lBQ1ZDLE9BQU87SUFDUEMsVUFBVTtJQUNWQyxRQUFRO0lBQ1JDLE9BQU87QUFDVDtBQUVBLElBQUlDLGtCQUFrQjtJQUFDO0lBQWM7SUFBYztJQUFjO0lBQVU7SUFBVztJQUFXO0lBQVc7SUFBUztJQUFVO0lBQVU7SUFBVTtJQUFRO0lBQVM7SUFBUztJQUFlO0lBQVU7Q0FBVztBQUVqTixVQUFVO0FBRVYsSUFBSUMsUUFBUTtJQUNWQyxLQUFLLENBQUM7SUFDTkMsU0FBUyxDQUFDO0FBQ1o7QUFFQSxRQUFRO0FBRVIsU0FBU0MsT0FBT0MsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDM0IsT0FBT0MsS0FBS0YsR0FBRyxDQUFDRSxLQUFLRCxHQUFHLENBQUNGLEtBQUtDLE1BQU1DO0FBQ3RDO0FBRUEsU0FBU0UsZUFBZUMsR0FBRyxFQUFFQyxJQUFJO0lBQy9CLE9BQU9ELElBQUlFLE9BQU8sQ0FBQ0QsUUFBUSxDQUFDO0FBQzlCO0FBRUEsU0FBU0UsZUFBZUMsSUFBSSxFQUFFQyxJQUFJO0lBQ2hDLE9BQU9ELEtBQUtFLEtBQUssQ0FBQyxNQUFNRDtBQUMxQjtBQUVBLElBQUlFLEtBQUs7SUFDUEMsS0FBSyxTQUFVQyxDQUFDO1FBQUksT0FBT0MsTUFBTUMsT0FBTyxDQUFDRjtJQUFJO0lBQzdDRyxLQUFLLFNBQVVILENBQUM7UUFBSSxP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QUlsSCxVQUFVTCxtQkFBbUJTLFVBQVVwUztRQUMzQzhZLEdBQUd2YyxLQUFLLEdBQUd5VixRQUFRelYsS0FBSztRQUN4QnVjLEdBQUd0YyxRQUFRLEdBQUd3VixRQUFReFYsUUFBUTtRQUM5QnNjLEdBQUd4YyxRQUFRLEdBQUcwVixRQUFRMVYsUUFBUTtRQUM5QndjLEdBQUdoRSxJQUFJLENBQUM7UUFDUmdFLEdBQUdoQyxLQUFLO1FBQ1IsSUFBSWdDLEdBQUczYyxRQUFRLEVBQUU7WUFBRTJjLEdBQUd0RyxJQUFJO1FBQUk7UUFDOUIsT0FBT3NHO0lBQ1Q7SUFDQSxPQUFPQTtBQUNUO0FBRUFwRyxNQUFNMkcsT0FBTyxHQUFHO0FBQ2hCM0csTUFBTWtDLEtBQUssR0FBRztBQUNkLHNDQUFzQztBQUN0Q2xDLE1BQU1DLHlCQUF5QixHQUFHO0FBQ2xDRCxNQUFNNEcsT0FBTyxHQUFHakg7QUFDaEJLLE1BQU13RSxNQUFNLEdBQUdLO0FBQ2Y3RSxNQUFNN0gsR0FBRyxHQUFHRTtBQUNaMkgsTUFBTWhJLEdBQUcsR0FBRzBHO0FBQ1pzQixNQUFNNkcsU0FBUyxHQUFHM1E7QUFDbEI4SixNQUFNaEYsSUFBSSxHQUFHRDtBQUNiaUYsTUFBTWpHLGFBQWEsR0FBR0E7QUFDdEJpRyxNQUFNOEUsT0FBTyxHQUFHQTtBQUNoQjlFLE1BQU1tRyxRQUFRLEdBQUdBO0FBQ2pCbkcsTUFBTWpXLE1BQU0sR0FBR3VJO0FBQ2YwTixNQUFNL08sTUFBTSxHQUFHQTtBQUNmK08sTUFBTThHLE1BQU0sR0FBRyxTQUFVdmMsR0FBRyxFQUFFQyxHQUFHO0lBQUksT0FBT0MsS0FBS29iLEtBQUssQ0FBQ3BiLEtBQUtxYyxNQUFNLEtBQU10YyxDQUFBQSxNQUFNRCxNQUFNLE1BQU1BO0FBQUs7QUFFL0YsK0RBQWV5VixLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hbmltZWpzL2xpYi9hbmltZS5lcy5qcz85MzczIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBhbmltZS5qcyB2My4yLjJcbiAqIChjKSAyMDIzIEp1bGlhbiBHYXJuaWVyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGFuaW1lanMuY29tXG4gKi9cblxuLy8gRGVmYXVsdHNcblxudmFyIGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzID0ge1xuICB1cGRhdGU6IG51bGwsXG4gIGJlZ2luOiBudWxsLFxuICBsb29wQmVnaW46IG51bGwsXG4gIGNoYW5nZUJlZ2luOiBudWxsLFxuICBjaGFuZ2U6IG51bGwsXG4gIGNoYW5nZUNvbXBsZXRlOiBudWxsLFxuICBsb29wQ29tcGxldGU6IG51bGwsXG4gIGNvbXBsZXRlOiBudWxsLFxuICBsb29wOiAxLFxuICBkaXJlY3Rpb246ICdub3JtYWwnLFxuICBhdXRvcGxheTogdHJ1ZSxcbiAgdGltZWxpbmVPZmZzZXQ6IDBcbn07XG5cbnZhciBkZWZhdWx0VHdlZW5TZXR0aW5ncyA9IHtcbiAgZHVyYXRpb246IDEwMDAsXG4gIGRlbGF5OiAwLFxuICBlbmREZWxheTogMCxcbiAgZWFzaW5nOiAnZWFzZU91dEVsYXN0aWMoMSwgLjUpJyxcbiAgcm91bmQ6IDBcbn07XG5cbnZhciB2YWxpZFRyYW5zZm9ybXMgPSBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJywgJ3JvdGF0ZScsICdyb3RhdGVYJywgJ3JvdGF0ZVknLCAncm90YXRlWicsICdzY2FsZScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ3NjYWxlWicsICdza2V3JywgJ3NrZXdYJywgJ3NrZXdZJywgJ3BlcnNwZWN0aXZlJywgJ21hdHJpeCcsICdtYXRyaXgzZCddO1xuXG4vLyBDYWNoaW5nXG5cbnZhciBjYWNoZSA9IHtcbiAgQ1NTOiB7fSxcbiAgc3ByaW5nczoge31cbn07XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIG1pbk1heCh2YWwsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0NvbnRhaW5zKHN0ciwgdGV4dCkge1xuICByZXR1cm4gc3RyLmluZGV4T2YodGV4dCkgPiAtMTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBcmd1bWVudHMoZnVuYywgYXJncykge1xuICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbn1cblxudmFyIGlzID0ge1xuICBhcnI6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBBcnJheS5pc0FycmF5KGEpOyB9LFxuICBvYmo6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBzdHJpbmdDb250YWlucyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSksICdPYmplY3QnKTsgfSxcbiAgcHRoOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gaXMub2JqKGEpICYmIGEuaGFzT3duUHJvcGVydHkoJ3RvdGFsTGVuZ3RoJyk7IH0sXG4gIHN2ZzogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBTVkdFbGVtZW50OyB9LFxuICBpbnA6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudDsgfSxcbiAgZG9tOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5ub2RlVHlwZSB8fCBpcy5zdmcoYSk7IH0sXG4gIHN0cjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAnc3RyaW5nJzsgfSxcbiAgZm5jOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7IH0sXG4gIHVuZDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAndW5kZWZpbmVkJzsgfSxcbiAgbmlsOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gaXMudW5kKGEpIHx8IGEgPT09IG51bGw7IH0sXG4gIGhleDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGEpOyB9LFxuICByZ2I6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvXnJnYi8udGVzdChhKTsgfSxcbiAgaHNsOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gL15oc2wvLnRlc3QoYSk7IH0sXG4gIGNvbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChpcy5oZXgoYSkgfHwgaXMucmdiKGEpIHx8IGlzLmhzbChhKSk7IH0sXG4gIGtleTogZnVuY3Rpb24gKGEpIHsgcmV0dXJuICFkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShhKSAmJiAhZGVmYXVsdFR3ZWVuU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYSkgJiYgYSAhPT0gJ3RhcmdldHMnICYmIGEgIT09ICdrZXlmcmFtZXMnOyB9LFxufTtcblxuLy8gRWFzaW5nc1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IC9cXCgoW14pXSspXFwpLy5leGVjKHN0cmluZyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwYXJzZUZsb2F0KHApOyB9KSA6IFtdO1xufVxuXG4vLyBTcHJpbmcgc29sdmVyIGluc3BpcmVkIGJ5IFdlYmtpdCBDb3B5cmlnaHQgwqkgMjAxNiBBcHBsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG5cbmZ1bmN0aW9uIHNwcmluZyhzdHJpbmcsIGR1cmF0aW9uKSB7XG5cbiAgdmFyIHBhcmFtcyA9IHBhcnNlRWFzaW5nUGFyYW1ldGVycyhzdHJpbmcpO1xuICB2YXIgbWFzcyA9IG1pbk1heChpcy51bmQocGFyYW1zWzBdKSA/IDEgOiBwYXJhbXNbMF0sIC4xLCAxMDApO1xuICB2YXIgc3RpZmZuZXNzID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMV0pID8gMTAwIDogcGFyYW1zWzFdLCAuMSwgMTAwKTtcbiAgdmFyIGRhbXBpbmcgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1syXSkgPyAxMCA6IHBhcmFtc1syXSwgLjEsIDEwMCk7XG4gIHZhciB2ZWxvY2l0eSA9ICBtaW5NYXgoaXMudW5kKHBhcmFtc1szXSkgPyAwIDogcGFyYW1zWzNdLCAuMSwgMTAwKTtcbiAgdmFyIHcwID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpO1xuICB2YXIgemV0YSA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gIHZhciB3ZCA9IHpldGEgPCAxID8gdzAgKiBNYXRoLnNxcnQoMSAtIHpldGEgKiB6ZXRhKSA6IDA7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSB6ZXRhIDwgMSA/ICh6ZXRhICogdzAgKyAtdmVsb2NpdHkpIC8gd2QgOiAtdmVsb2NpdHkgKyB3MDtcblxuICBmdW5jdGlvbiBzb2x2ZXIodCkge1xuICAgIHZhciBwcm9ncmVzcyA9IGR1cmF0aW9uID8gKGR1cmF0aW9uICogdCkgLyAxMDAwIDogdDtcbiAgICBpZiAoemV0YSA8IDEpIHtcbiAgICAgIHByb2dyZXNzID0gTWF0aC5leHAoLXByb2dyZXNzICogemV0YSAqIHcwKSAqIChhICogTWF0aC5jb3Mod2QgKiBwcm9ncmVzcykgKyBiICogTWF0aC5zaW4od2QgKiBwcm9ncmVzcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9ncmVzcyA9IChhICsgYiAqIHByb2dyZXNzKSAqIE1hdGguZXhwKC1wcm9ncmVzcyAqIHcwKTtcbiAgICB9XG4gICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkgeyByZXR1cm4gdDsgfVxuICAgIHJldHVybiAxIC0gcHJvZ3Jlc3M7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuc3ByaW5nc1tzdHJpbmddO1xuICAgIGlmIChjYWNoZWQpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICAgIHZhciBmcmFtZSA9IDEvNjtcbiAgICB2YXIgZWxhcHNlZCA9IDA7XG4gICAgdmFyIHJlc3QgPSAwO1xuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGVsYXBzZWQgKz0gZnJhbWU7XG4gICAgICBpZiAoc29sdmVyKGVsYXBzZWQpID09PSAxKSB7XG4gICAgICAgIHJlc3QrKztcbiAgICAgICAgaWYgKHJlc3QgPj0gMTYpIHsgYnJlYWs7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3QgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZHVyYXRpb24gPSBlbGFwc2VkICogZnJhbWUgKiAxMDAwO1xuICAgIGNhY2hlLnNwcmluZ3Nbc3RyaW5nXSA9IGR1cmF0aW9uO1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbiA/IHNvbHZlciA6IGdldER1cmF0aW9uO1xuXG59XG5cbi8vIEJhc2ljIHN0ZXBzIGVhc2luZyBpbXBsZW1lbnRhdGlvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9mci9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cblxuZnVuY3Rpb24gc3RlcHMoc3RlcHMpIHtcbiAgaWYgKCBzdGVwcyA9PT0gdm9pZCAwICkgc3RlcHMgPSAxMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGguY2VpbCgobWluTWF4KHQsIDAuMDAwMDAxLCAxKSkgKiBzdGVwcykgKiAoMSAvIHN0ZXBzKTsgfTtcbn1cblxuLy8gQmV6aWVyRWFzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZ1xuXG52YXIgYmV6aWVyID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xuICB2YXIga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xuXG4gIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHsgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMSB9XG4gIGZ1bmN0aW9uIEIoYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMSB9XG4gIGZ1bmN0aW9uIEMoYUExKSAgICAgIHsgcmV0dXJuIDMuMCAqIGFBMSB9XG5cbiAgZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHsgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUIH1cbiAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpIH1cblxuICBmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcbiAgICB2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkgeyBhQiA9IGN1cnJlbnRUOyB9IGVsc2UgeyBhQSA9IGN1cnJlbnRUOyB9XG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gMC4wMDAwMDAxICYmICsraSA8IDEwKTtcbiAgICByZXR1cm4gY3VycmVudFQ7XG4gIH1cblxuICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkgeyByZXR1cm4gYUd1ZXNzVDsgfVxuICAgICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuICAgIHJldHVybiBhR3Vlc3NUO1xuICB9XG5cbiAgZnVuY3Rpb24gYmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuXG4gICAgaWYgKCEoMCA8PSBtWDEgJiYgbVgxIDw9IDEgJiYgMCA8PSBtWDIgJiYgbVgyIDw9IDEpKSB7IHJldHVybjsgfVxuICAgIHZhciBzYW1wbGVWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuXG4gICAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuXG4gICAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDA7XG4gICAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgICB2YXIgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG4gICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLS1jdXJyZW50U2FtcGxlO1xuXG4gICAgICB2YXIgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgICB2YXIgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG5cbiAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gMC4wMDEpIHtcbiAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7IHJldHVybiB4OyB9XG4gICAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSAxKSB7IHJldHVybiB4OyB9XG4gICAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIGJlemllcjtcblxufSkoKTtcblxudmFyIHBlbm5lciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgLy8gQmFzZWQgb24galF1ZXJ5IFVJJ3MgaW1wbGVtZW5hdGlvbiBvZiBlYXNpbmcgZXF1YXRpb25zIGZyb20gUm9iZXJ0IFBlbm5lciAoaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZylcblxuICB2YXIgZWFzZXMgPSB7IGxpbmVhcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07IH0gfTtcblxuICB2YXIgZnVuY3Rpb25FYXNpbmdzID0ge1xuICAgIFNpbmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKTsgfTsgfSxcbiAgICBFeHBvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA/IE1hdGgucG93KDIsIDEwICogdCAtIDEwKSA6IDA7IH07IH0sXG4gICAgQ2lyYzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTsgfTsgfSxcbiAgICBCYWNrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqIHQgKiAoMyAqIHQgLSAyKTsgfTsgfSxcbiAgICBCb3VuY2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgcG93MiwgYiA9IDQ7XG4gICAgICB3aGlsZSAodCA8ICgoIHBvdzIgPSBNYXRoLnBvdygyLCAtLWIpKSAtIDEpIC8gMTEpIHt9XG4gICAgICByZXR1cm4gMSAvIE1hdGgucG93KDQsIDMgLSBiKSAtIDcuNTYyNSAqIE1hdGgucG93KCggcG93MiAqIDMgLSAyICkgLyAyMiAtIHQsIDIpXG4gICAgfTsgfSxcbiAgICBFbGFzdGljOiBmdW5jdGlvbiAoYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgICAgIGlmICggYW1wbGl0dWRlID09PSB2b2lkIDAgKSBhbXBsaXR1ZGUgPSAxO1xuICAgICAgaWYgKCBwZXJpb2QgPT09IHZvaWQgMCApIHBlcmlvZCA9IC41O1xuXG4gICAgICB2YXIgYSA9IG1pbk1heChhbXBsaXR1ZGUsIDEsIDEwKTtcbiAgICAgIHZhciBwID0gbWluTWF4KHBlcmlvZCwgLjEsIDIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAodCA9PT0gMCB8fCB0ID09PSAxKSA/IHQgOiBcbiAgICAgICAgICAtYSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKiBNYXRoLnNpbigoKCh0IC0gMSkgLSAocCAvIChNYXRoLlBJICogMikgKiBNYXRoLmFzaW4oMSAvIGEpKSkgKiAoTWF0aC5QSSAqIDIpKSAvIHApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYmFzZUVhc2luZ3MgPSBbJ1F1YWQnLCAnQ3ViaWMnLCAnUXVhcnQnLCAnUXVpbnQnXTtcblxuICBiYXNlRWFzaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgZnVuY3Rpb25FYXNpbmdzW25hbWVdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucG93KHQsIGkgKyAyKTsgfTsgfTtcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMoZnVuY3Rpb25FYXNpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGVhc2VJbiA9IGZ1bmN0aW9uRWFzaW5nc1tuYW1lXTtcbiAgICBlYXNlc1snZWFzZUluJyArIG5hbWVdID0gZWFzZUluO1xuICAgIGVhc2VzWydlYXNlT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gZWFzZUluKGEsIGIpKDEgLSB0KTsgfTsgfTtcbiAgICBlYXNlc1snZWFzZUluT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgMC41ID8gZWFzZUluKGEsIGIpKHQgKiAyKSAvIDIgOiBcbiAgICAgIDEgLSBlYXNlSW4oYSwgYikodCAqIC0yICsgMikgLyAyOyB9OyB9O1xuICAgIGVhc2VzWydlYXNlT3V0SW4nICsgbmFtZV0gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAwLjUgPyAoMSAtIGVhc2VJbihhLCBiKSgxIC0gdCAqIDIpKSAvIDIgOiBcbiAgICAgIChlYXNlSW4oYSwgYikodCAqIDIgLSAxKSArIDEpIC8gMjsgfTsgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2VzO1xuXG59KSgpO1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ3MoZWFzaW5nLCBkdXJhdGlvbikge1xuICBpZiAoaXMuZm5jKGVhc2luZykpIHsgcmV0dXJuIGVhc2luZzsgfVxuICB2YXIgbmFtZSA9IGVhc2luZy5zcGxpdCgnKCcpWzBdO1xuICB2YXIgZWFzZSA9IHBlbm5lcltuYW1lXTtcbiAgdmFyIGFyZ3MgPSBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoZWFzaW5nKTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc3ByaW5nJyA6IHJldHVybiBzcHJpbmcoZWFzaW5nLCBkdXJhdGlvbik7XG4gICAgY2FzZSAnY3ViaWNCZXppZXInIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGJlemllciwgYXJncyk7XG4gICAgY2FzZSAnc3RlcHMnIDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKHN0ZXBzLCBhcmdzKTtcbiAgICBkZWZhdWx0IDogcmV0dXJuIGFwcGx5QXJndW1lbnRzKGVhc2UsIGFyZ3MpO1xuICB9XG59XG5cbi8vIFN0cmluZ3NcblxuZnVuY3Rpb24gc2VsZWN0U3RyaW5nKHN0cikge1xuICB0cnkge1xuICAgIHZhciBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc3RyKTtcbiAgICByZXR1cm4gbm9kZXM7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG4vLyBBcnJheXNcblxuZnVuY3Rpb24gZmlsdGVyQXJyYXkoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpIGluIGFycikge1xuICAgICAgdmFyIHZhbCA9IGFycltpXTtcbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbCwgaSwgYXJyKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChpcy5hcnIoYikgPyBmbGF0dGVuQXJyYXkoYikgOiBiKTsgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KG8pIHtcbiAgaWYgKGlzLmFycihvKSkgeyByZXR1cm4gbzsgfVxuICBpZiAoaXMuc3RyKG8pKSB7IG8gPSBzZWxlY3RTdHJpbmcobykgfHwgbzsgfVxuICBpZiAobyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IG8gaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvbikgeyByZXR1cm4gW10uc2xpY2UuY2FsbChvKTsgfVxuICByZXR1cm4gW29dO1xufVxuXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSA9PT0gdmFsOyB9KTtcbn1cblxuLy8gT2JqZWN0c1xuXG5mdW5jdGlvbiBjbG9uZU9iamVjdChvKSB7XG4gIHZhciBjbG9uZSA9IHt9O1xuICBmb3IgKHZhciBwIGluIG8pIHsgY2xvbmVbcF0gPSBvW3BdOyB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZU9iamVjdFByb3BzKG8xLCBvMikge1xuICB2YXIgbyA9IGNsb25lT2JqZWN0KG8xKTtcbiAgZm9yICh2YXIgcCBpbiBvMSkgeyBvW3BdID0gbzIuaGFzT3duUHJvcGVydHkocCkgPyBvMltwXSA6IG8xW3BdOyB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMobzEsIG8yKSB7XG4gIHZhciBvID0gY2xvbmVPYmplY3QobzEpO1xuICBmb3IgKHZhciBwIGluIG8yKSB7IG9bcF0gPSBpcy51bmQobzFbcF0pID8gbzJbcF0gOiBvMVtwXTsgfVxuICByZXR1cm4gbztcbn1cblxuLy8gQ29sb3JzXG5cbmZ1bmN0aW9uIHJnYlRvUmdiYShyZ2JWYWx1ZSkge1xuICB2YXIgcmdiID0gL3JnYlxcKChcXGQrLFxccypbXFxkXSssXFxzKltcXGRdKylcXCkvZy5leGVjKHJnYlZhbHVlKTtcbiAgcmV0dXJuIHJnYiA/IChcInJnYmEoXCIgKyAocmdiWzFdKSArIFwiLDEpXCIpIDogcmdiVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGhleFRvUmdiYShoZXhWYWx1ZSkge1xuICB2YXIgcmd4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcbiAgdmFyIGhleCA9IGhleFZhbHVlLnJlcGxhY2Uocmd4LCBmdW5jdGlvbiAobSwgciwgZywgYikgeyByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiOyB9ICk7XG4gIHZhciByZ2IgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgdmFyIHIgPSBwYXJzZUludChyZ2JbMV0sIDE2KTtcbiAgdmFyIGcgPSBwYXJzZUludChyZ2JbMl0sIDE2KTtcbiAgdmFyIGIgPSBwYXJzZUludChyZ2JbM10sIDE2KTtcbiAgcmV0dXJuIChcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsMSlcIik7XG59XG5cbmZ1bmN0aW9uIGhzbFRvUmdiYShoc2xWYWx1ZSkge1xuICB2YXIgaHNsID0gL2hzbFxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJVxcKS9nLmV4ZWMoaHNsVmFsdWUpIHx8IC9oc2xhXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKylcXCkvZy5leGVjKGhzbFZhbHVlKTtcbiAgdmFyIGggPSBwYXJzZUludChoc2xbMV0sIDEwKSAvIDM2MDtcbiAgdmFyIHMgPSBwYXJzZUludChoc2xbMl0sIDEwKSAvIDEwMDtcbiAgdmFyIGwgPSBwYXJzZUludChoc2xbM10sIDEwKSAvIDEwMDtcbiAgdmFyIGEgPSBoc2xbNF0gfHwgMTtcbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7IHQgKz0gMTsgfVxuICAgIGlmICh0ID4gMSkgeyB0IC09IDE7IH1cbiAgICBpZiAodCA8IDEvNikgeyByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDsgfVxuICAgIGlmICh0IDwgMS8yKSB7IHJldHVybiBxOyB9XG4gICAgaWYgKHQgPCAyLzMpIHsgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjsgfVxuICAgIHJldHVybiBwO1xuICB9XG4gIHZhciByLCBnLCBiO1xuICBpZiAocyA9PSAwKSB7XG4gICAgciA9IGcgPSBiID0gbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEvMyk7XG4gICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gIH1cbiAgcmV0dXJuIChcInJnYmEoXCIgKyAociAqIDI1NSkgKyBcIixcIiArIChnICogMjU1KSArIFwiLFwiICsgKGIgKiAyNTUpICsgXCIsXCIgKyBhICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvUmdiKHZhbCkge1xuICBpZiAoaXMucmdiKHZhbCkpIHsgcmV0dXJuIHJnYlRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oZXgodmFsKSkgeyByZXR1cm4gaGV4VG9SZ2JhKHZhbCk7IH1cbiAgaWYgKGlzLmhzbCh2YWwpKSB7IHJldHVybiBoc2xUb1JnYmEodmFsKTsgfVxufVxuXG4vLyBVbml0c1xuXG5mdW5jdGlvbiBnZXRVbml0KHZhbCkge1xuICB2YXIgc3BsaXQgPSAvWystXT9cXGQqXFwuP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8oJXxweHxwdHxlbXxyZW18aW58Y218bW18ZXh8Y2h8cGN8dnd8dmh8dm1pbnx2bWF4fGRlZ3xyYWR8dHVybik/JC8uZXhlYyh2YWwpO1xuICBpZiAoc3BsaXQpIHsgcmV0dXJuIHNwbGl0WzFdOyB9XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVVuaXQocHJvcE5hbWUpIHtcbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAndHJhbnNsYXRlJykgfHwgcHJvcE5hbWUgPT09ICdwZXJzcGVjdGl2ZScpIHsgcmV0dXJuICdweCc7IH1cbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdza2V3JykpIHsgcmV0dXJuICdkZWcnOyB9XG59XG5cbi8vIFZhbHVlc1xuXG5mdW5jdGlvbiBnZXRGdW5jdGlvblZhbHVlKHZhbCwgYW5pbWF0YWJsZSkge1xuICBpZiAoIWlzLmZuYyh2YWwpKSB7IHJldHVybiB2YWw7IH1cbiAgcmV0dXJuIHZhbChhbmltYXRhYmxlLnRhcmdldCwgYW5pbWF0YWJsZS5pZCwgYW5pbWF0YWJsZS50b3RhbCk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgcHJvcCkge1xuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKHByb3ApO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSB7XG4gIHZhciB2YWx1ZVVuaXQgPSBnZXRVbml0KHZhbHVlKTtcbiAgaWYgKGFycmF5Q29udGFpbnMoW3VuaXQsICdkZWcnLCAncmFkJywgJ3R1cm4nXSwgdmFsdWVVbml0KSkgeyByZXR1cm4gdmFsdWU7IH1cbiAgdmFyIGNhY2hlZCA9IGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdO1xuICBpZiAoIWlzLnVuZChjYWNoZWQpKSB7IHJldHVybiBjYWNoZWQ7IH1cbiAgdmFyIGJhc2VsaW5lID0gMTAwO1xuICB2YXIgdGVtcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbC50YWdOYW1lKTtcbiAgdmFyIHBhcmVudEVsID0gKGVsLnBhcmVudE5vZGUgJiYgKGVsLnBhcmVudE5vZGUgIT09IGRvY3VtZW50KSkgPyBlbC5wYXJlbnROb2RlIDogZG9jdW1lbnQuYm9keTtcbiAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGVtcEVsKTtcbiAgdGVtcEVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgdGVtcEVsLnN0eWxlLndpZHRoID0gYmFzZWxpbmUgKyB1bml0O1xuICB2YXIgZmFjdG9yID0gYmFzZWxpbmUgLyB0ZW1wRWwub2Zmc2V0V2lkdGg7XG4gIHBhcmVudEVsLnJlbW92ZUNoaWxkKHRlbXBFbCk7XG4gIHZhciBjb252ZXJ0ZWRVbml0ID0gZmFjdG9yICogcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdID0gY29udmVydGVkVW5pdDtcbiAgcmV0dXJuIGNvbnZlcnRlZFVuaXQ7XG59XG5cbmZ1bmN0aW9uIGdldENTU1ZhbHVlKGVsLCBwcm9wLCB1bml0KSB7XG4gIGlmIChwcm9wIGluIGVsLnN0eWxlKSB7XG4gICAgdmFyIHVwcGVyY2FzZVByb3BOYW1lID0gcHJvcC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB2YWx1ZSA9IGVsLnN0eWxlW3Byb3BdIHx8IGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodXBwZXJjYXNlUHJvcE5hbWUpIHx8ICcwJztcbiAgICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uVHlwZShlbCwgcHJvcCkge1xuICBpZiAoaXMuZG9tKGVsKSAmJiAhaXMuaW5wKGVsKSAmJiAoIWlzLm5pbChnZXRBdHRyaWJ1dGUoZWwsIHByb3ApKSB8fCAoaXMuc3ZnKGVsKSAmJiBlbFtwcm9wXSkpKSB7IHJldHVybiAnYXR0cmlidXRlJzsgfVxuICBpZiAoaXMuZG9tKGVsKSAmJiBhcnJheUNvbnRhaW5zKHZhbGlkVHJhbnNmb3JtcywgcHJvcCkpIHsgcmV0dXJuICd0cmFuc2Zvcm0nOyB9XG4gIGlmIChpcy5kb20oZWwpICYmIChwcm9wICE9PSAndHJhbnNmb3JtJyAmJiBnZXRDU1NWYWx1ZShlbCwgcHJvcCkpKSB7IHJldHVybiAnY3NzJzsgfVxuICBpZiAoZWxbcHJvcF0gIT0gbnVsbCkgeyByZXR1cm4gJ29iamVjdCc7IH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFRyYW5zZm9ybXMoZWwpIHtcbiAgaWYgKCFpcy5kb20oZWwpKSB7IHJldHVybjsgfVxuICB2YXIgc3RyID0gZWwuc3R5bGUudHJhbnNmb3JtIHx8ICcnO1xuICB2YXIgcmVnICA9IC8oXFx3KylcXCgoW14pXSopXFwpL2c7XG4gIHZhciB0cmFuc2Zvcm1zID0gbmV3IE1hcCgpO1xuICB2YXIgbTsgd2hpbGUgKG0gPSByZWcuZXhlYyhzdHIpKSB7IHRyYW5zZm9ybXMuc2V0KG1bMV0sIG1bMl0pOyB9XG4gIHJldHVybiB0cmFuc2Zvcm1zO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1WYWx1ZShlbCwgcHJvcE5hbWUsIGFuaW1hdGFibGUsIHVuaXQpIHtcbiAgdmFyIGRlZmF1bHRWYWwgPSBzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3NjYWxlJykgPyAxIDogMCArIGdldFRyYW5zZm9ybVVuaXQocHJvcE5hbWUpO1xuICB2YXIgdmFsdWUgPSBnZXRFbGVtZW50VHJhbnNmb3JtcyhlbCkuZ2V0KHByb3BOYW1lKSB8fCBkZWZhdWx0VmFsO1xuICBpZiAoYW5pbWF0YWJsZSkge1xuICAgIGFuaW1hdGFibGUudHJhbnNmb3Jtcy5saXN0LnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgIGFuaW1hdGFibGUudHJhbnNmb3Jtc1snbGFzdCddID0gcHJvcE5hbWU7XG4gIH1cbiAgcmV0dXJuIHVuaXQgPyBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHVuaXQsIGFuaW1hdGFibGUpIHtcbiAgc3dpdGNoIChnZXRBbmltYXRpb25UeXBlKHRhcmdldCwgcHJvcE5hbWUpKSB7XG4gICAgY2FzZSAndHJhbnNmb3JtJzogcmV0dXJuIGdldFRyYW5zZm9ybVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGFibGUsIHVuaXQpO1xuICAgIGNhc2UgJ2Nzcyc6IHJldHVybiBnZXRDU1NWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB1bml0KTtcbiAgICBjYXNlICdhdHRyaWJ1dGUnOiByZXR1cm4gZ2V0QXR0cmlidXRlKHRhcmdldCwgcHJvcE5hbWUpO1xuICAgIGRlZmF1bHQ6IHJldHVybiB0YXJnZXRbcHJvcE5hbWVdIHx8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVWYWx1ZSh0bywgZnJvbSkge1xuICB2YXIgb3BlcmF0b3IgPSAvXihcXCo9fFxcKz18LT0pLy5leGVjKHRvKTtcbiAgaWYgKCFvcGVyYXRvcikgeyByZXR1cm4gdG87IH1cbiAgdmFyIHUgPSBnZXRVbml0KHRvKSB8fCAwO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoZnJvbSk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdCh0by5yZXBsYWNlKG9wZXJhdG9yWzBdLCAnJykpO1xuICBzd2l0Y2ggKG9wZXJhdG9yWzBdWzBdKSB7XG4gICAgY2FzZSAnKyc6IHJldHVybiB4ICsgeSArIHU7XG4gICAgY2FzZSAnLSc6IHJldHVybiB4IC0geSArIHU7XG4gICAgY2FzZSAnKic6IHJldHVybiB4ICogeSArIHU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWwsIHVuaXQpIHtcbiAgaWYgKGlzLmNvbCh2YWwpKSB7IHJldHVybiBjb2xvclRvUmdiKHZhbCk7IH1cbiAgaWYgKC9cXHMvZy50ZXN0KHZhbCkpIHsgcmV0dXJuIHZhbDsgfVxuICB2YXIgb3JpZ2luYWxVbml0ID0gZ2V0VW5pdCh2YWwpO1xuICB2YXIgdW5pdExlc3MgPSBvcmlnaW5hbFVuaXQgPyB2YWwuc3Vic3RyKDAsIHZhbC5sZW5ndGggLSBvcmlnaW5hbFVuaXQubGVuZ3RoKSA6IHZhbDtcbiAgaWYgKHVuaXQpIHsgcmV0dXJuIHVuaXRMZXNzICsgdW5pdDsgfVxuICByZXR1cm4gdW5pdExlc3M7XG59XG5cbi8vIGdldFRvdGFsTGVuZ3RoKCkgZXF1aXZhbGVudCBmb3IgY2lyY2xlLCByZWN0LCBwb2x5bGluZSwgcG9seWdvbiBhbmQgbGluZSBzaGFwZXNcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9TZWJMYW1ibGEvM2UwNTUwYzQ5NmMyMzY3MDk3NDRcblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDIueCAtIHAxLngsIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2lyY2xlTGVuZ3RoKGVsKSB7XG4gIHJldHVybiBNYXRoLlBJICogMiAqIGdldEF0dHJpYnV0ZShlbCwgJ3InKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdExlbmd0aChlbCkge1xuICByZXR1cm4gKGdldEF0dHJpYnV0ZShlbCwgJ3dpZHRoJykgKiAyKSArIChnZXRBdHRyaWJ1dGUoZWwsICdoZWlnaHQnKSAqIDIpO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGVsKSB7XG4gIHJldHVybiBnZXREaXN0YW5jZShcbiAgICB7eDogZ2V0QXR0cmlidXRlKGVsLCAneDEnKSwgeTogZ2V0QXR0cmlidXRlKGVsLCAneTEnKX0sIFxuICAgIHt4OiBnZXRBdHRyaWJ1dGUoZWwsICd4MicpLCB5OiBnZXRBdHRyaWJ1dGUoZWwsICd5MicpfVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRQb2x5bGluZUxlbmd0aChlbCkge1xuICB2YXIgcG9pbnRzID0gZWwucG9pbnRzO1xuICB2YXIgdG90YWxMZW5ndGggPSAwO1xuICB2YXIgcHJldmlvdXNQb3M7XG4gIGZvciAodmFyIGkgPSAwIDsgaSA8IHBvaW50cy5udW1iZXJPZkl0ZW1zOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFBvcyA9IHBvaW50cy5nZXRJdGVtKGkpO1xuICAgIGlmIChpID4gMCkgeyB0b3RhbExlbmd0aCArPSBnZXREaXN0YW5jZShwcmV2aW91c1BvcywgY3VycmVudFBvcyk7IH1cbiAgICBwcmV2aW91c1BvcyA9IGN1cnJlbnRQb3M7XG4gIH1cbiAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBnZXRQb2x5Z29uTGVuZ3RoKGVsKSB7XG4gIHZhciBwb2ludHMgPSBlbC5wb2ludHM7XG4gIHJldHVybiBnZXRQb2x5bGluZUxlbmd0aChlbCkgKyBnZXREaXN0YW5jZShwb2ludHMuZ2V0SXRlbShwb2ludHMubnVtYmVyT2ZJdGVtcyAtIDEpLCBwb2ludHMuZ2V0SXRlbSgwKSk7XG59XG5cbi8vIFBhdGggYW5pbWF0aW9uXG5cbmZ1bmN0aW9uIGdldFRvdGFsTGVuZ3RoKGVsKSB7XG4gIGlmIChlbC5nZXRUb3RhbExlbmd0aCkgeyByZXR1cm4gZWwuZ2V0VG90YWxMZW5ndGgoKTsgfVxuICBzd2l0Y2goZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnY2lyY2xlJzogcmV0dXJuIGdldENpcmNsZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncmVjdCc6IHJldHVybiBnZXRSZWN0TGVuZ3RoKGVsKTtcbiAgICBjYXNlICdsaW5lJzogcmV0dXJuIGdldExpbmVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3BvbHlsaW5lJzogcmV0dXJuIGdldFBvbHlsaW5lTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdwb2x5Z29uJzogcmV0dXJuIGdldFBvbHlnb25MZW5ndGgoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldERhc2hvZmZzZXQoZWwpIHtcbiAgdmFyIHBhdGhMZW5ndGggPSBnZXRUb3RhbExlbmd0aChlbCk7XG4gIGVsLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIHBhdGhMZW5ndGgpO1xuICByZXR1cm4gcGF0aExlbmd0aDtcbn1cblxuLy8gTW90aW9uIHBhdGhcblxuZnVuY3Rpb24gZ2V0UGFyZW50U3ZnRWwoZWwpIHtcbiAgdmFyIHBhcmVudEVsID0gZWwucGFyZW50Tm9kZTtcbiAgd2hpbGUgKGlzLnN2ZyhwYXJlbnRFbCkpIHtcbiAgICBpZiAoIWlzLnN2ZyhwYXJlbnRFbC5wYXJlbnROb2RlKSkgeyBicmVhazsgfVxuICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gcGFyZW50RWw7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFN2ZyhwYXRoRWwsIHN2Z0RhdGEpIHtcbiAgdmFyIHN2ZyA9IHN2Z0RhdGEgfHwge307XG4gIHZhciBwYXJlbnRTdmdFbCA9IHN2Zy5lbCB8fCBnZXRQYXJlbnRTdmdFbChwYXRoRWwpO1xuICB2YXIgcmVjdCA9IHBhcmVudFN2Z0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgdmlld0JveEF0dHIgPSBnZXRBdHRyaWJ1dGUocGFyZW50U3ZnRWwsICd2aWV3Qm94Jyk7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIHZpZXdCb3ggPSBzdmcudmlld0JveCB8fCAodmlld0JveEF0dHIgPyB2aWV3Qm94QXR0ci5zcGxpdCgnICcpIDogWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcbiAgcmV0dXJuIHtcbiAgICBlbDogcGFyZW50U3ZnRWwsXG4gICAgdmlld0JveDogdmlld0JveCxcbiAgICB4OiB2aWV3Qm94WzBdIC8gMSxcbiAgICB5OiB2aWV3Qm94WzFdIC8gMSxcbiAgICB3OiB3aWR0aCxcbiAgICBoOiBoZWlnaHQsXG4gICAgdlc6IHZpZXdCb3hbMl0sXG4gICAgdkg6IHZpZXdCb3hbM11cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoKHBhdGgsIHBlcmNlbnQpIHtcbiAgdmFyIHBhdGhFbCA9IGlzLnN0cihwYXRoKSA/IHNlbGVjdFN0cmluZyhwYXRoKVswXSA6IHBhdGg7XG4gIHZhciBwID0gcGVyY2VudCB8fCAxMDA7XG4gIHJldHVybiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICBlbDogcGF0aEVsLFxuICAgICAgc3ZnOiBnZXRQYXJlbnRTdmcocGF0aEVsKSxcbiAgICAgIHRvdGFsTGVuZ3RoOiBnZXRUb3RhbExlbmd0aChwYXRoRWwpICogKHAgLyAxMDApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhQcm9ncmVzcyhwYXRoLCBwcm9ncmVzcywgaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHKSB7XG4gIGZ1bmN0aW9uIHBvaW50KG9mZnNldCkge1xuICAgIGlmICggb2Zmc2V0ID09PSB2b2lkIDAgKSBvZmZzZXQgPSAwO1xuXG4gICAgdmFyIGwgPSBwcm9ncmVzcyArIG9mZnNldCA+PSAxID8gcHJvZ3Jlc3MgKyBvZmZzZXQgOiAwO1xuICAgIHJldHVybiBwYXRoLmVsLmdldFBvaW50QXRMZW5ndGgobCk7XG4gIH1cbiAgdmFyIHN2ZyA9IGdldFBhcmVudFN2ZyhwYXRoLmVsLCBwYXRoLnN2Zyk7XG4gIHZhciBwID0gcG9pbnQoKTtcbiAgdmFyIHAwID0gcG9pbnQoLTEpO1xuICB2YXIgcDEgPSBwb2ludCgrMSk7XG4gIHZhciBzY2FsZVggPSBpc1BhdGhUYXJnZXRJbnNpZGVTVkcgPyAxIDogc3ZnLncgLyBzdmcudlc7XG4gIHZhciBzY2FsZVkgPSBpc1BhdGhUYXJnZXRJbnNpZGVTVkcgPyAxIDogc3ZnLmggLyBzdmcudkg7XG4gIHN3aXRjaCAocGF0aC5wcm9wZXJ0eSkge1xuICAgIGNhc2UgJ3gnOiByZXR1cm4gKHAueCAtIHN2Zy54KSAqIHNjYWxlWDtcbiAgICBjYXNlICd5JzogcmV0dXJuIChwLnkgLSBzdmcueSkgKiBzY2FsZVk7XG4gICAgY2FzZSAnYW5nbGUnOiByZXR1cm4gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxufVxuXG4vLyBEZWNvbXBvc2UgdmFsdWVcblxuZnVuY3Rpb24gZGVjb21wb3NlVmFsdWUodmFsLCB1bml0KSB7XG4gIC8vIGNvbnN0IHJneCA9IC8tP1xcZCpcXC4/XFxkKy9nOyAvLyBoYW5kbGVzIGJhc2ljIG51bWJlcnNcbiAgLy8gY29uc3Qgcmd4ID0gL1srLV0/XFxkKyg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPy9nOyAvLyBoYW5kbGVzIGV4cG9uZW50cyBub3RhdGlvblxuICB2YXIgcmd4ID0gL1srLV0/XFxkKlxcLj9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/L2c7IC8vIGhhbmRsZXMgZXhwb25lbnRzIG5vdGF0aW9uXG4gIHZhciB2YWx1ZSA9IHZhbGlkYXRlVmFsdWUoKGlzLnB0aCh2YWwpID8gdmFsLnRvdGFsTGVuZ3RoIDogdmFsKSwgdW5pdCkgKyAnJztcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW5hbDogdmFsdWUsXG4gICAgbnVtYmVyczogdmFsdWUubWF0Y2gocmd4KSA/IHZhbHVlLm1hdGNoKHJneCkubWFwKE51bWJlcikgOiBbMF0sXG4gICAgc3RyaW5nczogKGlzLnN0cih2YWwpIHx8IHVuaXQpID8gdmFsdWUuc3BsaXQocmd4KSA6IFtdXG4gIH1cbn1cblxuLy8gQW5pbWF0YWJsZXNcblxuZnVuY3Rpb24gcGFyc2VUYXJnZXRzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldHNBcnJheSA9IHRhcmdldHMgPyAoZmxhdHRlbkFycmF5KGlzLmFycih0YXJnZXRzKSA/IHRhcmdldHMubWFwKHRvQXJyYXkpIDogdG9BcnJheSh0YXJnZXRzKSkpIDogW107XG4gIHJldHVybiBmaWx0ZXJBcnJheSh0YXJnZXRzQXJyYXksIGZ1bmN0aW9uIChpdGVtLCBwb3MsIHNlbGYpIHsgcmV0dXJuIHNlbGYuaW5kZXhPZihpdGVtKSA9PT0gcG9zOyB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZXModGFyZ2V0cykge1xuICB2YXIgcGFyc2VkID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICByZXR1cm4gcGFyc2VkLm1hcChmdW5jdGlvbiAodCwgaSkge1xuICAgIHJldHVybiB7dGFyZ2V0OiB0LCBpZDogaSwgdG90YWw6IHBhcnNlZC5sZW5ndGgsIHRyYW5zZm9ybXM6IHsgbGlzdDogZ2V0RWxlbWVudFRyYW5zZm9ybXModCkgfSB9O1xuICB9KTtcbn1cblxuLy8gUHJvcGVydGllc1xuXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwcm9wLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBzZXR0aW5ncyA9IGNsb25lT2JqZWN0KHR3ZWVuU2V0dGluZ3MpO1xuICAvLyBPdmVycmlkZSBkdXJhdGlvbiBpZiBlYXNpbmcgaXMgYSBzcHJpbmdcbiAgaWYgKC9ec3ByaW5nLy50ZXN0KHNldHRpbmdzLmVhc2luZykpIHsgc2V0dGluZ3MuZHVyYXRpb24gPSBzcHJpbmcoc2V0dGluZ3MuZWFzaW5nKTsgfVxuICBpZiAoaXMuYXJyKHByb3ApKSB7XG4gICAgdmFyIGwgPSBwcm9wLmxlbmd0aDtcbiAgICB2YXIgaXNGcm9tVG8gPSAobCA9PT0gMiAmJiAhaXMub2JqKHByb3BbMF0pKTtcbiAgICBpZiAoIWlzRnJvbVRvKSB7XG4gICAgICAvLyBEdXJhdGlvbiBkaXZpZGVkIGJ5IHRoZSBudW1iZXIgb2YgdHdlZW5zXG4gICAgICBpZiAoIWlzLmZuYyh0d2VlblNldHRpbmdzLmR1cmF0aW9uKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24gLyBsOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYW5zZm9ybSBbZnJvbSwgdG9dIHZhbHVlcyBzaG9ydGhhbmQgdG8gYSB2YWxpZCB0d2VlbiB2YWx1ZVxuICAgICAgcHJvcCA9IHt2YWx1ZTogcHJvcH07XG4gICAgfVxuICB9XG4gIHZhciBwcm9wQXJyYXkgPSBpcy5hcnIocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xuICByZXR1cm4gcHJvcEFycmF5Lm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgIHZhciBvYmogPSAoaXMub2JqKHYpICYmICFpcy5wdGgodikpID8gdiA6IHt2YWx1ZTogdn07XG4gICAgLy8gRGVmYXVsdCBkZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBmaXJzdCB0d2VlblxuICAgIGlmIChpcy51bmQob2JqLmRlbGF5KSkgeyBvYmouZGVsYXkgPSAhaSA/IHR3ZWVuU2V0dGluZ3MuZGVsYXkgOiAwOyB9XG4gICAgLy8gRGVmYXVsdCBlbmREZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBsYXN0IHR3ZWVuXG4gICAgaWYgKGlzLnVuZChvYmouZW5kRGVsYXkpKSB7IG9iai5lbmREZWxheSA9IGkgPT09IHByb3BBcnJheS5sZW5ndGggLSAxID8gdHdlZW5TZXR0aW5ncy5lbmREZWxheSA6IDA7IH1cbiAgICByZXR1cm4gb2JqO1xuICB9KS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIG1lcmdlT2JqZWN0cyhrLCBzZXR0aW5ncyk7IH0pO1xufVxuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5LZXlmcmFtZXMoa2V5ZnJhbWVzKSB7XG4gIHZhciBwcm9wZXJ0eU5hbWVzID0gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gT2JqZWN0LmtleXMoa2V5KTsgfSkpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gaXMua2V5KHApOyB9KVxuICAucmVkdWNlKGZ1bmN0aW9uIChhLGIpIHsgaWYgKGEuaW5kZXhPZihiKSA8IDApIHsgYS5wdXNoKGIpOyB9IHJldHVybiBhOyB9LCBbXSk7XG4gIHZhciBwcm9wZXJ0aWVzID0ge307XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5TmFtZXNbaV07XG4gICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBrZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBuZXdLZXkgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4ga2V5KSB7XG4gICAgICAgIGlmIChpcy5rZXkocCkpIHtcbiAgICAgICAgICBpZiAocCA9PSBwcm9wTmFtZSkgeyBuZXdLZXkudmFsdWUgPSBrZXlbcF07IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdLZXlbcF0gPSBrZXlbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKHR3ZWVuU2V0dGluZ3MsIHBhcmFtcykge1xuICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICB2YXIga2V5ZnJhbWVzID0gcGFyYW1zLmtleWZyYW1lcztcbiAgaWYgKGtleWZyYW1lcykgeyBwYXJhbXMgPSBtZXJnZU9iamVjdHMoZmxhdHRlbktleWZyYW1lcyhrZXlmcmFtZXMpLCBwYXJhbXMpOyB9XG4gIGZvciAodmFyIHAgaW4gcGFyYW1zKSB7XG4gICAgaWYgKGlzLmtleShwKSkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogcCxcbiAgICAgICAgdHdlZW5zOiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwYXJhbXNbcF0sIHR3ZWVuU2V0dGluZ3MpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbi8vIFR3ZWVuc1xuXG5mdW5jdGlvbiBub3JtYWxpemVUd2VlblZhbHVlcyh0d2VlbiwgYW5pbWF0YWJsZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHR3ZWVuKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZSh0d2VlbltwXSwgYW5pbWF0YWJsZSk7XG4gICAgaWYgKGlzLmFycih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBnZXRGdW5jdGlvblZhbHVlKHYsIGFuaW1hdGFibGUpOyB9KTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHsgdmFsdWUgPSB2YWx1ZVswXTsgfVxuICAgIH1cbiAgICB0W3BdID0gdmFsdWU7XG4gIH1cbiAgdC5kdXJhdGlvbiA9IHBhcnNlRmxvYXQodC5kdXJhdGlvbik7XG4gIHQuZGVsYXkgPSBwYXJzZUZsb2F0KHQuZGVsYXkpO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVHdlZW5zKHByb3AsIGFuaW1hdGFibGUpIHtcbiAgdmFyIHByZXZpb3VzVHdlZW47XG4gIHJldHVybiBwcm9wLnR3ZWVucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgdHdlZW4gPSBub3JtYWxpemVUd2VlblZhbHVlcyh0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgdHdlZW5WYWx1ZSA9IHR3ZWVuLnZhbHVlO1xuICAgIHZhciB0byA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMV0gOiB0d2VlblZhbHVlO1xuICAgIHZhciB0b1VuaXQgPSBnZXRVbml0KHRvKTtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSwgdG9Vbml0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVHdlZW4gPyBwcmV2aW91c1R3ZWVuLnRvLm9yaWdpbmFsIDogb3JpZ2luYWxWYWx1ZTtcbiAgICB2YXIgZnJvbSA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMF0gOiBwcmV2aW91c1ZhbHVlO1xuICAgIHZhciBmcm9tVW5pdCA9IGdldFVuaXQoZnJvbSkgfHwgZ2V0VW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICB2YXIgdW5pdCA9IHRvVW5pdCB8fCBmcm9tVW5pdDtcbiAgICBpZiAoaXMudW5kKHRvKSkgeyB0byA9IHByZXZpb3VzVmFsdWU7IH1cbiAgICB0d2Vlbi5mcm9tID0gZGVjb21wb3NlVmFsdWUoZnJvbSwgdW5pdCk7XG4gICAgdHdlZW4udG8gPSBkZWNvbXBvc2VWYWx1ZShnZXRSZWxhdGl2ZVZhbHVlKHRvLCBmcm9tKSwgdW5pdCk7XG4gICAgdHdlZW4uc3RhcnQgPSBwcmV2aW91c1R3ZWVuID8gcHJldmlvdXNUd2Vlbi5lbmQgOiAwO1xuICAgIHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0ICsgdHdlZW4uZGVsYXkgKyB0d2Vlbi5kdXJhdGlvbiArIHR3ZWVuLmVuZERlbGF5O1xuICAgIHR3ZWVuLmVhc2luZyA9IHBhcnNlRWFzaW5ncyh0d2Vlbi5lYXNpbmcsIHR3ZWVuLmR1cmF0aW9uKTtcbiAgICB0d2Vlbi5pc1BhdGggPSBpcy5wdGgodHdlZW5WYWx1ZSk7XG4gICAgdHdlZW4uaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHID0gdHdlZW4uaXNQYXRoICYmIGlzLnN2ZyhhbmltYXRhYmxlLnRhcmdldCk7XG4gICAgdHdlZW4uaXNDb2xvciA9IGlzLmNvbCh0d2Vlbi5mcm9tLm9yaWdpbmFsKTtcbiAgICBpZiAodHdlZW4uaXNDb2xvcikgeyB0d2Vlbi5yb3VuZCA9IDE7IH1cbiAgICBwcmV2aW91c1R3ZWVuID0gdHdlZW47XG4gICAgcmV0dXJuIHR3ZWVuO1xuICB9KTtcbn1cblxuLy8gVHdlZW4gcHJvZ3Jlc3NcblxudmFyIHNldFByb2dyZXNzVmFsdWUgPSB7XG4gIGNzczogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHQuc3R5bGVbcF0gPSB2OyB9LFxuICBhdHRyaWJ1dGU6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0LnNldEF0dHJpYnV0ZShwLCB2KTsgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdFtwXSA9IHY7IH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKHQsIHAsIHYsIHRyYW5zZm9ybXMsIG1hbnVhbCkge1xuICAgIHRyYW5zZm9ybXMubGlzdC5zZXQocCwgdik7XG4gICAgaWYgKHAgPT09IHRyYW5zZm9ybXMubGFzdCB8fCBtYW51YWwpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIHRyYW5zZm9ybXMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcHJvcCkgeyBzdHIgKz0gcHJvcCArIFwiKFwiICsgdmFsdWUgKyBcIikgXCI7IH0pO1xuICAgICAgdC5zdHlsZS50cmFuc2Zvcm0gPSBzdHI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBTZXQgVmFsdWUgaGVscGVyXG5cbmZ1bmN0aW9uIHNldFRhcmdldHNWYWx1ZSh0YXJnZXRzLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBhbmltYXRhYmxlcyA9IGdldEFuaW1hdGFibGVzKHRhcmdldHMpO1xuICBhbmltYXRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZShwcm9wZXJ0aWVzW3Byb3BlcnR5XSwgYW5pbWF0YWJsZSk7XG4gICAgICB2YXIgdGFyZ2V0ID0gYW5pbWF0YWJsZS50YXJnZXQ7XG4gICAgICB2YXIgdmFsdWVVbml0ID0gZ2V0VW5pdCh2YWx1ZSk7XG4gICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWVVbml0LCBhbmltYXRhYmxlKTtcbiAgICAgIHZhciB1bml0ID0gdmFsdWVVbml0IHx8IGdldFVuaXQob3JpZ2luYWxWYWx1ZSk7XG4gICAgICB2YXIgdG8gPSBnZXRSZWxhdGl2ZVZhbHVlKHZhbGlkYXRlVmFsdWUodmFsdWUsIHVuaXQpLCBvcmlnaW5hbFZhbHVlKTtcbiAgICAgIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBzZXRQcm9ncmVzc1ZhbHVlW2FuaW1UeXBlXSh0YXJnZXQsIHByb3BlcnR5LCB0bywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBBbmltYXRpb25zXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKSB7XG4gIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSk7XG4gIGlmIChhbmltVHlwZSkge1xuICAgIHZhciB0d2VlbnMgPSBub3JtYWxpemVUd2VlbnMocHJvcCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIGxhc3RUd2VlbiA9IHR3ZWVuc1t0d2VlbnMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFuaW1UeXBlLFxuICAgICAgcHJvcGVydHk6IHByb3AubmFtZSxcbiAgICAgIGFuaW1hdGFibGU6IGFuaW1hdGFibGUsXG4gICAgICB0d2VlbnM6IHR3ZWVucyxcbiAgICAgIGR1cmF0aW9uOiBsYXN0VHdlZW4uZW5kLFxuICAgICAgZGVsYXk6IHR3ZWVuc1swXS5kZWxheSxcbiAgICAgIGVuZERlbGF5OiBsYXN0VHdlZW4uZW5kRGVsYXlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcykge1xuICByZXR1cm4gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGFuaW1hdGFibGVzLm1hcChmdW5jdGlvbiAoYW5pbWF0YWJsZSkge1xuICAgIHJldHVybiBwcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKTtcbiAgICB9KTtcbiAgfSkpLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIWlzLnVuZChhKTsgfSk7XG59XG5cbi8vIENyZWF0ZSBJbnN0YW5jZVxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZVRpbWluZ3MoYW5pbWF0aW9ucywgdHdlZW5TZXR0aW5ncykge1xuICB2YXIgYW5pbUxlbmd0aCA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuICB2YXIgZ2V0VGxPZmZzZXQgPSBmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gYW5pbS50aW1lbGluZU9mZnNldCA/IGFuaW0udGltZWxpbmVPZmZzZXQgOiAwOyB9O1xuICB2YXIgdGltaW5ncyA9IHt9O1xuICB0aW1pbmdzLmR1cmF0aW9uID0gYW5pbUxlbmd0aCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBnZXRUbE9mZnNldChhbmltKSArIGFuaW0uZHVyYXRpb247IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb247XG4gIHRpbWluZ3MuZGVsYXkgPSBhbmltTGVuZ3RoID8gTWF0aC5taW4uYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kZWxheTsgfSkpIDogdHdlZW5TZXR0aW5ncy5kZWxheTtcbiAgdGltaW5ncy5lbmREZWxheSA9IGFuaW1MZW5ndGggPyB0aW1pbmdzLmR1cmF0aW9uIC0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kdXJhdGlvbiAtIGFuaW0uZW5kRGVsYXk7IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZW5kRGVsYXk7XG4gIHJldHVybiB0aW1pbmdzO1xufVxuXG52YXIgaW5zdGFuY2VJRCA9IDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcykge1xuICB2YXIgaW5zdGFuY2VTZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHR3ZWVuU2V0dGluZ3MgPSByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdFR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gZ2V0UHJvcGVydGllcyh0d2VlblNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgYW5pbWF0YWJsZXMgPSBnZXRBbmltYXRhYmxlcyhwYXJhbXMudGFyZ2V0cyk7XG4gIHZhciBhbmltYXRpb25zID0gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcyk7XG4gIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGFuaW1hdGlvbnMsIHR3ZWVuU2V0dGluZ3MpO1xuICB2YXIgaWQgPSBpbnN0YW5jZUlEO1xuICBpbnN0YW5jZUlEKys7XG4gIHJldHVybiBtZXJnZU9iamVjdHMoaW5zdGFuY2VTZXR0aW5ncywge1xuICAgIGlkOiBpZCxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgYW5pbWF0YWJsZXM6IGFuaW1hdGFibGVzLFxuICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgZHVyYXRpb246IHRpbWluZ3MuZHVyYXRpb24sXG4gICAgZGVsYXk6IHRpbWluZ3MuZGVsYXksXG4gICAgZW5kRGVsYXk6IHRpbWluZ3MuZW5kRGVsYXlcbiAgfSk7XG59XG5cbi8vIENvcmVcblxudmFyIGFjdGl2ZUluc3RhbmNlcyA9IFtdO1xuXG52YXIgZW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhZjtcblxuICBmdW5jdGlvbiBwbGF5KCkge1xuICAgIGlmICghcmFmICYmICghaXNEb2N1bWVudEhpZGRlbigpIHx8ICFhbmltZS5zdXNwZW5kV2hlbkRvY3VtZW50SGlkZGVuKSAmJiBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdGVwKHQpIHtcbiAgICAvLyBtZW1vIG9uIGFsZ29yaXRobSBpc3N1ZTpcbiAgICAvLyBkYW5nZXJvdXMgaXRlcmF0aW9uIG92ZXIgbXV0YWJsZSBgYWN0aXZlSW5zdGFuY2VzYFxuICAgIC8vICh0aGF0IGNvbGxlY3Rpb24gbWF5IGJlIHVwZGF0ZWQgZnJvbSB3aXRoaW4gY2FsbGJhY2tzIG9mIGB0aWNrYC1lZCBhbmltYXRpb24gaW5zdGFuY2VzKVxuICAgIHZhciBhY3RpdmVJbnN0YW5jZXNMZW5ndGggPSBhY3RpdmVJbnN0YW5jZXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFjdGl2ZUluc3RhbmNlc0xlbmd0aCkge1xuICAgICAgdmFyIGFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2VzW2ldO1xuICAgICAgaWYgKCFhY3RpdmVJbnN0YW5jZS5wYXVzZWQpIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UudGljayh0KTtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJhZiA9IGkgPiAwID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoIWFuaW1lLnN1c3BlbmRXaGVuRG9jdW1lbnRIaWRkZW4pIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoaXNEb2N1bWVudEhpZGRlbigpKSB7XG4gICAgICAvLyBzdXNwZW5kIHRpY2tzXG4gICAgICByYWYgPSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgIH0gZWxzZSB7IC8vIGlzIGJhY2sgdG8gYWN0aXZlIHRhYlxuICAgICAgLy8gZmlyc3QgYWRqdXN0IGFuaW1hdGlvbnMgdG8gY29uc2lkZXIgdGhlIHRpbWUgdGhhdCB0aWNrcyB3ZXJlIHN1c3BlbmRlZFxuICAgICAgYWN0aXZlSW5zdGFuY2VzLmZvckVhY2goXG4gICAgICAgIGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UgLl9vbkRvY3VtZW50VmlzaWJpbGl0eSgpOyB9XG4gICAgICApO1xuICAgICAgZW5naW5lKCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICB9XG5cbiAgcmV0dXJuIHBsYXk7XG59KSgpO1xuXG5mdW5jdGlvbiBpc0RvY3VtZW50SGlkZGVuKCkge1xuICByZXR1cm4gISFkb2N1bWVudCAmJiBkb2N1bWVudC5oaWRkZW47XG59XG5cbi8vIFB1YmxpYyBJbnN0YW5jZVxuXG5mdW5jdGlvbiBhbmltZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG5cbiAgdmFyIHN0YXJ0VGltZSA9IDAsIGxhc3RUaW1lID0gMCwgbm93ID0gMDtcbiAgdmFyIGNoaWxkcmVuLCBjaGlsZHJlbkxlbmd0aCA9IDA7XG4gIHZhciByZXNvbHZlID0gbnVsbDtcblxuICBmdW5jdGlvbiBtYWtlUHJvbWlzZShpbnN0YW5jZSkge1xuICAgIHZhciBwcm9taXNlID0gd2luZG93LlByb21pc2UgJiYgbmV3IFByb21pc2UoZnVuY3Rpb24gKF9yZXNvbHZlKSB7IHJldHVybiByZXNvbHZlID0gX3Jlc29sdmU7IH0pO1xuICAgIGluc3RhbmNlLmZpbmlzaGVkID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcyk7XG4gIHZhciBwcm9taXNlID0gbWFrZVByb21pc2UoaW5zdGFuY2UpO1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnN0YW5jZS5kaXJlY3Rpb247XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgIGluc3RhbmNlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbiAhPT0gJ25vcm1hbCcgPyAnbm9ybWFsJyA6ICdyZXZlcnNlJztcbiAgICB9XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSAhaW5zdGFuY2UucmV2ZXJzZWQ7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnJldmVyc2VkID0gaW5zdGFuY2UucmV2ZXJzZWQ7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRqdXN0VGltZSh0aW1lKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gLSB0aW1lIDogdGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VGltZSgpIHtcbiAgICBzdGFydFRpbWUgPSAwO1xuICAgIGxhc3RUaW1lID0gYWRqdXN0VGltZShpbnN0YW5jZS5jdXJyZW50VGltZSkgKiAoMSAvIGFuaW1lLnNwZWVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlZWtDaGlsZCh0aW1lLCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCkgeyBjaGlsZC5zZWVrKHRpbWUgLSBjaGlsZC50aW1lbGluZU9mZnNldCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmNJbnN0YW5jZUNoaWxkcmVuKHRpbWUpIHtcbiAgICBpZiAoIWluc3RhbmNlLnJldmVyc2VQbGF5YmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7IHNlZWtDaGlsZCh0aW1lLCBjaGlsZHJlbltpXSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSQxID0gY2hpbGRyZW5MZW5ndGg7IGkkMS0tOykgeyBzZWVrQ2hpbGQodGltZSwgY2hpbGRyZW5baSQxXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zVGltZSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gICAgdmFyIGFuaW1hdGlvbnNMZW5ndGggPSBhbmltYXRpb25zLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGFuaW1hdGlvbnNMZW5ndGgpIHtcbiAgICAgIHZhciBhbmltID0gYW5pbWF0aW9uc1tpXTtcbiAgICAgIHZhciBhbmltYXRhYmxlID0gYW5pbS5hbmltYXRhYmxlO1xuICAgICAgdmFyIHR3ZWVucyA9IGFuaW0udHdlZW5zO1xuICAgICAgdmFyIHR3ZWVuTGVuZ3RoID0gdHdlZW5zLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgdHdlZW4gPSB0d2VlbnNbdHdlZW5MZW5ndGhdO1xuICAgICAgLy8gT25seSBjaGVjayBmb3Iga2V5ZnJhbWVzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgdHdlZW5cbiAgICAgIGlmICh0d2Vlbkxlbmd0aCkgeyB0d2VlbiA9IGZpbHRlckFycmF5KHR3ZWVucywgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChpbnNUaW1lIDwgdC5lbmQpOyB9KVswXSB8fCB0d2VlbjsgfVxuICAgICAgdmFyIGVsYXBzZWQgPSBtaW5NYXgoaW5zVGltZSAtIHR3ZWVuLnN0YXJ0IC0gdHdlZW4uZGVsYXksIDAsIHR3ZWVuLmR1cmF0aW9uKSAvIHR3ZWVuLmR1cmF0aW9uO1xuICAgICAgdmFyIGVhc2VkID0gaXNOYU4oZWxhcHNlZCkgPyAxIDogdHdlZW4uZWFzaW5nKGVsYXBzZWQpO1xuICAgICAgdmFyIHN0cmluZ3MgPSB0d2Vlbi50by5zdHJpbmdzO1xuICAgICAgdmFyIHJvdW5kID0gdHdlZW4ucm91bmQ7XG4gICAgICB2YXIgbnVtYmVycyA9IFtdO1xuICAgICAgdmFyIHRvTnVtYmVyc0xlbmd0aCA9IHR3ZWVuLnRvLm51bWJlcnMubGVuZ3RoO1xuICAgICAgdmFyIHByb2dyZXNzID0gKHZvaWQgMCk7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRvTnVtYmVyc0xlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgdG9OdW1iZXIgPSB0d2Vlbi50by5udW1iZXJzW25dO1xuICAgICAgICB2YXIgZnJvbU51bWJlciA9IHR3ZWVuLmZyb20ubnVtYmVyc1tuXSB8fCAwO1xuICAgICAgICBpZiAoIXR3ZWVuLmlzUGF0aCkge1xuICAgICAgICAgIHZhbHVlID0gZnJvbU51bWJlciArIChlYXNlZCAqICh0b051bWJlciAtIGZyb21OdW1iZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldFBhdGhQcm9ncmVzcyh0d2Vlbi52YWx1ZSwgZWFzZWQgKiB0b051bWJlciwgdHdlZW4uaXNQYXRoVGFyZ2V0SW5zaWRlU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICBpZiAoISh0d2Vlbi5pc0NvbG9yICYmIG4gPiAyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogcm91bmQpIC8gcm91bmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBNYW51YWwgQXJyYXkucmVkdWNlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VzXG4gICAgICB2YXIgc3RyaW5nc0xlbmd0aCA9IHN0cmluZ3MubGVuZ3RoO1xuICAgICAgaWYgKCFzdHJpbmdzTGVuZ3RoKSB7XG4gICAgICAgIHByb2dyZXNzID0gbnVtYmVyc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyZXNzID0gc3RyaW5nc1swXTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdHJpbmdzTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICB2YXIgYSA9IHN0cmluZ3Nbc107XG4gICAgICAgICAgdmFyIGIgPSBzdHJpbmdzW3MgKyAxXTtcbiAgICAgICAgICB2YXIgbiQxID0gbnVtYmVyc1tzXTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG4kMSkpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyAnICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0UHJvZ3Jlc3NWYWx1ZVthbmltLnR5cGVdKGFuaW1hdGFibGUudGFyZ2V0LCBhbmltLnByb3BlcnR5LCBwcm9ncmVzcywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zKTtcbiAgICAgIGFuaW0uY3VycmVudFZhbHVlID0gcHJvZ3Jlc3M7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FsbGJhY2soY2IpIHtcbiAgICBpZiAoaW5zdGFuY2VbY2JdICYmICFpbnN0YW5jZS5wYXNzVGhyb3VnaCkgeyBpbnN0YW5jZVtjYl0oaW5zdGFuY2UpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudEl0ZXJhdGlvbigpIHtcbiAgICBpZiAoaW5zdGFuY2UucmVtYWluaW5nICYmIGluc3RhbmNlLnJlbWFpbmluZyAhPT0gdHJ1ZSkge1xuICAgICAgaW5zdGFuY2UucmVtYWluaW5nLS07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW5zdGFuY2VQcm9ncmVzcyhlbmdpbmVUaW1lKSB7XG4gICAgdmFyIGluc0R1cmF0aW9uID0gaW5zdGFuY2UuZHVyYXRpb247XG4gICAgdmFyIGluc0RlbGF5ID0gaW5zdGFuY2UuZGVsYXk7XG4gICAgdmFyIGluc0VuZERlbGF5ID0gaW5zRHVyYXRpb24gLSBpbnN0YW5jZS5lbmREZWxheTtcbiAgICB2YXIgaW5zVGltZSA9IGFkanVzdFRpbWUoZW5naW5lVGltZSk7XG4gICAgaW5zdGFuY2UucHJvZ3Jlc3MgPSBtaW5NYXgoKGluc1RpbWUgLyBpbnNEdXJhdGlvbikgKiAxMDAsIDAsIDEwMCk7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gaW5zVGltZSA8IGluc3RhbmNlLmN1cnJlbnRUaW1lO1xuICAgIGlmIChjaGlsZHJlbikgeyBzeW5jSW5zdGFuY2VDaGlsZHJlbihpbnNUaW1lKTsgfVxuICAgIGlmICghaW5zdGFuY2UuYmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5iZWdhbiA9IHRydWU7XG4gICAgICBzZXRDYWxsYmFjaygnYmVnaW4nKTtcbiAgICB9XG4gICAgaWYgKCFpbnN0YW5jZS5sb29wQmVnYW4gJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSB0cnVlO1xuICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BCZWdpbicpO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA8PSBpbnNEZWxheSAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSAhPT0gMCkge1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKDApO1xuICAgIH1cbiAgICBpZiAoKGluc1RpbWUgPj0gaW5zRW5kRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IGluc0R1cmF0aW9uKSB8fCAhaW5zRHVyYXRpb24pIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNEdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChpbnNUaW1lID4gaW5zRGVsYXkgJiYgaW5zVGltZSA8IGluc0VuZERlbGF5KSB7XG4gICAgICBpZiAoIWluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VCZWdpbicpO1xuICAgICAgfVxuICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZScpO1xuICAgICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zdGFuY2UuY2hhbmdlQmVnYW4pIHtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2NoYW5nZUNvbXBsZXRlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gbWluTWF4KGluc1RpbWUsIDAsIGluc0R1cmF0aW9uKTtcbiAgICBpZiAoaW5zdGFuY2UuYmVnYW4pIHsgc2V0Q2FsbGJhY2soJ3VwZGF0ZScpOyB9XG4gICAgaWYgKGVuZ2luZVRpbWUgPj0gaW5zRHVyYXRpb24pIHtcbiAgICAgIGxhc3RUaW1lID0gMDtcbiAgICAgIGNvdW50SXRlcmF0aW9uKCk7XG4gICAgICBpZiAoIWluc3RhbmNlLnJlbWFpbmluZykge1xuICAgICAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWluc3RhbmNlLmNvbXBsZXRlZCkge1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICAgIHNldENhbGxiYWNrKCdjb21wbGV0ZScpO1xuICAgICAgICAgIGlmICghaW5zdGFuY2UucGFzc1Rocm91Z2ggJiYgJ1Byb21pc2UnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgc2V0Q2FsbGJhY2soJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICBpbnN0YW5jZS5sb29wQmVnYW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmRpcmVjdGlvbiA9PT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgICAgICB0b2dnbGVJbnN0YW5jZURpcmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5zdGFuY2UucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5zdGFuY2UuZGlyZWN0aW9uO1xuICAgIGluc3RhbmNlLnBhc3NUaHJvdWdoID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY3VycmVudFRpbWUgPSAwO1xuICAgIGluc3RhbmNlLnByb2dyZXNzID0gMDtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIGluc3RhbmNlLmJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQmVnYW4gPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jaGFuZ2VDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlZCA9IGRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnO1xuICAgIGluc3RhbmNlLnJlbWFpbmluZyA9IGluc3RhbmNlLmxvb3A7XG4gICAgY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbjtcbiAgICBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gY2hpbGRyZW5MZW5ndGg7IGktLTspIHsgaW5zdGFuY2UuY2hpbGRyZW5baV0ucmVzZXQoKTsgfVxuICAgIGlmIChpbnN0YW5jZS5yZXZlcnNlZCAmJiBpbnN0YW5jZS5sb29wICE9PSB0cnVlIHx8IChkaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnICYmIGluc3RhbmNlLmxvb3AgPT09IDEpKSB7IGluc3RhbmNlLnJlbWFpbmluZysrOyB9XG4gICAgc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gOiAwKTtcbiAgfTtcblxuICAvLyBpbnRlcm5hbCBtZXRob2QgKGZvciBlbmdpbmUpIHRvIGFkanVzdCBhbmltYXRpb24gdGltaW5ncyBiZWZvcmUgcmVzdG9yaW5nIGVuZ2luZSB0aWNrcyAockFGKVxuICBpbnN0YW5jZS5fb25Eb2N1bWVudFZpc2liaWxpdHkgPSByZXNldFRpbWU7XG5cbiAgLy8gU2V0IFZhbHVlIGhlbHBlclxuXG4gIGluc3RhbmNlLnNldCA9IGZ1bmN0aW9uKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgICBzZXRUYXJnZXRzVmFsdWUodGFyZ2V0cywgcHJvcGVydGllcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGluc3RhbmNlLnRpY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgbm93ID0gdDtcbiAgICBpZiAoIXN0YXJ0VGltZSkgeyBzdGFydFRpbWUgPSBub3c7IH1cbiAgICBzZXRJbnN0YW5jZVByb2dyZXNzKChub3cgKyAobGFzdFRpbWUgLSBzdGFydFRpbWUpKSAqIGFuaW1lLnNwZWVkKTtcbiAgfTtcblxuICBpbnN0YW5jZS5zZWVrID0gZnVuY3Rpb24odGltZSkge1xuICAgIHNldEluc3RhbmNlUHJvZ3Jlc3MoYWRqdXN0VGltZSh0aW1lKSk7XG4gIH07XG5cbiAgaW5zdGFuY2UucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWluc3RhbmNlLnBhdXNlZCkgeyByZXR1cm47IH1cbiAgICBpZiAoaW5zdGFuY2UuY29tcGxldGVkKSB7IGluc3RhbmNlLnJlc2V0KCk7IH1cbiAgICBpbnN0YW5jZS5wYXVzZWQgPSBmYWxzZTtcbiAgICBhY3RpdmVJbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgcmVzZXRUaW1lKCk7XG4gICAgZW5naW5lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCk7XG4gICAgaW5zdGFuY2UuY29tcGxldGVkID0gaW5zdGFuY2UucmV2ZXJzZWQgPyBmYWxzZSA6IHRydWU7XG4gICAgcmVzZXRUaW1lKCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGluc3RhbmNlLnJlc2V0KCk7XG4gICAgaW5zdGFuY2UucGxheSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnJlbW92ZSA9IGZ1bmN0aW9uKHRhcmdldHMpIHtcbiAgICB2YXIgdGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICAgIHJlbW92ZVRhcmdldHNGcm9tSW5zdGFuY2UodGFyZ2V0c0FycmF5LCBpbnN0YW5jZSk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmVzZXQoKTtcblxuICBpZiAoaW5zdGFuY2UuYXV0b3BsYXkpIHsgaW5zdGFuY2UucGxheSgpOyB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xuXG59XG5cbi8vIFJlbW92ZSB0YXJnZXRzIGZyb20gYW5pbWF0aW9uXG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnMpIHtcbiAgZm9yICh2YXIgYSA9IGFuaW1hdGlvbnMubGVuZ3RoOyBhLS07KSB7XG4gICAgaWYgKGFycmF5Q29udGFpbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zW2FdLmFuaW1hdGFibGUudGFyZ2V0KSkge1xuICAgICAgYW5pbWF0aW9ucy5zcGxpY2UoYSwgMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHNGcm9tSW5zdGFuY2UodGFyZ2V0c0FycmF5LCBpbnN0YW5jZSkge1xuICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gIHZhciBjaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuO1xuICByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zKTtcbiAgZm9yICh2YXIgYyA9IGNoaWxkcmVuLmxlbmd0aDsgYy0tOykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2NdO1xuICAgIHZhciBjaGlsZEFuaW1hdGlvbnMgPSBjaGlsZC5hbmltYXRpb25zO1xuICAgIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGNoaWxkQW5pbWF0aW9ucyk7XG4gICAgaWYgKCFjaGlsZEFuaW1hdGlvbnMubGVuZ3RoICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHsgY2hpbGRyZW4uc3BsaWNlKGMsIDEpOyB9XG4gIH1cbiAgaWYgKCFhbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGRyZW4ubGVuZ3RoKSB7IGluc3RhbmNlLnBhdXNlKCk7IH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0c0Zyb21BY3RpdmVJbnN0YW5jZXModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICBmb3IgKHZhciBpID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDsgaS0tOykge1xuICAgIHZhciBpbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICByZW1vdmVUYXJnZXRzRnJvbUluc3RhbmNlKHRhcmdldHNBcnJheSwgaW5zdGFuY2UpO1xuICB9XG59XG5cbi8vIFN0YWdnZXIgaGVscGVyc1xuXG5mdW5jdGlvbiBzdGFnZ2VyKHZhbCwgcGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgZGlyZWN0aW9uID0gcGFyYW1zLmRpcmVjdGlvbiB8fCAnbm9ybWFsJztcbiAgdmFyIGVhc2luZyA9IHBhcmFtcy5lYXNpbmcgPyBwYXJzZUVhc2luZ3MocGFyYW1zLmVhc2luZykgOiBudWxsO1xuICB2YXIgZ3JpZCA9IHBhcmFtcy5ncmlkO1xuICB2YXIgYXhpcyA9IHBhcmFtcy5heGlzO1xuICB2YXIgZnJvbUluZGV4ID0gcGFyYW1zLmZyb20gfHwgMDtcbiAgdmFyIGZyb21GaXJzdCA9IGZyb21JbmRleCA9PT0gJ2ZpcnN0JztcbiAgdmFyIGZyb21DZW50ZXIgPSBmcm9tSW5kZXggPT09ICdjZW50ZXInO1xuICB2YXIgZnJvbUxhc3QgPSBmcm9tSW5kZXggPT09ICdsYXN0JztcbiAgdmFyIGlzUmFuZ2UgPSBpcy5hcnIodmFsKTtcbiAgdmFyIHZhbDEgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMF0pIDogcGFyc2VGbG9hdCh2YWwpO1xuICB2YXIgdmFsMiA9IGlzUmFuZ2UgPyBwYXJzZUZsb2F0KHZhbFsxXSkgOiAwO1xuICB2YXIgdW5pdCA9IGdldFVuaXQoaXNSYW5nZSA/IHZhbFsxXSA6IHZhbCkgfHwgMDtcbiAgdmFyIHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDAgKyAoaXNSYW5nZSA/IHZhbDEgOiAwKTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgbWF4VmFsdWUgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCBpLCB0KSB7XG4gICAgaWYgKGZyb21GaXJzdCkgeyBmcm9tSW5kZXggPSAwOyB9XG4gICAgaWYgKGZyb21DZW50ZXIpIHsgZnJvbUluZGV4ID0gKHQgLSAxKSAvIDI7IH1cbiAgICBpZiAoZnJvbUxhc3QpIHsgZnJvbUluZGV4ID0gdCAtIDE7IH1cbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0OyBpbmRleCsrKSB7XG4gICAgICAgIGlmICghZ3JpZCkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKE1hdGguYWJzKGZyb21JbmRleCAtIGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb21YID0gIWZyb21DZW50ZXIgPyBmcm9tSW5kZXglZ3JpZFswXSA6IChncmlkWzBdLTEpLzI7XG4gICAgICAgICAgdmFyIGZyb21ZID0gIWZyb21DZW50ZXIgPyBNYXRoLmZsb29yKGZyb21JbmRleC9ncmlkWzBdKSA6IChncmlkWzFdLTEpLzI7XG4gICAgICAgICAgdmFyIHRvWCA9IGluZGV4JWdyaWRbMF07XG4gICAgICAgICAgdmFyIHRvWSA9IE1hdGguZmxvb3IoaW5kZXgvZ3JpZFswXSk7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBmcm9tWSAtIHRvWTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLnNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7IHZhbHVlID0gLWRpc3RhbmNlWDsgfVxuICAgICAgICAgIGlmIChheGlzID09PSAneScpIHsgdmFsdWUgPSAtZGlzdGFuY2VZOyB9XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlYXNpbmcpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBlYXNpbmcodmFsIC8gbWF4VmFsdWUpICogbWF4VmFsdWU7IH0pOyB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAncmV2ZXJzZScpIHsgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBheGlzID8gKHZhbCA8IDApID8gdmFsICogLTEgOiAtdmFsIDogTWF0aC5hYnMobWF4VmFsdWUgLSB2YWwpOyB9KTsgfVxuICAgIH1cbiAgICB2YXIgc3BhY2luZyA9IGlzUmFuZ2UgPyAodmFsMiAtIHZhbDEpIC8gbWF4VmFsdWUgOiB2YWwxO1xuICAgIHJldHVybiBzdGFydCArIChzcGFjaW5nICogKE1hdGgucm91bmQodmFsdWVzW2ldICogMTAwKSAvIDEwMCkpICsgdW5pdDtcbiAgfVxufVxuXG4vLyBUaW1lbGluZVxuXG5mdW5jdGlvbiB0aW1lbGluZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG4gIHZhciB0bCA9IGFuaW1lKHBhcmFtcyk7XG4gIHRsLmR1cmF0aW9uID0gMDtcbiAgdGwuYWRkID0gZnVuY3Rpb24oaW5zdGFuY2VQYXJhbXMsIHRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgdmFyIHRsSW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZih0bCk7XG4gICAgdmFyIGNoaWxkcmVuID0gdGwuY2hpbGRyZW47XG4gICAgaWYgKHRsSW5kZXggPiAtMSkgeyBhY3RpdmVJbnN0YW5jZXMuc3BsaWNlKHRsSW5kZXgsIDEpOyB9XG4gICAgZnVuY3Rpb24gcGFzc1Rocm91Z2goaW5zKSB7IGlucy5wYXNzVGhyb3VnaCA9IHRydWU7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IHBhc3NUaHJvdWdoKGNoaWxkcmVuW2ldKTsgfVxuICAgIHZhciBpbnNQYXJhbXMgPSBtZXJnZU9iamVjdHMoaW5zdGFuY2VQYXJhbXMsIHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0VHdlZW5TZXR0aW5ncywgcGFyYW1zKSk7XG4gICAgaW5zUGFyYW1zLnRhcmdldHMgPSBpbnNQYXJhbXMudGFyZ2V0cyB8fCBwYXJhbXMudGFyZ2V0cztcbiAgICB2YXIgdGxEdXJhdGlvbiA9IHRsLmR1cmF0aW9uO1xuICAgIGluc1BhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgIGluc1BhcmFtcy5kaXJlY3Rpb24gPSB0bC5kaXJlY3Rpb247XG4gICAgaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0ID0gaXMudW5kKHRpbWVsaW5lT2Zmc2V0KSA/IHRsRHVyYXRpb24gOiBnZXRSZWxhdGl2ZVZhbHVlKHRpbWVsaW5lT2Zmc2V0LCB0bER1cmF0aW9uKTtcbiAgICBwYXNzVGhyb3VnaCh0bCk7XG4gICAgdGwuc2VlayhpbnNQYXJhbXMudGltZWxpbmVPZmZzZXQpO1xuICAgIHZhciBpbnMgPSBhbmltZShpbnNQYXJhbXMpO1xuICAgIHBhc3NUaHJvdWdoKGlucyk7XG4gICAgY2hpbGRyZW4ucHVzaChpbnMpO1xuICAgIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGNoaWxkcmVuLCBwYXJhbXMpO1xuICAgIHRsLmRlbGF5ID0gdGltaW5ncy5kZWxheTtcbiAgICB0bC5lbmREZWxheSA9IHRpbWluZ3MuZW5kRGVsYXk7XG4gICAgdGwuZHVyYXRpb24gPSB0aW1pbmdzLmR1cmF0aW9uO1xuICAgIHRsLnNlZWsoMCk7XG4gICAgdGwucmVzZXQoKTtcbiAgICBpZiAodGwuYXV0b3BsYXkpIHsgdGwucGxheSgpOyB9XG4gICAgcmV0dXJuIHRsO1xuICB9O1xuICByZXR1cm4gdGw7XG59XG5cbmFuaW1lLnZlcnNpb24gPSAnMy4yLjEnO1xuYW5pbWUuc3BlZWQgPSAxO1xuLy8gVE9ETzojcmV2aWV3OiBuYW1pbmcsIGRvY3VtZW50YXRpb25cbmFuaW1lLnN1c3BlbmRXaGVuRG9jdW1lbnRIaWRkZW4gPSB0cnVlO1xuYW5pbWUucnVubmluZyA9IGFjdGl2ZUluc3RhbmNlcztcbmFuaW1lLnJlbW92ZSA9IHJlbW92ZVRhcmdldHNGcm9tQWN0aXZlSW5zdGFuY2VzO1xuYW5pbWUuZ2V0ID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZTtcbmFuaW1lLnNldCA9IHNldFRhcmdldHNWYWx1ZTtcbmFuaW1lLmNvbnZlcnRQeCA9IGNvbnZlcnRQeFRvVW5pdDtcbmFuaW1lLnBhdGggPSBnZXRQYXRoO1xuYW5pbWUuc2V0RGFzaG9mZnNldCA9IHNldERhc2hvZmZzZXQ7XG5hbmltZS5zdGFnZ2VyID0gc3RhZ2dlcjtcbmFuaW1lLnRpbWVsaW5lID0gdGltZWxpbmU7XG5hbmltZS5lYXNpbmcgPSBwYXJzZUVhc2luZ3M7XG5hbmltZS5wZW5uZXIgPSBwZW5uZXI7XG5hbmltZS5yYW5kb20gPSBmdW5jdGlvbiAobWluLCBtYXgpIHsgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47IH07XG5cbmV4cG9ydCBkZWZhdWx0IGFuaW1lO1xuIl0sIm5hbWVzIjpbImRlZmF1bHRJbnN0YW5jZVNldHRpbmdzIiwidXBkYXRlIiwiYmVnaW4iLCJsb29wQmVnaW4iLCJjaGFuZ2VCZWdpbiIsImNoYW5nZSIsImNoYW5nZUNvbXBsZXRlIiwibG9vcENvbXBsZXRlIiwiY29tcGxldGUiLCJsb29wIiwiZGlyZWN0aW9uIiwiYXV0b3BsYXkiLCJ0aW1lbGluZU9mZnNldCIsImRlZmF1bHRUd2VlblNldHRpbmdzIiwiZHVyYXRpb24iLCJkZWxheSIsImVuZERlbGF5IiwiZWFzaW5nIiwicm91bmQiLCJ2YWxpZFRyYW5zZm9ybXMiLCJjYWNoZSIsIkNTUyIsInNwcmluZ3MiLCJtaW5NYXgiLCJ2YWwiLCJtaW4iLCJtYXgiLCJNYXRoIiwic3RyaW5nQ29udGFpbnMiLCJzdHIiLCJ0ZXh0IiwiaW5kZXhPZiIsImFwcGx5QXJndW1lbnRzIiwiZnVuYyIsImFyZ3MiLCJhcHBseSIsImlzIiwiYXJyIiwiYSIsIkFycmF5IiwiaXNBcnJheSIsIm9iaiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInB0aCIsImhhc093blByb3BlcnR5Iiwic3ZnIiwiU1ZHRWxlbWVudCIsImlucCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJkb20iLCJub2RlVHlwZSIsImZuYyIsInVuZCIsIm5pbCIsImhleCIsInRlc3QiLCJyZ2IiLCJoc2wiLCJjb2wiLCJrZXkiLCJwYXJzZUVhc2luZ1BhcmFtZXRlcnMiLCJzdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJzcGxpdCIsIm1hcCIsInAiLCJwYXJzZUZsb2F0Iiwic3ByaW5nIiwicGFyYW1zIiwibWFzcyIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJ2ZWxvY2l0eSIsIncwIiwic3FydCIsInpldGEiLCJ3ZCIsImIiLCJzb2x2ZXIiLCJ0IiwicHJvZ3Jlc3MiLCJleHAiLCJjb3MiLCJzaW4iLCJnZXREdXJhdGlvbiIsImNhY2hlZCIsImZyYW1lIiwiZWxhcHNlZCIsInJlc3QiLCJzdGVwcyIsImNlaWwiLCJiZXppZXIiLCJrU3BsaW5lVGFibGVTaXplIiwia1NhbXBsZVN0ZXBTaXplIiwiQSIsImFBMSIsImFBMiIsIkIiLCJDIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsImFBIiwiYUIiLCJtWDEiLCJtWDIiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwiaSIsImFicyIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsIm1ZMSIsIm1ZMiIsInNhbXBsZVZhbHVlcyIsIkZsb2F0MzJBcnJheSIsImdldFRGb3JYIiwiaW50ZXJ2YWxTdGFydCIsImN1cnJlbnRTYW1wbGUiLCJsYXN0U2FtcGxlIiwiZGlzdCIsImd1ZXNzRm9yVCIsImluaXRpYWxTbG9wZSIsIngiLCJwZW5uZXIiLCJlYXNlcyIsImxpbmVhciIsImZ1bmN0aW9uRWFzaW5ncyIsIlNpbmUiLCJQSSIsIkV4cG8iLCJwb3ciLCJDaXJjIiwiQmFjayIsIkJvdW5jZSIsInBvdzIiLCJFbGFzdGljIiwiYW1wbGl0dWRlIiwicGVyaW9kIiwiYXNpbiIsImJhc2VFYXNpbmdzIiwiZm9yRWFjaCIsIm5hbWUiLCJrZXlzIiwiZWFzZUluIiwicGFyc2VFYXNpbmdzIiwiZWFzZSIsInNlbGVjdFN0cmluZyIsIm5vZGVzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZSIsImZpbHRlckFycmF5IiwiY2FsbGJhY2siLCJsZW4iLCJsZW5ndGgiLCJ0aGlzQXJnIiwiYXJndW1lbnRzIiwicmVzdWx0IiwicHVzaCIsImZsYXR0ZW5BcnJheSIsInJlZHVjZSIsImNvbmNhdCIsInRvQXJyYXkiLCJvIiwiTm9kZUxpc3QiLCJIVE1MQ29sbGVjdGlvbiIsInNsaWNlIiwiYXJyYXlDb250YWlucyIsInNvbWUiLCJjbG9uZU9iamVjdCIsImNsb25lIiwicmVwbGFjZU9iamVjdFByb3BzIiwibzEiLCJvMiIsIm1lcmdlT2JqZWN0cyIsInJnYlRvUmdiYSIsInJnYlZhbHVlIiwiaGV4VG9SZ2JhIiwiaGV4VmFsdWUiLCJyZ3giLCJyZXBsYWNlIiwibSIsInIiLCJnIiwicGFyc2VJbnQiLCJoc2xUb1JnYmEiLCJoc2xWYWx1ZSIsImgiLCJzIiwibCIsImh1ZTJyZ2IiLCJxIiwiY29sb3JUb1JnYiIsImdldFVuaXQiLCJnZXRUcmFuc2Zvcm1Vbml0IiwicHJvcE5hbWUiLCJnZXRGdW5jdGlvblZhbHVlIiwiYW5pbWF0YWJsZSIsInRhcmdldCIsImlkIiwidG90YWwiLCJnZXRBdHRyaWJ1dGUiLCJlbCIsInByb3AiLCJjb252ZXJ0UHhUb1VuaXQiLCJ2YWx1ZSIsInVuaXQiLCJ2YWx1ZVVuaXQiLCJiYXNlbGluZSIsInRlbXBFbCIsImNyZWF0ZUVsZW1lbnQiLCJ0YWdOYW1lIiwicGFyZW50RWwiLCJwYXJlbnROb2RlIiwiYm9keSIsImFwcGVuZENoaWxkIiwic3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiZmFjdG9yIiwib2Zmc2V0V2lkdGgiLCJyZW1vdmVDaGlsZCIsImNvbnZlcnRlZFVuaXQiLCJnZXRDU1NWYWx1ZSIsInVwcGVyY2FzZVByb3BOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImdldEFuaW1hdGlvblR5cGUiLCJnZXRFbGVtZW50VHJhbnNmb3JtcyIsInRyYW5zZm9ybSIsInJlZyIsInRyYW5zZm9ybXMiLCJNYXAiLCJzZXQiLCJnZXRUcmFuc2Zvcm1WYWx1ZSIsImRlZmF1bHRWYWwiLCJnZXQiLCJsaXN0IiwiZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZSIsImdldFJlbGF0aXZlVmFsdWUiLCJ0byIsImZyb20iLCJvcGVyYXRvciIsInUiLCJ5IiwidmFsaWRhdGVWYWx1ZSIsIm9yaWdpbmFsVW5pdCIsInVuaXRMZXNzIiwic3Vic3RyIiwiZ2V0RGlzdGFuY2UiLCJwMSIsInAyIiwiZ2V0Q2lyY2xlTGVuZ3RoIiwiZ2V0UmVjdExlbmd0aCIsImdldExpbmVMZW5ndGgiLCJnZXRQb2x5bGluZUxlbmd0aCIsInBvaW50cyIsInRvdGFsTGVuZ3RoIiwicHJldmlvdXNQb3MiLCJudW1iZXJPZkl0ZW1zIiwiY3VycmVudFBvcyIsImdldEl0ZW0iLCJnZXRQb2x5Z29uTGVuZ3RoIiwiZ2V0VG90YWxMZW5ndGgiLCJzZXREYXNob2Zmc2V0IiwicGF0aExlbmd0aCIsInNldEF0dHJpYnV0ZSIsImdldFBhcmVudFN2Z0VsIiwiZ2V0UGFyZW50U3ZnIiwicGF0aEVsIiwic3ZnRGF0YSIsInBhcmVudFN2Z0VsIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInZpZXdCb3hBdHRyIiwiaGVpZ2h0Iiwidmlld0JveCIsInciLCJ2VyIsInZIIiwiZ2V0UGF0aCIsInBhdGgiLCJwZXJjZW50IiwicHJvcGVydHkiLCJnZXRQYXRoUHJvZ3Jlc3MiLCJpc1BhdGhUYXJnZXRJbnNpZGVTVkciLCJwb2ludCIsIm9mZnNldCIsImdldFBvaW50QXRMZW5ndGgiLCJwMCIsInNjYWxlWCIsInNjYWxlWSIsImF0YW4yIiwiZGVjb21wb3NlVmFsdWUiLCJvcmlnaW5hbCIsIm51bWJlcnMiLCJOdW1iZXIiLCJzdHJpbmdzIiwicGFyc2VUYXJnZXRzIiwidGFyZ2V0cyIsInRhcmdldHNBcnJheSIsIml0ZW0iLCJwb3MiLCJzZWxmIiwiZ2V0QW5pbWF0YWJsZXMiLCJwYXJzZWQiLCJub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyIsInR3ZWVuU2V0dGluZ3MiLCJzZXR0aW5ncyIsImlzRnJvbVRvIiwicHJvcEFycmF5IiwidiIsImsiLCJmbGF0dGVuS2V5ZnJhbWVzIiwia2V5ZnJhbWVzIiwicHJvcGVydHlOYW1lcyIsInByb3BlcnRpZXMiLCJuZXdLZXkiLCJnZXRQcm9wZXJ0aWVzIiwidHdlZW5zIiwibm9ybWFsaXplVHdlZW5WYWx1ZXMiLCJ0d2VlbiIsIm5vcm1hbGl6ZVR3ZWVucyIsInByZXZpb3VzVHdlZW4iLCJ0d2VlblZhbHVlIiwidG9Vbml0Iiwib3JpZ2luYWxWYWx1ZSIsInByZXZpb3VzVmFsdWUiLCJmcm9tVW5pdCIsInN0YXJ0IiwiZW5kIiwiaXNQYXRoIiwiaXNDb2xvciIsInNldFByb2dyZXNzVmFsdWUiLCJjc3MiLCJhdHRyaWJ1dGUiLCJvYmplY3QiLCJtYW51YWwiLCJsYXN0Iiwic2V0VGFyZ2V0c1ZhbHVlIiwiYW5pbWF0YWJsZXMiLCJhbmltVHlwZSIsImNyZWF0ZUFuaW1hdGlvbiIsImxhc3RUd2VlbiIsInR5cGUiLCJnZXRBbmltYXRpb25zIiwiZ2V0SW5zdGFuY2VUaW1pbmdzIiwiYW5pbWF0aW9ucyIsImFuaW1MZW5ndGgiLCJnZXRUbE9mZnNldCIsImFuaW0iLCJ0aW1pbmdzIiwiaW5zdGFuY2VJRCIsImNyZWF0ZU5ld0luc3RhbmNlIiwiaW5zdGFuY2VTZXR0aW5ncyIsImNoaWxkcmVuIiwiYWN0aXZlSW5zdGFuY2VzIiwiZW5naW5lIiwicmFmIiwicGxheSIsImlzRG9jdW1lbnRIaWRkZW4iLCJhbmltZSIsInN1c3BlbmRXaGVuRG9jdW1lbnRIaWRkZW4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdGVwIiwiYWN0aXZlSW5zdGFuY2VzTGVuZ3RoIiwiYWN0aXZlSW5zdGFuY2UiLCJwYXVzZWQiLCJ0aWNrIiwic3BsaWNlIiwidW5kZWZpbmVkIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaW5zdGFuY2UiLCJfb25Eb2N1bWVudFZpc2liaWxpdHkiLCJhZGRFdmVudExpc3RlbmVyIiwiaGlkZGVuIiwic3RhcnRUaW1lIiwibGFzdFRpbWUiLCJub3ciLCJjaGlsZHJlbkxlbmd0aCIsInJlc29sdmUiLCJtYWtlUHJvbWlzZSIsInByb21pc2UiLCJ3aW5kb3ciLCJQcm9taXNlIiwiX3Jlc29sdmUiLCJmaW5pc2hlZCIsInRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uIiwicmV2ZXJzZWQiLCJjaGlsZCIsImFkanVzdFRpbWUiLCJ0aW1lIiwicmVzZXRUaW1lIiwiY3VycmVudFRpbWUiLCJzcGVlZCIsInNlZWtDaGlsZCIsInNlZWsiLCJzeW5jSW5zdGFuY2VDaGlsZHJlbiIsInJldmVyc2VQbGF5YmFjayIsImkkMSIsInNldEFuaW1hdGlvbnNQcm9ncmVzcyIsImluc1RpbWUiLCJhbmltYXRpb25zTGVuZ3RoIiwidHdlZW5MZW5ndGgiLCJlYXNlZCIsImlzTmFOIiwidG9OdW1iZXJzTGVuZ3RoIiwibiIsInRvTnVtYmVyIiwiZnJvbU51bWJlciIsInN0cmluZ3NMZW5ndGgiLCJuJDEiLCJjdXJyZW50VmFsdWUiLCJzZXRDYWxsYmFjayIsImNiIiwicGFzc1Rocm91Z2giLCJjb3VudEl0ZXJhdGlvbiIsInJlbWFpbmluZyIsInNldEluc3RhbmNlUHJvZ3Jlc3MiLCJlbmdpbmVUaW1lIiwiaW5zRHVyYXRpb24iLCJpbnNEZWxheSIsImluc0VuZERlbGF5IiwiYmVnYW4iLCJsb29wQmVnYW4iLCJjaGFuZ2VCZWdhbiIsImNoYW5nZUNvbXBsZXRlZCIsImNvbXBsZXRlZCIsInJlc2V0IiwicGF1c2UiLCJyZXZlcnNlIiwicmVzdGFydCIsInJlbW92ZSIsInJlbW92ZVRhcmdldHNGcm9tSW5zdGFuY2UiLCJyZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbnMiLCJjIiwiY2hpbGRBbmltYXRpb25zIiwicmVtb3ZlVGFyZ2V0c0Zyb21BY3RpdmVJbnN0YW5jZXMiLCJzdGFnZ2VyIiwiZ3JpZCIsImF4aXMiLCJmcm9tSW5kZXgiLCJmcm9tRmlyc3QiLCJmcm9tQ2VudGVyIiwiZnJvbUxhc3QiLCJpc1JhbmdlIiwidmFsMSIsInZhbDIiLCJ2YWx1ZXMiLCJtYXhWYWx1ZSIsImluZGV4IiwiZnJvbVgiLCJmcm9tWSIsImZsb29yIiwidG9YIiwidG9ZIiwiZGlzdGFuY2VYIiwiZGlzdGFuY2VZIiwic3BhY2luZyIsInRpbWVsaW5lIiwidGwiLCJhZGQiLCJpbnN0YW5jZVBhcmFtcyIsInRsSW5kZXgiLCJpbnMiLCJpbnNQYXJhbXMiLCJ0bER1cmF0aW9uIiwidmVyc2lvbiIsInJ1bm5pbmciLCJjb252ZXJ0UHgiLCJyYW5kb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/animejs/lib/anime.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/animation/opening/Opening.jsx":
/*!*******************************************!*\
  !*** ./src/animation/opening/Opening.jsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/gsap/index.js\");\n/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! animejs */ \"(app-pages-browser)/./node_modules/animejs/lib/anime.es.js\");\n/* harmony import */ var _Opening_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Opening.css */ \"(app-pages-browser)/./src/animation/opening/Opening.css\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst Opening = (param)=>{\n    let { isLoading } = param;\n    _s();\n    const [animationComplete, setAnimationComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const counterRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const titleRefs = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const cairoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const barsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Array(5).fill(null));\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let currentValue = 0;\n        const updateCounter = ()=>{\n            currentValue++;\n            if (currentValue <= 100) {\n                if (counterRef.current) {\n                    counterRef.current.textContent = currentValue;\n                }\n            } else {\n                clearInterval(interval);\n                setAnimationComplete(true);\n            }\n        };\n        const interval = setInterval(updateCounter, 30);\n        return ()=>clearInterval(interval);\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // if (animationComplete) {\n        //     const tl = gsap.timeline({\n        //         onComplete: () => {\n        //             sessionStorage.setItem('hasAnimationShown', 'true');\n        //             isLoading();\n        //         }\n        //     });\n        //     tl.to(\".counter\", { duration: 0.5, opacity: 0, ease: 'power2.inOut' });\n        //     tl.to(cairoRef.current, { opacity: 1, duration: 2, ease: 'power2.inOut' })\n        //         .to(cairoRef.current, { opacity: 0, duration: 1, ease: 'power2.inOut' });\n        //     barsRef.current.forEach(bar => {\n        //         tl.to(bar, {\n        //             duration: 2,\n        //             opacity: 1,\n        //             height: 0,\n        //             y: -400,\n        //             ease: 'power3.inOut'\n        //         }, \"<\");\n        //     });\n        // }\n        gsap__WEBPACK_IMPORTED_MODULE_4__[\"default\"].to(\".count\", {\n            opacity: 0,\n            delay: 3.5,\n            deuration: 5\n        });\n        let textWrapper = document.querySelector(\".ml16\");\n        textWrapper.innerHTML = textWrapper.textContent.replace(/\\S/g, \"<span class='letter'>$&</span>\");\n        animejs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].timeline({\n            loop: false\n        }).add({\n            targets: \".ml16 .letter\",\n            translateY: [\n                -100,\n                0\n            ],\n            easing: \"easeOutExpo\",\n            duration: 1400,\n            delay: (el, i)=>30 * i\n        }).add({\n            targets: \".ml16 .letter\",\n            translateY: [\n                0,\n                100\n            ],\n            duration: 1000,\n            easing: \"easeOutExpo\",\n            delay: (el, i)=>2000 + 30 * i\n        });\n    }, [\n        animationComplete,\n        isLoading\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"preloader\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"loader\"\n                    }, void 0, false, {\n                        fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                        lineNumber: 84,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"loader-bg\"\n                    }, void 0, false, {\n                        fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                        lineNumber: 85,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                lineNumber: 83,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"loader-content\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"count\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            ref: counterRef,\n                            children: \"0\"\n                        }, void 0, false, {\n                            fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                            lineNumber: 88,\n                            columnNumber: 40\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                        lineNumber: 88,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"copy\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"ml16\",\n                            children: \"F365\"\n                        }, void 0, false, {\n                            fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                            lineNumber: 89,\n                            columnNumber: 39\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                        lineNumber: 89,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                lineNumber: 87,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"loader-2\"\n            }, void 0, false, {\n                fileName: \"/Users/shehabwaleed/Development/work/f356/src/animation/opening/Opening.jsx\",\n                lineNumber: 91,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true);\n};\n_s(Opening, \"S1Vv03zzM64JLpAI+2zQvXxRbSQ=\");\n_c = Opening;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Opening);\nvar _c;\n$RefreshReg$(_c, \"Opening\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hbmltYXRpb24vb3BlbmluZy9PcGVuaW5nLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkQ7QUFDbkM7QUFDSTtBQUNMO0FBRXZCLE1BQU1NLFVBQVU7UUFBQyxFQUFFQyxTQUFTLEVBQUU7O0lBQzFCLE1BQU0sQ0FBQ0MsbUJBQW1CQyxxQkFBcUIsR0FBR1AsK0NBQVFBLENBQUM7SUFDM0QsTUFBTVEsYUFBYVAsNkNBQU1BLENBQUM7SUFDMUIsTUFBTVEsWUFBWVIsNkNBQU1BLENBQUMsRUFBRTtJQUMzQixNQUFNUyxXQUFXVCw2Q0FBTUEsQ0FBQztJQUN4QixNQUFNVSxVQUFVViw2Q0FBTUEsQ0FBQyxJQUFJVyxNQUFNLEdBQUdDLElBQUksQ0FBQztJQUd6Q2QsZ0RBQVNBLENBQUM7UUFDTixJQUFJZSxlQUFlO1FBQ25CLE1BQU1DLGdCQUFnQjtZQUNsQkQ7WUFDQSxJQUFJQSxnQkFBZ0IsS0FBSztnQkFDckIsSUFBSU4sV0FBV1EsT0FBTyxFQUFFO29CQUNwQlIsV0FBV1EsT0FBTyxDQUFDQyxXQUFXLEdBQUdIO2dCQUNyQztZQUNKLE9BQU87Z0JBQ0hJLGNBQWNDO2dCQUNkWixxQkFBcUI7WUFDekI7UUFDSjtRQUVBLE1BQU1ZLFdBQVdDLFlBQVlMLGVBQWU7UUFDNUMsT0FBTyxJQUFNRyxjQUFjQztJQUMvQixHQUFHLEVBQUU7SUFFTHBCLGdEQUFTQSxDQUFDO1FBQ04sMkJBQTJCO1FBQzNCLGlDQUFpQztRQUNqQyw4QkFBOEI7UUFDOUIsbUVBQW1FO1FBQ25FLDJCQUEyQjtRQUMzQixZQUFZO1FBQ1osVUFBVTtRQUVWLDhFQUE4RTtRQUU5RSxpRkFBaUY7UUFDakYsb0ZBQW9GO1FBRXBGLHVDQUF1QztRQUN2Qyx1QkFBdUI7UUFDdkIsMkJBQTJCO1FBQzNCLDBCQUEwQjtRQUMxQix5QkFBeUI7UUFDekIsdUJBQXVCO1FBQ3ZCLG1DQUFtQztRQUNuQyxtQkFBbUI7UUFDbkIsVUFBVTtRQUNWLElBQUk7UUFFSkcsNENBQUlBLENBQUNtQixFQUFFLENBQUMsVUFBVTtZQUFFQyxTQUFTO1lBQUdDLE9BQU87WUFBS0MsV0FBVztRQUFFO1FBQ3pELElBQUlDLGNBQWNDLFNBQVNDLGFBQWEsQ0FBQztRQUN6Q0YsWUFBWUcsU0FBUyxHQUFHSCxZQUFZUixXQUFXLENBQUNZLE9BQU8sQ0FBQyxPQUFPO1FBQy9EMUIsK0NBQUtBLENBQUMyQixRQUFRLENBQUM7WUFBRUMsTUFBTTtRQUFNLEdBQ3hCQyxHQUFHLENBQUM7WUFDREMsU0FBUztZQUNUQyxZQUFZO2dCQUFDLENBQUM7Z0JBQUs7YUFBRTtZQUNyQkMsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZiLE9BQU8sQ0FBQ2MsSUFBSUMsSUFBTSxLQUFLQTtRQUMzQixHQUFHTixHQUFHLENBQUM7WUFDSEMsU0FBUztZQUNUQyxZQUFZO2dCQUFDO2dCQUFHO2FBQUk7WUFDcEJFLFVBQVU7WUFDVkQsUUFBUTtZQUNSWixPQUFPLENBQUNjLElBQUlDLElBQU0sT0FBTyxLQUFLQTtRQUNsQztJQUtSLEdBQUc7UUFBQ2hDO1FBQW1CRDtLQUFVO0lBRWpDLHFCQUVJOzswQkFDSSw4REFBQ2tDO2dCQUFJQyxXQUFVOztrQ0FDWCw4REFBQ0Q7d0JBQUlDLFdBQVU7Ozs7OztrQ0FDZiw4REFBQ0Q7d0JBQUlDLFdBQVU7Ozs7Ozs7Ozs7OzswQkFFbkIsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDWCw4REFBQ0Q7d0JBQUlDLFdBQVU7a0NBQVEsNEVBQUNDOzRCQUFFQyxLQUFLbEM7c0NBQVk7Ozs7Ozs7Ozs7O2tDQUMzQyw4REFBQytCO3dCQUFJQyxXQUFVO2tDQUFPLDRFQUFDQzs0QkFBRUQsV0FBVTtzQ0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBRTlDLDhEQUFDRDtnQkFBSUMsV0FBVTs7Ozs7Ozs7QUFNM0I7R0EzRk1wQztLQUFBQTtBQTZGTiwrREFBZUEsT0FBT0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYW5pbWF0aW9uL29wZW5pbmcvT3BlbmluZy5qc3g/NDM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XG5pbXBvcnQgYW5pbWUgZnJvbSAnYW5pbWVqcyc7XG5pbXBvcnQgJy4vT3BlbmluZy5jc3MnO1xuXG5jb25zdCBPcGVuaW5nID0gKHsgaXNMb2FkaW5nIH0pID0+IHtcbiAgICBjb25zdCBbYW5pbWF0aW9uQ29tcGxldGUsIHNldEFuaW1hdGlvbkNvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBjb3VudGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHRpdGxlUmVmcyA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgY2Fpcm9SZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgYmFyc1JlZiA9IHVzZVJlZihuZXcgQXJyYXkoNSkuZmlsbChudWxsKSk7XG5cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSAwO1xuICAgICAgICBjb25zdCB1cGRhdGVDb3VudGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlKys7XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIDw9IDEwMCkge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclJlZi5jdXJyZW50LnRleHRDb250ZW50ID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgc2V0QW5pbWF0aW9uQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh1cGRhdGVDb3VudGVyLCAzMCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBpZiAoYW5pbWF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgLy8gICAgIGNvbnN0IHRsID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgIC8vICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdoYXNBbmltYXRpb25TaG93bicsICd0cnVlJyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIGlzTG9hZGluZygpO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH0pO1xuXG4gICAgICAgIC8vICAgICB0bC50byhcIi5jb3VudGVyXCIsIHsgZHVyYXRpb246IDAuNSwgb3BhY2l0eTogMCwgZWFzZTogJ3Bvd2VyMi5pbk91dCcgfSk7XG5cbiAgICAgICAgLy8gICAgIHRsLnRvKGNhaXJvUmVmLmN1cnJlbnQsIHsgb3BhY2l0eTogMSwgZHVyYXRpb246IDIsIGVhc2U6ICdwb3dlcjIuaW5PdXQnIH0pXG4gICAgICAgIC8vICAgICAgICAgLnRvKGNhaXJvUmVmLmN1cnJlbnQsIHsgb3BhY2l0eTogMCwgZHVyYXRpb246IDEsIGVhc2U6ICdwb3dlcjIuaW5PdXQnIH0pO1xuXG4gICAgICAgIC8vICAgICBiYXJzUmVmLmN1cnJlbnQuZm9yRWFjaChiYXIgPT4ge1xuICAgICAgICAvLyAgICAgICAgIHRsLnRvKGJhciwge1xuICAgICAgICAvLyAgICAgICAgICAgICBkdXJhdGlvbjogMixcbiAgICAgICAgLy8gICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgLy8gICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAvLyAgICAgICAgICAgICB5OiAtNDAwLFxuICAgICAgICAvLyAgICAgICAgICAgICBlYXNlOiAncG93ZXIzLmluT3V0J1xuICAgICAgICAvLyAgICAgICAgIH0sIFwiPFwiKTtcbiAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgZ3NhcC50byhcIi5jb3VudFwiLCB7IG9wYWNpdHk6IDAsIGRlbGF5OiAzLjUsIGRldXJhdGlvbjogNSB9KTtcbiAgICAgICAgbGV0IHRleHRXcmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1sMTYnKTtcbiAgICAgICAgdGV4dFdyYXBwZXIuaW5uZXJIVE1MID0gdGV4dFdyYXBwZXIudGV4dENvbnRlbnQucmVwbGFjZSgvXFxTL2csIFwiPHNwYW4gY2xhc3M9J2xldHRlcic+JCY8L3NwYW4+XCIpO1xuICAgICAgICBhbmltZS50aW1lbGluZSh7IGxvb3A6IGZhbHNlIH0pXG4gICAgICAgICAgICAuYWRkKHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiAnLm1sMTYgLmxldHRlcicsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogWy0xMDAsIDBdLFxuICAgICAgICAgICAgICAgIGVhc2luZzogXCJlYXNlT3V0RXhwb1wiLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxNDAwLFxuICAgICAgICAgICAgICAgIGRlbGF5OiAoZWwsIGkpID0+IDMwICogaVxuICAgICAgICAgICAgfSkuYWRkKHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiAnLm1sMTYgLmxldHRlcicsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogWzAsIDEwMF0sXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICAgICAgICAgICAgZWFzaW5nOiBcImVhc2VPdXRFeHBvXCIsXG4gICAgICAgICAgICAgICAgZGVsYXk6IChlbCwgaSkgPT4gMjAwMCArIDMwICogaVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIFxuICAgICAgICBcblxuICAgIH0sIFthbmltYXRpb25Db21wbGV0ZSwgaXNMb2FkaW5nXSk7XG5cbiAgICByZXR1cm4gKFxuXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ncHJlbG9hZGVyJz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nbG9hZGVyJz48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nbG9hZGVyLWJnJz48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsb2FkZXItY29udGVudFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb3VudCc+PHAgcmVmPXtjb3VudGVyUmVmfT4wPC9wPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb3B5Jz48cCBjbGFzc05hbWU9J21sMTYnPkYzNjU8L3A+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdsb2FkZXItMic+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cblxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBPcGVuaW5nO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJnc2FwIiwiYW5pbWUiLCJPcGVuaW5nIiwiaXNMb2FkaW5nIiwiYW5pbWF0aW9uQ29tcGxldGUiLCJzZXRBbmltYXRpb25Db21wbGV0ZSIsImNvdW50ZXJSZWYiLCJ0aXRsZVJlZnMiLCJjYWlyb1JlZiIsImJhcnNSZWYiLCJBcnJheSIsImZpbGwiLCJjdXJyZW50VmFsdWUiLCJ1cGRhdGVDb3VudGVyIiwiY3VycmVudCIsInRleHRDb250ZW50IiwiY2xlYXJJbnRlcnZhbCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ0byIsIm9wYWNpdHkiLCJkZWxheSIsImRldXJhdGlvbiIsInRleHRXcmFwcGVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiaW5uZXJIVE1MIiwicmVwbGFjZSIsInRpbWVsaW5lIiwibG9vcCIsImFkZCIsInRhcmdldHMiLCJ0cmFuc2xhdGVZIiwiZWFzaW5nIiwiZHVyYXRpb24iLCJlbCIsImkiLCJkaXYiLCJjbGFzc05hbWUiLCJwIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/animation/opening/Opening.jsx\n"));

/***/ })

});